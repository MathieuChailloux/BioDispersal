# -*- coding: utf-8 -*-
"""
/***************************************************************************
 BioDispersal
                                 A QGIS plugin
 Computes ecological continuities based on environments permeability
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2018-04-12
        git sha              : $Format:%H$
        copyright            : (C) 2018 by IRSTEA
        email                : mathieu.chailloux@irstea.fr
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import csv
import os

from PyQt5.QtCore import Qt, QModelIndex
from PyQt5.QtGui import QIcon
from PyQt5.QtWidgets import QFileDialog
from qgis.gui import QgsFileWidget

from ..qgis_lib_mc import utils, qgsUtils, qgsTreatments, abstract_model, feedbacks, styles
from . import params, subnetworks, classes


class FrictionRowItem(abstract_model.DictItem):

    def __init__(self,dict):
        super().__init__(dict)
            

class FrictionModel(abstract_model.DictModel):

    def __init__(self,bdModel):
        self.parser_name = "FrictionModel"
        self.is_runnable = True
        self.bdModel = bdModel
        self.defaultVal = None
        self.classes = []
        self.fields = ["class_descr","class","code"]
        super().__init__(self,self.fields)
        
    # True if item matching class 'cls_name' exists, False otherwise.
    def classExists(self,cls_name):
        for fr in self.items:
            if fr.dict["class"] == cls_name:
                return True
        return False
        
    # Returns item matching class 'cls_name', None if there is no match.
    def getRowByClass(self,cls_name):
        for i in self.items:
            if i.dict["class"] == cls_name:
                return i
        return None
        
    # Adds new FrictionRowItem in model from given ClassItem.
    def addClassItem(self,cls_item):
        new_row = {"class_descr" : cls_item.dict["descr"],
                   "class" : cls_item.dict["name"],
                   "code" : cls_item.dict["code"]}
        self.addSTCols(new_row)
        row_item = FrictionRowItem(new_row)
        if not self.classExists(cls_item.dict["name"]):
            if cls_item not in self.classes:
                self.classes.append(cls_item)
            self.addItem(row_item)
            self.layoutChanged.emit()
        
    # Removes item matching class 'name' from model.
    def removeClassFromName(self,name):
        utils.debug("removing class " + str(name) + " from friction")
        self.classes = [cls_item for cls_item in self.classes if cls_item.dict["name"] != name]
        for i in range(0,len(self.items)):
            if self.items[i].dict["class"] == name:
                del self.items[i]
                self.layoutChanged.emit()
                return
        
    # Adds subnetwork columns to given FrictionRowItem.
    # Friction values are set to defaultVal (None).
    def addSTCols(self,row):
        utils.debug("addSTCols")
        for st in self.bdModel.stModel.getSTList():
            row[st] = self.defaultVal
            
    # Adds new subnetwork entry to all items of model from given STItem.
    def addSTItem(self,st_item):
        utils.debug("addSTItem")
        st_name = st_item.dict["name"]
        utils.debug("ST addItem, items = " + str(self.bdModel.stModel))
        if st_name not in self.fields:
            for i in self.items:
                if st_name not in i.dict:
                    i.dict[st_name] = self.defaultVal
                    i.recompute()
            self.fields.append(st_name)
            self.layoutChanged.emit()
        
    # Removes subnetwork 'st_name' entry for all items of model.
    def removeSTFromName(self,st_name):
        utils.debug("removeSTFromName " + str(st_name))
        self.removeField(st_name)
        self.layoutChanged.emit()
        
    # Reload items of model to match current ClassModel.
    def reloadClasses(self):
        utils.debug("reloadClasses")
        classes_to_delete = []
        for item in self.items:
            cls_name = item.dict["class"]
            cls_item = self.bdModel.classModel.getClassByName(cls_name)
            if not cls_item:
                classes_to_delete.append(cls_name)
                utils.debug("Removing class " + str(cls_name))
            else:
                utils.debug("Class " + cls_name + " indeed exists")
        self.items = [fr for fr in self.items if fr.dict["class"] not in classes_to_delete]
        self.layoutChanged.emit()
        for cls_item in self.bdModel.classModel.items:
            utils.debug("cls_item : " + str(cls_item.dict))
            cls_name = cls_item.dict["name"]
            cls_code = cls_item.dict["code"]
            cls_descr = cls_item.dict["descr"]
            row_item = self.getRowByClass(cls_name)
            if row_item:
                utils.debug("row_item : " + str(row_item.dict))
                utils.debug("Class " + str(cls_name) + " already exists")
                if row_item.dict["code"] != cls_code:
                    utils.debug("Reassigning code '" + str(cls_code) + "' instead of '"
                                + str(row_item.dict["code"]) + " to class " + cls_name)
                    row_item.dict["code"] = cls_code
                    self.layoutChanged.emit()
                if cls_descr and row_item.dict["class_descr"] != cls_descr:
                    utils.debug("Reassigning descr '" + str(cls_descr) + "' instead of '"
                                + str(row_item.dict["class_descr"]) + " to class " + cls_name)
                    row_item.dict["class_descr"] = cls_descr
                    self.layoutChanged.emit()
            else:
                utils.debug("Reloading class " + cls_name)
                self.addClassItem(cls_item)
                self.layoutChanged.emit()
        
    # DEPRECATED : creates rules file for r.reclass call.
    # Algorithm native:reclassifybytable is now used instead.
    def createRulesFiles(self):
        utils.debug("createRulesFiles")
        for st_item in self.bdModel.stModel.items:
            st_name = st_item.dict["name"]
            utils.debug("createRulesFiles " + str(st_name))
            st_rules_fname = st_item.getRulesPath()
            with open(st_rules_fname,"w") as f:
                for i in self.items:
                    in_class = i.dict["code"]
                    out_class = i.dict[st_name]
                    f.write(str(in_class) + " = " + str(out_class) + "\n")
                    
    # Returns reclassify matrix (list) for native:reclassifybytable call.
    def getReclassifyMatrixes(self):
        st_list = self.bdModel.stModel.getSTList()
        matrixes = { st_name : [] for st_name in st_list }
        for item in self.items:
            for st in st_list:
                if st not in self.fields:
                    utils.internal_error("Subnetwork '" + str(st) + "' not found in friction model")
                new_val = item.dict[st]
                if new_val is None:
                    utils.user_error("No friction assigned to subnetwork " + str(st)
                                     + " for class " + str(item.dict["class"])
                                     + ", please type an integer value or 'None' string")
                if new_val == qgsTreatments.nodata_val:
                    assert(False)
                    utils.internal_error("Reclassify to nodata in " + str(item))
                try:
                    int(new_val)
                except ValueError:
                    utils.debug("Ignoring non-integer value " + str(new_val))
                    new_val = qgsTreatments.nodata_val
                matrixes[st] += [ item.dict["code"], item.dict["code"], new_val ]
        return matrixes
        
    # Returns set of item' code (value in input raster)
    def getCodes(self):
        codes = set([int(item.dict["code"]) for item in self.items])
        return codes
        
    # Raise an error in values of input raster do no match codes of friction items.
    def checkInVals(self,in_path):
        in_vals = qgsUtils.getRasterValsFromPath(in_path)
        codes = self.getCodes()
        diff = in_vals.difference(codes)
        if len(diff) > 0:
            utils.user_error("Some values of " + str(in_path) + " are not associated to a friction value " + str(diff))
          
    # DEPRECATED : old call to r.reclass
    def applyReclassProcessing(self):
        utils.debug("applyReclass")
        self.createRulesFiles()
        for st_item in self.bdModel.stModel.items:
            st_name = st_item.dict["name"]
            utils.debug("applyReclass " + str(st_name))
            st_rules_fname = st_item.getRulesPath()
            utils.checkFileExists(st_rules_fname)
            st_merged_fname = st_item.getMergedPath()
            utils.checkFileExists(st_merged_fname)
            st_friction_fname = st_item.getFrictionPath()
            qgsTreatments.applyReclassProcessing(st_merged_fname,st_friction_fname,st_rules_fname,st_name)
        
    # DEPRECATED : old call to gdal:calc performing reclassification
    def applyReclassGdal(self,indexes):
        utils.debug("friction.applyReclassGdal")
        utils.debug("indexes = " + str(indexes))
        st_list = self.bdModel.stModel.items
        nb_steps = len(st_list)
        progress_section = feedbacks.ProgressFeedback("Friction",nb_steps)
        progress_section.start_section()
        for st_item in st_list:
            st_merged_fname = st_item.getMergedPath()
            utils.checkFileExists(st_merged_fname)
            st_friction_fname = st_item.getFrictionPath()
            utils.debug("st_friction_fname = " + str(st_friction_fname))
            qgsUtils.removeRaster(st_friction_fname)
            reclass_dict = {}
            for r in self.items:
                st_name = st_item.dict["name"]
                class_code = r.dict['code']
                if st_name not in r.dict:
                    utils.internal_error("Could not find sous-trame '" + str(st_name)
                                         + "' in friction model " + str(r.dict.keys()))
                coeff = r.dict[st_name]
                if not utils.is_integer(coeff):
                    class_name = r.dict['class']
                    utils.warn("Friction coefficient for class " + class_name
                                     + " and st " + str(st_name)
                                     + " is not an integer : '" + str(coeff) + "'")
                else:
                    reclass_dict[r.dict['code']] = r.dict[st_item.dict["name"]]
            utils.debug("Reclass dict : " + str(reclass_dict))
            qgsTreatments.applyReclassGdalFromDict(st_merged_fname,st_friction_fname,
                                                   reclass_dict,load_flag=True)
            progress_section.next_step()
        progress_section.end_section()
        
    # Computes friction layer for each item.
    def applyItemsWithContext(self,indexes,context,feedback):
        feedbacks.beginSection("Friction")
        self.bdModel.paramsModel.checkInit()
        reclass_matrixes = self.getReclassifyMatrixes()
        nb_items = len(reclass_matrixes)
        step_feedback = feedbacks.ProgressMultiStepFeedback(nb_items,feedback)
        curr_step = 0
        for st_name, matrix in reclass_matrixes.items():
            feedback.setProgressText("computing subnetwork '" + st_name + "'")
            feedback.pushInfo("Friction computation for subnetwork " + str(st_name))
            in_path = self.bdModel.stModel.getMergedPath(st_name)
            out_path = self.bdModel.stModel.getFrictionPath(st_name)
            qgsUtils.removeRaster(out_path)
            self.checkInVals(in_path)
            qgsTreatments.applyReclassifyByTable(in_path,matrix,out_path,boundaries_mode=2,
                                                 context=context,feedback=step_feedback)
            loaded_layer = qgsUtils.loadRasterLayer(out_path,loadProject=True)
            styles.setRendererPalettedGnYlRd(loaded_layer)
            curr_step += 1
            step_feedback.setCurrentStep(curr_step)
        feedbacks.endSection()
        
    # Saves friction coefficients to CSV file 'fname'
    def saveCSV(self,fname):
        with open(fname,"w", newline='') as f:
            writer = csv.DictWriter(f,fieldnames=self.fields,delimiter=';')
            writer.writeheader()
            for i in self.items:
                utils.debug("writing row " + str(i.dict))
                writer.writerow(i.dict)
        utils.info("Friction saved to file '" + str(fname) + "'")
                
    # Add or update FrictionRowItem 'item' into model.
    def fromCSVItem(self,item):
        cls_name = item.dict["class"]
        friction_item = self.getRowByClass(cls_name)
        cls_item = self.bdModel.classModel.getClassByName(cls_name)
        item_descr = item.dict["class_descr"]
        if cls_item:
            if item_descr:
                cls_item.dict["descr"] = item_descr
            if friction_item:
                friction_item.dict["class_descr"] = item_descr
                for st in self.bdModel.stModel.getSTList():
                    if st in item.dict:
                        friction_item.dict[st] = item.dict[st]
                    else:
                        utils.warn("No entry for class '" + cls_name + "' and subnetwork '" + st + "'")
            else:
                self.addItem(item)
        else:
            utils.warn("Ignoring imported csv row : class '" + str(cls_name)
                       + "' does not exist.")
            
    # Loads friction coefficients from CSV file 'fname' into model (insertion or update).
    def fromCSVUpdate(self,fname):
        with open(fname,"r") as f:
            reader = csv.DictReader(f,fieldnames=self.fields,delimiter=';')
            first_line = next(reader)
            for row in reader:
                item = FrictionRowItem(row)
                self.fromCSVItem(item)
        self.layoutChanged.emit()
        
    # Loads friction coefficients from CSV file 'fname' into model.
    # Existing items are erased.
    def fromCSV(self,fname):
        self.items = []
        with open(fname,"r") as f:
            reader = csv.DictReader(f,fieldnames=self.fields,delimiter=';')
            header = reader.fieldnames
            self.fields = header
            for st in header[3:]:
                st_item = self.bdModel.stModel.getSTByName(st)
                if not st_item:
                    utils.user_error("Sous-trame '" + st + "' does not exist")
            first_line = next(reader)
            for row in reader:
                item = FrictionRowItem(row)
                self.addItem(item)
        self.layoutChanged.emit()
        
    # Loads model from XML root (tag 'FrictionModel')    
    def fromXMLRoot(self,root):
        self.items = []
        for fr in root:
            item = FrictionRowItem(fr.attrib)
            self.addItem(item)
        self.layoutChanged.emit()
        
    def flags(self, index):
        if index.column() in [1,2]:
            flags = Qt.ItemIsSelectable | Qt.ItemIsEnabled
        else:
            flags = Qt.ItemIsSelectable | Qt.ItemIsEnabled | Qt.ItemIsEditable
        return flags
           
           
class FrictionConnector(abstract_model.AbstractConnector):
    
    def __init__(self,dlg,frictionModel):
        self.dlg = dlg
        super().__init__(frictionModel,self.dlg.frictionView,None,None)
        
    def initGui(self):
        pass
        
    def connectComponents(self):
        super().connectComponents()
        self.dlg.frictionLoadClass.clicked.connect(self.model.reloadClasses)
        self.dlg.frictionRun.clicked.connect(self.applyItems)
        self.dlg.frictionSave.clicked.connect(self.saveCSVAction)
        self.dlg.frictionLoad.clicked.connect(self.loadCSVAction)
        
    # Return indexes currently selected in friction view
    def getSelectedIndexes(self):
        if self.onlySelection:
            indexes = list(set([i.column() for i in self.view.selectedIndexes()]))
        else:
            indexes = range(3,len(self.model.fields))
        return indexes
        
    # Updates model with items loaded from file 'fname'
    def loadCSV(self,fname):
        utils.checkFileExists(fname)
        self.model.fromCSVUpdate(fname)
        utils.info("Friction loaded from '" + str(fname))
        
    # Opens file dialog and loads model from selected CSV file.
    def loadCSVAction(self):
        utils.debug("loadCSVAction " + str(self))
        fname = qgsUtils.openFileDialog(parent=self.dlg,
                                      msg="Ouvrir le tableau de friction",
                                      filter="*.csv")
        if fname:
            self.loadCSV(fname)
            
    def saveCSV(self,fname):
        self.model.saveCSV(fname)
     
    def saveCSVAction(self):
        utils.debug("saveCSVAction")
        fname = qgsUtils.saveFileDialog(parent=self.dlg,
                                      msg="Sauvegarder le tableau de friction sous",
                                      filter="*.csv")
        if fname:
            self.saveCSV(fname)
        
