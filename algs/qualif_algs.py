# -*- coding: utf-8 -*-
"""
/***************************************************************************
 BioDispersal
                                 A QGIS plugin
 Computes ecological continuities based on environments permeability
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2018-04-12
        git sha              : $Format:%H$
        copyright            : (C) 2018 by IRSTEA
        email                : mathieu.chailloux@irstea.fr
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
    
from PyQt5.QtCore import QCoreApplication, QVariant
from PyQt5.QtGui import QIcon
from qgis.core import (Qgis,
                       QgsFields,
                       QgsField,
                       QgsFeature,
                       QgsProcessing,
                       QgsProcessingUtils,
                       QgsProcessingAlgorithm,
                       QgsProcessingException,
                       QgsProcessingMultiStepFeedback,
                       QgsProcessingParameterDefinition,
                       QgsProcessingParameterFeatureSource,
                       QgsProcessingParameterMultipleLayers,
                       QgsProcessingParameterExtent,
                       QgsProcessingParameterNumber,
                       QgsProcessingParameterMatrix,
                       QgsProcessingParameterFeatureSink,
                       QgsProcessingParameterExpression,
                       QgsProcessingParameterString,
                       QgsProcessingParameterField,
                       QgsProcessingParameterRange,
                       QgsProcessingParameterVectorDestination,
                       QgsProcessingParameterRasterDestination,
                       QgsProcessingParameterFileDestination,
                       QgsProcessingParameterFolderDestination,
                       QgsProcessingParameterRasterLayer,
                       QgsProcessingParameterMapLayer,
                       QgsProcessingParameterEnum,
                       QgsProcessingParameterBoolean,
                       QgsProcessingParameterFile,
                       QgsFeatureSink)

import processing
from processing.algs.gdal.rasterize import rasterize

from ..qgis_lib_mc import utils, qgsUtils, qgsTreatments, feedbacks, styles

QualifAlgorithm = qgsUtils.BaseProcessingAlgorithm      
  
  
class RelativeSurface(QualifAlgorithm):

    ALG_NAME = 'RelativeSurface'
    
    LAYER_A = 'LAYER_A'
    LAYER_B = 'LAYER_B'
    
    def displayName(self):
        return self.tr("Relative surface")
    def group(self):
        return self.tr("Habitat qualification")
    def groupId(self):
        return 'qualif'
        
    def shortHelpString(self):
        return self.tr("Relative surface (percentage of B surface in each patch of layer A)")
    
    def initAlgorithm(self, config=None):
        self.addParameter(
            QgsProcessingParameterFeatureSource(
                self.LAYER_A,
                description=self.tr('Layer A (main layer)')))
        self.addParameter(
            QgsProcessingParameterFeatureSource(
                self.LAYER_B,
                description=self.tr('Layer B (relative surface layer)')))
        self.addParameter(
            QgsProcessingParameterFeatureSink(
                self.OUTPUT,
                self.tr("Output layer")))
        # self.addParameter(
            # QgsProcessingParameterVectorDestination(
                # self.OUTPUT,
                # self.tr("Output layer")))
                
    def computeArea(self,f):
        return f.geometry().area()
    def computeRelSurf(self,f):
        return f[self.sumField] / f.geometry().area()
        
    def processAlgorithm(self,parameters,context,feedback):
        # Parameters
        layerA = self.parameterAsVectorLayer(parameters,self.LAYER_A,context)
        if layerA is None:
            raise QgsProcessingException(self.invalidSourceError(parameters, self.LAYER_A))
        layerB = self.parameterAsVectorLayer(parameters,self.LAYER_B,context)
        if layerB is None:
            raise QgsProcessingException(self.invalidSourceError(parameters, self.LAYER_B))
        outFields = QgsFields(layerA.fields())
        areaFieldName = "area"
        relSurfFieldName = "relSurface"
        areaField = QgsField(areaFieldName, QVariant.Double)
        relSurfField = QgsField(relSurfFieldName, QVariant.Double)
        outFields.append(areaField)
        outFields.append(relSurfField)
        (sink, dest_id) = self.parameterAsSink(
            parameters,
            self.OUTPUT,
            context,
            outFields,
            layerA.wkbType(),
            layerA.sourceCrs()
        )
        nb_feats = layerA.featureCount()
        if nb_feats == 0:
            raise QgsProcessingException("No feature in layerA layer")
        progress_step = 100.0 / nb_feats
        curr_step = 0
        mf = QgsProcessingMultiStepFeedback(nb_feats,feedback)
        for cpt, f in enumerate(layerA.getFeatures(),start=1):
            f_geom = f.geometry()
            f_area = f_geom.area()
            area = 0
            for b_feat in layerB.getFeatures():
                b_geom = b_feat.geometry()
                intersection = f_geom.intersection(b_geom)
                area += intersection.area()
            # f_id = f.id()
            # layerA.selectByIds([f_id])
            # suffix = "_" + str(f_id) + ".gpkg"
            # selection = QgsProcessingUtils.generateTempFilename(
                # "selection" + suffix)
            # qgsTreatments.saveSelectedAttributes(joined_layer,
                # layerA,context=context,feedback=mf)
            # clipped_path = QgsProcessingUtils.generateTempFilename(
                # "clipped" + suffix)
            # qgsTreatments.applyVectorClip(layerB,selection,
                # clipped_path,context=context,feedback=mf)
            # clipped_layer = qgsUtils.loadVectorLayer(clipped)
            outF = QgsFeature(outFields)
            outF.setGeometry(f.geometry())
            for field in f.fields().names():
                outF[field] = f[field]
            outF[areaFieldName] = area
            outF[relSurfFieldName] = area / f_area
            sink.addFeature(outF)
            mf.setCurrentStep(cpt)
        return { self.OUTPUT : dest_id } 
        
    def processAlgorithmOld(self,parameters,context,feedback):
        # Parameters
        layerA = self.parameterAsVectorLayer(parameters,self.LAYER_A,context)
        if layerA is None:
            raise QgsProcessingException(self.invalidSourceError(parameters, self.LAYER_A))
        layerB = self.parameterAsVectorLayer(parameters,self.LAYER_B,context)
        if layerB is None:
            raise QgsProcessingException(self.invalidSourceError(parameters, self.LAYER_B))
        output = self.parameterAsOutputLayer(parameters,self.OUTPUT,context)
        # Processing : todo clip
        clippedPath = QgsProcessingUtils.generateTempFilename('clipped.gpkg')
        qgsTreatments.applyVectorClip(layerA,layerB,clippedPath,
            context=context,feedback=feedback)
        qgsUtils.loadVectorLayer(clippedPath,loadProject=True)
        # Computes new area
        areaField = 'area'
        areaPath = QgsProcessingUtils.generateTempFilename('area.gpkg')
        qgsTreatments.fieldCalculator(clippedPath,areaField,'$area',areaPath,
            context=context,feedback=feedback)
        # Join by loc summary
        joinedPath = QgsProcessingUtils.generateTempFilename('joined.gpkg')
        qgsTreatments.joinByLocSummary(layerA,areaPath,joinedPath,
            fieldnames=[areaField],summaries=[5],predicates=[1],discard=False,
            context=context,feedback=feedback)
        # Computes relative surface
        sumField = areaField + '_sum'
        formula = 'if ( "' + sumField + '" > 0, "' + sumField + '" / $area, 0)'
        qgsTreatments.fieldCalculator(joinedPath,'relSurface',formula,output,
            context=context,feedback=feedback)
        return { self.OUTPUT : output }
        
    
