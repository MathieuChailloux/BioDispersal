# -*- coding: utf-8 -*-
"""
/***************************************************************************
 BioDispersal
                                 A QGIS plugin
 Computes ecological continuities based on environments permeability
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2018-04-12
        git sha              : $Format:%H$
        copyright            : (C) 2018 by IRSTEA
        email                : mathieu.chailloux@irstea.fr
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
    
from PyQt5.QtCore import QCoreApplication, QVariant
from PyQt5.QtGui import QIcon
from qgis.core import (Qgis,
                       QgsFields,
                       QgsField,
                       QgsFeature,
                       QgsGraduatedSymbolRenderer,
                       QgsProcessing,
                       QgsProcessingUtils,
                       QgsProcessingAlgorithm,
                       QgsProcessingException,
                       QgsProcessingMultiStepFeedback,
                       QgsProcessingParameterDefinition,
                       QgsProcessingParameterFeatureSource,
                       QgsProcessingParameterMultipleLayers,
                       QgsProcessingParameterExtent,
                       QgsProcessingParameterNumber,
                       QgsProcessingParameterMatrix,
                       QgsProcessingParameterFeatureSink,
                       QgsProcessingParameterExpression,
                       QgsProcessingParameterString,
                       QgsProcessingParameterField,
                       QgsProcessingParameterRange,
                       QgsProcessingParameterVectorDestination,
                       QgsProcessingParameterRasterDestination,
                       QgsProcessingParameterFileDestination,
                       QgsProcessingParameterFolderDestination,
                       QgsProcessingParameterRasterLayer,
                       QgsProcessingParameterMapLayer,
                       QgsProcessingParameterEnum,
                       QgsProcessingParameterBoolean,
                       QgsProcessingParameterFile,
                       QgsFeatureSink)

import processing
from processing.algs.gdal.rasterize import rasterize

from ..qgis_lib_mc import utils, qgsUtils, qgsTreatments, feedbacks, styles
from .patch_algs import ExtractPatchesR

class QualifAlgorithm(qgsUtils.BaseProcessingAlgorithm):

    def group(self):
        return self.tr("Patch qualification")
    def groupId(self):
        return "qualif"
     
class QualifAlgClassif(QualifAlgorithm):
    # Apply Jenks classif on self.output self.fieldname
    def postProcessAlgorithm(self,context,feedback):
        out_layer = QgsProcessingUtils.mapLayerFromString(self.output,context)
        if not out_layer:
            raise QgsProcessingException("No layer found for " + str(self.output))
        styles.setRdYlGnGraduatedStyle(out_layer,self.fieldname)
        return {self.OUTPUT: self.output }
        
class QualifAlg1Layer(QualifAlgClassif):
    INPUT = 'INPUT'
    OUTPUT = 'OUTPUT'
    
    def initAlgorithm(self, config=None):
        self.addParameter(
            QgsProcessingParameterFeatureSource(
                self.INPUT,
                description=self.tr('Patch layer')))
        self.addParameter(
            QgsProcessingParameterVectorDestination(
                self.OUTPUT,
                self.tr("Output layer")))
                
    def processAlgorithm(self,parameters,context,feedback):
        # Parameters
        input = self.parameterAsVectorLayer(parameters,self.INPUT,context)
        if input is None:
            raise QgsProcessingException(self.invalidSourceError(parameters, self.LAYER_A))
        output = self.parameterAsOutputLayer(parameters,self.OUTPUT,context)
        # Processing
        

class QualifAlg2Layers(QualifAlgClassif):
    LAYER_A = 'LAYER_A'
    LAYER_B = 'LAYER_B'
    VALUES = 'VALUES'
    
    def initLayerAV(self):
        self.addParameter(
            QgsProcessingParameterFeatureSource(
                self.LAYER_A,
                description=self.tr('Patch layer')))
    def initLayerBV(self):
        self.addParameter(
            QgsProcessingParameterFeatureSource(
                self.LAYER_B,
                description=self.tr('Layer B (relative surface layer)')))
    def initLayerBR(self):
        self.addParameter(
            QgsProcessingParameterRasterLayer(
                self.LAYER_B,
                description=self.tr('Layer B (relative surface layer)')))
    def initOutLayerV(self):
        self.addParameter(
            QgsProcessingParameterVectorDestination(
                self.OUTPUT,
                self.tr("Output layer")))
    def initOutLayerR(self):
        self.addParameter(
            QgsProcessingParameterRasterDestination(
                self.OUTPUT,
                self.tr("Output layer")))
    def initValues(self):
        self.addParameter(
            QgsProcessingParameterString (
                self.VALUES,
                description=self.tr('Values (separated by \';\', all values by default)')))
        

class QualifAlgVV(QualifAlg2Layers):
    def initAlgorithm(self, config=None):
        self.initLayerAV()
        self.initLayerBV()
        self.initOutLayerV()
class QualifAlgVR(QualifAlg2Layers):
    def initAlgorithm(self, config=None):
        self.initLayerAV()
        self.initLayerBR()
        self.initValues()
        self.initOutLayerV()
                  
# Relative surface with patch vector and landuse raster
class RelativeSurfaceVR(QualifAlgVR):

    ALG_NAME = 'relativeSurfaceVR'

    def displayName(self):
        return self.tr("Relative surface (VR)")
    def shortHelpString(self):
        return self.tr("Relative surface (percentage of B surface in each patch of layer A)")
        
    def processAlgorithm(self,parameters,context,feedback):
        # Parameters
        layerA = self.parameterAsVectorLayer(parameters,self.LAYER_A,context)
        if layerA is None:
            raise QgsProcessingException(self.invalidSourceError(parameters, self.LAYER_A))
        layerB = self.parameterAsRasterLayer(parameters,self.LAYER_B,context)
        if layerB is None:
            raise QgsProcessingException(self.invalidSourceError(parameters, self.LAYER_B))
        values = self.parameterAsInts(parameters,self.VALUES,context)
        self.output = self.parameterAsOutputLayer(parameters,self.OUTPUT,context)
        # Values extraction
        if values:
            extract_path = self.mkTmpPath("extract.tif")
            extract_params = { ExtractPatchesR.INPUT : parameters[self.LAYER_B],
                ExtractPatchesR.VALUES : parameters[self.VALUES],
                ExtractPatchesR.OUTPUT : extract_path }
            processing.run("BioDispersal:" + ExtractPatchesR.ALG_NAME,
                extract_params,context=context,feedback=feedback)
            # layerB = qgsUtils.loadRasterLayer(extract_path) 
        else:
            extract_path = layerB
        # Zonal stats
        values_str = "".join(str(v) for v in values)
        prefix = values_str + "_"
        stats_path = qgsUtils.mkTmpPath("stats.gpkg")
        # Stats = 0 <=> count
        qgsTreatments.rasterZonalStats(layerA,extract_path,stats_path,
            prefix=prefix,stats=[0],feedback=feedback) 
        # Compute relative surface
        x_res = layerB.rasterUnitsPerPixelX()
        y_res = layerB.rasterUnitsPerPixelY()
        pixel_surf = x_res * y_res
        feedback.pushDebugInfo("pixel_surf = " + str(pixel_surf))
        expr = '("%scount" * %d) / $area' % (prefix,pixel_surf)
        feedback.pushDebugInfo("expr = " + expr)
        self.fieldname = "SurfRel_" + values_str
        qgsTreatments.fieldCalculator(stats_path,self.fieldname,expr,self.output,
            precision=4,feedback=feedback)
        return { self.OUTPUT : self.output }
        
    def postProcessAlgorithm(self,context,feedback):
        out_layer = QgsProcessingUtils.mapLayerFromString(self.output,context)
        if not out_layer:
            raise QgsProcessingException("No layer found for " + str(self.output))
        styles.setRdYlGnGraduatedStyle(out_layer,self.fieldname)
        return {self.OUTPUT: self.output }
  
class RelativeSurface(QualifAlgorithm):

    ALG_NAME = 'RelativeSurface'
    
    LAYER_A = 'LAYER_A'
    LAYER_B = 'LAYER_B'
    
    def displayName(self):
        return self.tr("Relative surface")
        
    def shortHelpString(self):
        return self.tr("Relative surface (percentage of B surface in each patch of layer A)")
    
    def initAlgorithm(self, config=None):
        self.addParameter(
            QgsProcessingParameterFeatureSource(
                self.LAYER_A,
                description=self.tr('Layer A (main layer)')))
        self.addParameter(
            QgsProcessingParameterFeatureSource(
                self.LAYER_B,
                description=self.tr('Layer B (relative surface layer)')))
        self.addParameter(
            QgsProcessingParameterFeatureSink(
                self.OUTPUT,
                self.tr("Output layer")))
        # self.addParameter(
            # QgsProcessingParameterVectorDestination(
                # self.OUTPUT,
                # self.tr("Output layer")))
                
    def computeArea(self,f):
        return f.geometry().area()
    def computeRelSurf(self,f):
        return f[self.sumField] / f.geometry().area()
        
    def processAlgorithm(self,parameters,context,feedback):
        # Parameters
        layerA = self.parameterAsVectorLayer(parameters,self.LAYER_A,context)
        if layerA is None:
            raise QgsProcessingException(self.invalidSourceError(parameters, self.LAYER_A))
        layerB = self.parameterAsVectorLayer(parameters,self.LAYER_B,context)
        if layerB is None:
            raise QgsProcessingException(self.invalidSourceError(parameters, self.LAYER_B))
        outFields = QgsFields(layerA.fields())
        areaFieldName = "area"
        relSurfFieldName = "relSurface"
        areaField = QgsField(areaFieldName, QVariant.Double)
        relSurfField = QgsField(relSurfFieldName, QVariant.Double)
        outFields.append(areaField)
        outFields.append(relSurfField)
        (sink, dest_id) = self.parameterAsSink(
            parameters,
            self.OUTPUT,
            context,
            outFields,
            layerA.wkbType(),
            layerA.sourceCrs()
        )
        nb_feats = layerA.featureCount()
        if nb_feats == 0:
            raise QgsProcessingException("No feature in layerA layer")
        progress_step = 100.0 / nb_feats
        curr_step = 0
        mf = QgsProcessingMultiStepFeedback(nb_feats,feedback)
        for cpt, f in enumerate(layerA.getFeatures(),start=1):
            f_geom = f.geometry()
            f_area = f_geom.area()
            area = 0
            for b_feat in layerB.getFeatures():
                b_geom = b_feat.geometry()
                intersection = f_geom.intersection(b_geom)
                area += intersection.area()
            # f_id = f.id()
            # layerA.selectByIds([f_id])
            # suffix = "_" + str(f_id) + ".gpkg"
            # selection = QgsProcessingUtils.generateTempFilename(
                # "selection" + suffix)
            # qgsTreatments.saveSelectedAttributes(joined_layer,
                # layerA,context=context,feedback=mf)
            # clipped_path = QgsProcessingUtils.generateTempFilename(
                # "clipped" + suffix)
            # qgsTreatments.applyVectorClip(layerB,selection,
                # clipped_path,context=context,feedback=mf)
            # clipped_layer = qgsUtils.loadVectorLayer(clipped)
            outF = QgsFeature(outFields)
            outF.setGeometry(f.geometry())
            for field in f.fields().names():
                outF[field] = f[field]
            outF[areaFieldName] = area
            outF[relSurfFieldName] = area / f_area
            sink.addFeature(outF)
            mf.setCurrentStep(cpt)
        return { self.OUTPUT : dest_id } 
        
    def processAlgorithmOld(self,parameters,context,feedback):
        # Parameters
        layerA = self.parameterAsVectorLayer(parameters,self.LAYER_A,context)
        if layerA is None:
            raise QgsProcessingException(self.invalidSourceError(parameters, self.LAYER_A))
        layerB = self.parameterAsVectorLayer(parameters,self.LAYER_B,context)
        if layerB is None:
            raise QgsProcessingException(self.invalidSourceError(parameters, self.LAYER_B))
        output = self.parameterAsOutputLayer(parameters,self.OUTPUT,context)
        # Processing : todo clip
        clippedPath = QgsProcessingUtils.generateTempFilename('clipped.gpkg')
        qgsTreatments.applyVectorClip(layerA,layerB,clippedPath,
            context=context,feedback=feedback)
        qgsUtils.loadVectorLayer(clippedPath,loadProject=True)
        # Computes new area
        areaField = 'area'
        areaPath = QgsProcessingUtils.generateTempFilename('area.gpkg')
        qgsTreatments.fieldCalculator(clippedPath,areaField,'$area',areaPath,
            context=context,feedback=feedback)
        # Join by loc summary
        joinedPath = QgsProcessingUtils.generateTempFilename('joined.gpkg')
        qgsTreatments.joinByLocSummary(layerA,areaPath,joinedPath,
            fieldnames=[areaField],summaries=[5],predicates=[1],discard=False,
            context=context,feedback=feedback)
        # Computes relative surface
        sumField = areaField + '_sum'
        formula = 'if ( "' + sumField + '" > 0, "' + sumField + '" / $area, 0)'
        qgsTreatments.fieldCalculator(joinedPath,'relSurface',formula,output,
            context=context,feedback=feedback)
        return { self.OUTPUT : output }
        
    
class CompactnessAlg(QualifAlg1Layer):

    ALG_NAME = 'compactness'   
    def displayName(self):
        return self.tr("Compactness")
    def shortHelpString(self):
        return self.tr("Computes compactness index (area / perimeter) for each feature of input layer")
                
    def processAlgorithm(self,parameters,context,feedback):
        # Parameters
        input = self.parameterAsVectorLayer(parameters,self.INPUT,context)
        if input is None:
            raise QgsProcessingException(self.invalidSourceError(parameters, self.LAYER_A))
        self.output = self.parameterAsOutputLayer(parameters,self.OUTPUT,context)
        # Processing
        # Compactness could be based on minimum enclosing circles 
        expr = "$area / $perimeter"
        expr = "$area / ($perimeter * $perimeter)"
        expr = "$area / ($perimeter * $perimeter / (4*pi()))"
        self.fieldname = "compactness"
        qgsTreatments.fieldCalculator(input,self.fieldname,expr,self.output,
            context=context,feedback=feedback)
        return { self.OUTPUT : self.output }
    

class DistanceAlg(QualifAlgVR):

    ALG_NAME = 'distanceAlgVR'

    def displayName(self):
        return self.tr("Distance to layer")
    def shortHelpString(self):
        return self.tr("Computes minimal distance to layer B pixel for each feature of layer A")
        
    def processAlgorithm(self,parameters,context,feedback):
        # Parameters
        layerA = self.parameterAsVectorLayer(parameters,self.LAYER_A,context)
        if layerA is None:
            raise QgsProcessingException(self.invalidSourceError(parameters, self.LAYER_A))
        layerB = self.parameterAsRasterLayer(parameters,self.LAYER_B,context)
        if layerB is None:
            raise QgsProcessingException(self.invalidSourceError(parameters, self.LAYER_B))
        values = self.parameterAsInts(parameters,self.VALUES,context)
        self.output = self.parameterAsOutputLayer(parameters,self.OUTPUT,context)
        # Values extraction
        if values:
            extract_path = self.mkTmpPath("extract.tif")
            extract_params = { ExtractPatchesR.INPUT : parameters[self.LAYER_B],
                ExtractPatchesR.VALUES : parameters[self.VALUES],
                ExtractPatchesR.OUTPUT : extract_path }
            processing.run("BioDispersal:" + ExtractPatchesR.ALG_NAME,
                extract_params,context=context,feedback=feedback)
            # layerB = qgsUtils.loadRasterLayer(extract_path) 
        else:
            extract_path = layerB
        # Distance
        distance_path = qgsUtils.mkTmpPath("distance.tif")
        qgsTreatments.applyProximity(extract_path,distance_path,feedback=feedback)
        # Zonal stats
        values_str = "".join(str(v) for v in values)
        prefix = values_str + "_dist_"
        self.fieldname = prefix + "min"
        # Stats = 5 <=> minimum
        qgsTreatments.rasterZonalStats(layerA,distance_path,self.output,
            prefix=prefix,stats=[5],feedback=feedback) 
        return { self.OUTPUT : self.output }
        
    def postProcessAlgorithm(self,context,feedback):
        out_layer = QgsProcessingUtils.mapLayerFromString(self.output,context)
        if not out_layer:
            raise QgsProcessingException("No layer found for " + str(self.output))
        styles.setRdYlGnGraduatedStyle(out_layer,self.fieldname,invert_ramp=True)
        return {self.OUTPUT: self.output }

# Computes Shannon Diversity Index
class ShannonDiversityIndex(QualifAlgClassif):

    ALG_NAME = 'shannonIndex'

    PATCHES = 'PATCHES'
    LANDUSE = 'LANDUSE'
    
    def displayName(self):
        return self.tr("Shannon index")
    def shortHelpString(self):
        return self.tr("Creates field with classification value from active symbology")
        
    def initAlgorithm(self, config=None):
        self.addParameter(
            QgsProcessingParameterFeatureSource(
                self.PATCHES,
                description=self.tr('Patch vector layer')))
        self.addParameter(
            QgsProcessingParameterRasterLayer(
                self.LANDUSE,
                description=self.tr('Landuse raster layer')))
        self.addParameter(
            QgsProcessingParameterVectorDestination(
                self.OUTPUT,
                self.tr("Output layer")))
                
    def processAlgorithm(self,parameters,context,feedback):
        # Parameters
        patches = self.parameterAsVectorLayer(parameters,self.PATCHES,context)
        if patches is None:
            raise QgsProcessingException(self.invalidSourceError(parameters, self.PATCHES))
        landuse = self.parameterAsRasterLayer(parameters,self.LANDUSE,context)
        if landuse is None:
            raise QgsProcessingException(self.invalidSourceError(parameters, self.LANDUSE))
        self.output = self.parameterAsOutputLayer(parameters,self.OUTPUT,context)
        self.fieldname = "shannon"
        # Computes zonal histo
        hist_path = qgsUtils.mkTmpPath("zonal_histo.gpkg")
        qgsTreatments.zonalHisto(patches,landuse,hist_path,feedback=feedback)
        hist_layer = qgsUtils.loadVectorLayer(hist_path)
        # Computes index
        prefix = "HISTO_"
        fields_histo = [f.name() for f in hist_layer.fields() if f.name().startswith(prefix)]
        tot_expr = " + ".join(fields_histo)
        fields_expr = ['("{0}" / ({1}) * ln("{0}" / ({1}))) * -1'.format(fh,tot_expr) for fh in fields_histo]
        expr = " + ".join(fields_expr)
        qgsTreatments.fieldCalculator(hist_path,self.fieldname,expr,self.output,feedback=feedback)
        return { self.OUTPUT: self.output }

  
class ClassifySymbology(QualifAlgorithm):

    ALG_NAME = 'classifySymbology'
    
    FIELDNAME = 'FIELDNAME'
    FIELD_PREFIX = 'classif_'

    def displayName(self):
        return self.tr("Classify from symbology")
    def shortHelpString(self):
        return self.tr("Creates field with classification value from active symbology")
        
    def initAlgorithm(self, config=None):
        self.addParameter(
            QgsProcessingParameterFeatureSource(
                self.INPUT,
                description=self.tr('Input layer')))
        self.addParameter(
            QgsProcessingParameterString(
                self.FIELDNAME,
                description=self.tr('Prefix for output fieldname'),
                defaultValue=self.FIELD_PREFIX))
        self.addParameter(
            QgsProcessingParameterFeatureSink(
                self.OUTPUT,
                self.tr("Output layer")))
    
    def processAlgorithm(self,parameters,context,feedback):
        # Parameters
        input = self.parameterAsVectorLayer(parameters,self.INPUT,context)
        if input is None:
            raise QgsProcessingException(self.invalidSourceError(parameters, self.INPUT))
        out_fieldname = self.parameterAsString(parameters,self.FIELDNAME,context)
        # Retrieve symbology classes
        renderer = input.renderer()
        feedback.pushDebugInfo("Rendered class = " + str(renderer.__class__.__name__))
        if isinstance(renderer,QgsGraduatedSymbolRenderer):
            ranges = renderer.ranges()
            fieldname = renderer.classAttribute()
            out_fname = out_fieldname + fieldname
            feedback.pushDebugInfo("out_fname = " + str(out_fname))
            def localFunc(feat):
                val = feat[fieldname]
                range = renderer.rangeForValue(val)
                for idx, val in enumerate(ranges):
                    if val.lowerValue() == range.lowerValue():
                        return float(idx)
                raise QgsProcessingException("No range for " + str(range) + " in " + str(ranges))
            qgsUtils.createOrUpdateField(input,localFunc,out_fname)
        else:
            pass
        return { self.OUTPUT: input }