# -*- coding: utf-8 -*-
"""
/***************************************************************************
 BioDispersal
                                 A QGIS plugin
 Computes ecological continuities based on environments permeability
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2018-04-12
        git sha              : $Format:%H$
        copyright            : (C) 2018 by IRSTEA
        email                : mathieu.chailloux@irstea.fr
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
    
from PyQt5.QtCore import QCoreApplication, QVariant
from PyQt5.QtGui import QIcon
from qgis.core import (Qgis,
                       QgsFields,
                       QgsField,
                       QgsFeature,
                       QgsProcessing,
                       QgsProcessingUtils,
                       QgsProcessingAlgorithm,
                       QgsProcessingException,
                       QgsProcessingMultiStepFeedback,
                       QgsProcessingParameterDefinition,
                       QgsProcessingParameterFeatureSource,
                       QgsProcessingParameterMultipleLayers,
                       QgsProcessingParameterExtent,
                       QgsProcessingParameterNumber,
                       QgsProcessingParameterMatrix,
                       QgsProcessingParameterFeatureSink,
                       QgsProcessingParameterExpression,
                       QgsProcessingParameterString,
                       QgsProcessingParameterField,
                       QgsProcessingParameterRange,
                       QgsProcessingParameterVectorDestination,
                       QgsProcessingParameterRasterDestination,
                       QgsProcessingParameterFileDestination,
                       QgsProcessingParameterFolderDestination,
                       QgsProcessingParameterRasterLayer,
                       QgsProcessingParameterMapLayer,
                       QgsProcessingParameterEnum,
                       QgsProcessingParameterBoolean,
                       QgsProcessingParameterFile,
                       QgsFeatureSink)

import processing
from processing.algs.gdal.rasterize import rasterize

from ..qgis_lib_mc import utils, qgsUtils, qgsTreatments, feedbacks, styles
from .patch_algs import ExtractPatchesR

class QualifAlgorithm(qgsUtils.BaseProcessingAlgorithm):

    def group(self):
        return self.tr("Patch qualification")
    def groupId(self):
        return "qualif"
  
class QualifAlg2Layers(QualifAlgorithm):
    LAYER_A = 'LAYER_A'
    LAYER_B = 'LAYER_B'
    VALUES = 'VALUES'
    
    def initLayerAV(self):
        self.addParameter(
            QgsProcessingParameterFeatureSource(
                self.LAYER_A,
                description=self.tr('Patch layer')))
    def initLayerBV(self):
        self.addParameter(
            QgsProcessingParameterFeatureSource(
                self.LAYER_B,
                description=self.tr('Layer B (relative surface layer)')))
    def initLayerBR(self):
        self.addParameter(
            QgsProcessingParameterRasterLayer(
                self.LAYER_B,
                description=self.tr('Layer B (relative surface layer)')))
    def initOutLayerV(self):
        self.addParameter(
            QgsProcessingParameterVectorDestination(
                self.OUTPUT,
                self.tr("Output layer")))
    def initOutLayerR(self):
        self.addParameter(
            QgsProcessingParameterRasterDestination(
                self.OUTPUT,
                self.tr("Output layer")))
    def initValues(self):
        self.addParameter(
            QgsProcessingParameterString (
                self.VALUES,
                description=self.tr('Values (separated by \';\', all values by default)')))
        

class QualifAlgVV(QualifAlg2Layers):
    def initAlgorithm(self, config=None):
        self.initLayerAV()
        self.initLayerBV()
        self.initOutLayerV()
class QualifAlgVR(QualifAlg2Layers):
    def initAlgorithm(self, config=None):
        self.initLayerAV()
        self.initLayerBR()
        self.initValues()
        self.initOutLayerV()
                  
# Relative surface with patch vector and landuse raster
class RelativeSurfaceVR(QualifAlgVR):
    ALG_NAME = 'RelativeSurfaceVR'

    def displayName(self):
        return self.tr("Relative surface (VR)")
    def shortHelpString(self):
        return self.tr("Relative surface (percentage of B surface in each patch of layer A)")
        
    def processAlgorithm(self,parameters,context,feedback):
        # Parameters
        layerA = self.parameterAsVectorLayer(parameters,self.LAYER_A,context)
        if layerA is None:
            raise QgsProcessingException(self.invalidSourceError(parameters, self.LAYER_A))
        layerB = self.parameterAsRasterLayer(parameters,self.LAYER_B,context)
        if layerB is None:
            raise QgsProcessingException(self.invalidSourceError(parameters, self.LAYER_B))
        values = self.parameterAsInts(parameters,self.VALUES,context)
        self.output = self.parameterAsOutputLayer(parameters,self.OUTPUT,context)
        # Values extraction
        if values:
            extract_path = self.mkTmpPath("extract.tif")
            extract_params = { ExtractPatchesR.INPUT : parameters[self.LAYER_B],
                ExtractPatchesR.VALUES : parameters[self.VALUES],
                ExtractPatchesR.OUTPUT : extract_path }
            processing.run("BioDispersal:" + ExtractPatchesR.ALG_NAME,
                extract_params,context=context,feedback=feedback)
            # layerB = qgsUtils.loadRasterLayer(extract_path) 
        else:
            extract_path = layerB
        # Zonal stats
        values_str = "".join(str(v) for v in values)
        prefix = values_str + "_"
        stats_path = qgsUtils.mkTmpPath("stats.gpkg")
        # Stats = 0 <=> count
        qgsTreatments.rasterZonalStats(layerA,extract_path,stats_path,
            prefix=prefix,stats=[0],feedback=feedback) 
        # Compute relative surface
        x_res = layerB.rasterUnitsPerPixelX()
        y_res = layerB.rasterUnitsPerPixelY()
        pixel_surf = x_res * y_res
        feedback.pushDebugInfo("pixel_surf = " + str(pixel_surf))
        expr = '("%scount" * %d) / $area' % (prefix,pixel_surf)
        feedback.pushDebugInfo("expr = " + expr)
        self.fieldname = "SurfRel_" + values_str
        qgsTreatments.fieldCalculator(stats_path,self.fieldname,expr,self.output,
            precision=4,feedback=feedback)
        return { self.OUTPUT : self.output }
        
    def postProcessAlgorithm(self,context,feedback):
        out_layer = QgsProcessingUtils.mapLayerFromString(self.output,context)
        if not out_layer:
            raise QgsProcessingException("No layer found for " + str(self.dest_id))
        styles.setRdYlGnGraduatedStyle(out_layer,self.fieldname)
        return {self.OUTPUT: self.output }
  
class RelativeSurface(QualifAlgorithm):

    ALG_NAME = 'RelativeSurface'
    
    LAYER_A = 'LAYER_A'
    LAYER_B = 'LAYER_B'
    
    def displayName(self):
        return self.tr("Relative surface")
        
    def shortHelpString(self):
        return self.tr("Relative surface (percentage of B surface in each patch of layer A)")
    
    def initAlgorithm(self, config=None):
        self.addParameter(
            QgsProcessingParameterFeatureSource(
                self.LAYER_A,
                description=self.tr('Layer A (main layer)')))
        self.addParameter(
            QgsProcessingParameterFeatureSource(
                self.LAYER_B,
                description=self.tr('Layer B (relative surface layer)')))
        self.addParameter(
            QgsProcessingParameterFeatureSink(
                self.OUTPUT,
                self.tr("Output layer")))
        # self.addParameter(
            # QgsProcessingParameterVectorDestination(
                # self.OUTPUT,
                # self.tr("Output layer")))
                
    def computeArea(self,f):
        return f.geometry().area()
    def computeRelSurf(self,f):
        return f[self.sumField] / f.geometry().area()
        
    def processAlgorithm(self,parameters,context,feedback):
        # Parameters
        layerA = self.parameterAsVectorLayer(parameters,self.LAYER_A,context)
        if layerA is None:
            raise QgsProcessingException(self.invalidSourceError(parameters, self.LAYER_A))
        layerB = self.parameterAsVectorLayer(parameters,self.LAYER_B,context)
        if layerB is None:
            raise QgsProcessingException(self.invalidSourceError(parameters, self.LAYER_B))
        outFields = QgsFields(layerA.fields())
        areaFieldName = "area"
        relSurfFieldName = "relSurface"
        areaField = QgsField(areaFieldName, QVariant.Double)
        relSurfField = QgsField(relSurfFieldName, QVariant.Double)
        outFields.append(areaField)
        outFields.append(relSurfField)
        (sink, dest_id) = self.parameterAsSink(
            parameters,
            self.OUTPUT,
            context,
            outFields,
            layerA.wkbType(),
            layerA.sourceCrs()
        )
        nb_feats = layerA.featureCount()
        if nb_feats == 0:
            raise QgsProcessingException("No feature in layerA layer")
        progress_step = 100.0 / nb_feats
        curr_step = 0
        mf = QgsProcessingMultiStepFeedback(nb_feats,feedback)
        for cpt, f in enumerate(layerA.getFeatures(),start=1):
            f_geom = f.geometry()
            f_area = f_geom.area()
            area = 0
            for b_feat in layerB.getFeatures():
                b_geom = b_feat.geometry()
                intersection = f_geom.intersection(b_geom)
                area += intersection.area()
            # f_id = f.id()
            # layerA.selectByIds([f_id])
            # suffix = "_" + str(f_id) + ".gpkg"
            # selection = QgsProcessingUtils.generateTempFilename(
                # "selection" + suffix)
            # qgsTreatments.saveSelectedAttributes(joined_layer,
                # layerA,context=context,feedback=mf)
            # clipped_path = QgsProcessingUtils.generateTempFilename(
                # "clipped" + suffix)
            # qgsTreatments.applyVectorClip(layerB,selection,
                # clipped_path,context=context,feedback=mf)
            # clipped_layer = qgsUtils.loadVectorLayer(clipped)
            outF = QgsFeature(outFields)
            outF.setGeometry(f.geometry())
            for field in f.fields().names():
                outF[field] = f[field]
            outF[areaFieldName] = area
            outF[relSurfFieldName] = area / f_area
            sink.addFeature(outF)
            mf.setCurrentStep(cpt)
        return { self.OUTPUT : dest_id } 
        
    def processAlgorithmOld(self,parameters,context,feedback):
        # Parameters
        layerA = self.parameterAsVectorLayer(parameters,self.LAYER_A,context)
        if layerA is None:
            raise QgsProcessingException(self.invalidSourceError(parameters, self.LAYER_A))
        layerB = self.parameterAsVectorLayer(parameters,self.LAYER_B,context)
        if layerB is None:
            raise QgsProcessingException(self.invalidSourceError(parameters, self.LAYER_B))
        output = self.parameterAsOutputLayer(parameters,self.OUTPUT,context)
        # Processing : todo clip
        clippedPath = QgsProcessingUtils.generateTempFilename('clipped.gpkg')
        qgsTreatments.applyVectorClip(layerA,layerB,clippedPath,
            context=context,feedback=feedback)
        qgsUtils.loadVectorLayer(clippedPath,loadProject=True)
        # Computes new area
        areaField = 'area'
        areaPath = QgsProcessingUtils.generateTempFilename('area.gpkg')
        qgsTreatments.fieldCalculator(clippedPath,areaField,'$area',areaPath,
            context=context,feedback=feedback)
        # Join by loc summary
        joinedPath = QgsProcessingUtils.generateTempFilename('joined.gpkg')
        qgsTreatments.joinByLocSummary(layerA,areaPath,joinedPath,
            fieldnames=[areaField],summaries=[5],predicates=[1],discard=False,
            context=context,feedback=feedback)
        # Computes relative surface
        sumField = areaField + '_sum'
        formula = 'if ( "' + sumField + '" > 0, "' + sumField + '" / $area, 0)'
        qgsTreatments.fieldCalculator(joinedPath,'relSurface',formula,output,
            context=context,feedback=feedback)
        return { self.OUTPUT : output }
        
    
