# -*- coding: utf-8 -*-
"""
/***************************************************************************
 BioDispersal
                                 A QGIS plugin
 Computes ecological continuities based on environments permeability
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2018-04-12
        git sha              : $Format:%H$
        copyright            : (C) 2018 by IRSTEA
        email                : mathieu.chailloux@irstea.fr
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

from PyQt5.QtCore import QCoreApplication, QVariant
from qgis.core import (Qgis,
                       QgsProject,
                       QgsProcessing,
                       QgsProcessingAlgorithm,
                       QgsProcessingException,
                       QgsProcessingProvider,
                       QgsProcessingParameterFeatureSource,
                       QgsProcessingParameterMultipleLayers,
                       QgsProcessingParameterExtent,
                       QgsProcessingParameterNumber,
                       QgsProcessingParameterMatrix,
                       QgsProcessingParameterFeatureSink,
                       QgsProcessingParameterExpression,
                       QgsProcessingParameterRasterDestination)

import processing

from ..qgis_lib_mc import qgsUtils, qgsTreatments

MEMORY_LAYER_NAME = 'TEMPORARY_OUTPUT'

class BioDispersalAlgorithmsProvider(QgsProcessingProvider):

    NAME = "BioDispersal"

    def __init__(self):
        self.alglist = [TestAlg(),
                        SelectionVExprAlg()]
        for a in self.alglist:
            a.initAlgorithm()
        super().__init__()
        
    def unload(self):
        pass
        
    def id(self):
        return self.NAME
        
    def name(self):
        return self.NAME
        
    def longName(self):
        return self.name()
        
    def loadAlgorithms(self):
        for a in self.alglist:
            self.addAlgorithm(a)
            
            
class TestAlg(QgsProcessingAlgorithm):

    ALG_NAME = "testalg"

    LAYERS = "LAYERS"
    EXTENT = "EXTENT"
    NUMBER = "NUMBER"
    MATRIX = "MATRIX"
    OUTPUT = "OUTPUT"

    def tr(self, string):
        return QCoreApplication.translate('Processing', string)
        
    def createInstance(self):
        return TestAlg()
        
    def name(self):
        return self.ALG_NAME
        
    def displayName(self):
        return self.tr("1 - Prepare landscape")
        
    def shortHelpString(self):
        return self.tr("This algorithms prepares land cover data by applying selection (from expression) and dissolving geometries")

    def initAlgorithm(self, config=None):
        self.addParameter(
            QgsProcessingParameterMultipleLayers(
                self.LAYERS,
                self.tr("Raster layers")))
        self.addParameter(
            QgsProcessingParameterExtent (
                self.EXTENT,
                description=self.tr("Extent"),
                optional=True))
        self.addParameter(
            QgsProcessingParameterNumber (
                self.NUMBER,
                description=self.tr("Number"),
                optional=True))
        self.addParameter(
            QgsProcessingParameterMatrix (
                self.MATRIX,
                "Matrix",
                numberRows=1,
                hasFixedNumberRows=False,
                headers=['c1','c2','c3']))
        self.addParameter(
            QgsProcessingParameterFeatureSink(
                self.OUTPUT,
                self.tr("Output layer")))
                
    def processAlgorithm(self,parameters,context,feedback):
        return None
        
        
class SelectionVExprAlg(QgsProcessingAlgorithm):

    ALG_NAME = 'selectionvexpralg'
    
    INPUT = 'INPUT'
    EXPR = 'EXPR'
    BURNVAL = 'BURNVAL'
    EXTENT = 'EXTENT'
    RESOLUTION = 'RESOLUTION'
    OUTPUT = 'OUTPUT'
    
    def tr(self, string):
        return QCoreApplication.translate('Processing', string)
        
    def createInstance(self):
        return SelectionVExprAlg()
        
    def name(self):
        return self.ALG_NAME
        
    def displayName(self):
        return self.tr('3.1 - Selection from expression')
        
    def shortHelpString(self):
        return self.tr('Selection from expression then rasterization')

    def initAlgorithm(self, config=None):
        self.addParameter(
            QgsProcessingParameterFeatureSource(
                self.INPUT,
                self.tr('Input layer')))
        self.addParameter(
            QgsProcessingParameterExpression (
                self.EXPR,
                description=self.tr('Expression'),
                defaultValue="",
                parentLayerParameterName=self.INPUT,
                optional=True))
        self.addParameter(
            QgsProcessingParameterNumber (
                self.BURNVAL,
                description=self.tr('Burn value'),
                type=QgsProcessingParameterNumber.Integer))
        self.addParameter(
            QgsProcessingParameterExtent (
                self.EXTENT,
                description=self.tr('Extent')))
        self.addParameter(
            QgsProcessingParameterNumber (
                self.RESOLUTION,
                description=self.tr('Resolution (georeferenced units)'),
                type=QgsProcessingParameterNumber.Double))
        self.addParameter(
            QgsProcessingParameterRasterDestination (
                self.OUTPUT,
                description=self.tr('Output')))
                
    def processAlgorithm(self,parameters,context,feedback):
        input = self.parameterAsVectorLayer(parameters,self.INPUT,context)
        feedback.pushDebugInfo("input = " + str(input))
        if input is None:
            raise QgsProcessingException(self.invalidSourceError(parameters, self.INPUT))
        qgsUtils.normalizeEncoding(input)
        expr = self.parameterAsExpression(parameters,self.EXPR,context)
        burn_val = self.parameterAsInt(parameters,self.BURNVAL,context)
        extent = self.parameterAsExtent(parameters,self.EXTENT,context)
        resolution = self.parameterAsDouble(parameters,self.RESOLUTION,context)
        output = parameters[self.OUTPUT]
        if expr:
            selected = qgsTreatments.extractByExpression(input,expr,MEMORY_LAYER_NAME,context,feedback)
        else:
            selected = input
        feedback.pushDebugInfo("selected = " + str(selected))
        rasterized = qgsTreatments.applyRasterization(selected,output,extent,resolution,
                                                      burn_val=burn_val,all_touch=True,
                                                      context=context,feedback=feedback)
        # layer = QgsProject.instance().mapLayer(rasterized)
        # QgsProject.instance().addMapLayer(layer)
        return { 'OUTPUT' : rasterized }
