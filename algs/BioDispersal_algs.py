# -*- coding: utf-8 -*-
"""
/***************************************************************************
 BioDispersal
                                 A QGIS plugin
 Computes ecological continuities based on environments permeability
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2018-04-12
        git sha              : $Format:%H$
        copyright            : (C) 2018 by IRSTEA
        email                : mathieu.chailloux@irstea.fr
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

from PyQt5.QtCore import QCoreApplication, QVariant
from qgis.core import (Qgis,
                       QgsProject,
                       QgsFields,
                       QgsField,
                       QgsFeature,
                       QgsProcessing,
                       QgsProcessingAlgorithm,
                       QgsProcessingException,
                       QgsProcessingProvider,
                       QgsProcessingParameterFeatureSource,
                       QgsProcessingParameterMultipleLayers,
                       QgsProcessingParameterExtent,
                       QgsProcessingParameterNumber,
                       QgsProcessingParameterMatrix,
                       QgsProcessingParameterFeatureSink,
                       QgsProcessingParameterExpression,
                       QgsProcessingParameterString,
                       QgsProcessingParameterField,
                       QgsProcessingParameterVectorDestination,
                       QgsProcessingParameterRasterDestination,
                       QgsProcessingParameterRasterLayer,
                       QgsFeatureSink)

import processing

from ..qgis_lib_mc import qgsUtils, qgsTreatments

MEMORY_LAYER_NAME = 'TEMPORARY_OUTPUT'

class BioDispersalAlgorithmsProvider(QgsProcessingProvider):

    NAME = "BioDispersal"

    def __init__(self):
        self.alglist = [TestAlg(),
                        SelectVExprAlg(),
                        SelectVFieldAlg(),
                        WeightingByValue()]
        for a in self.alglist:
            a.initAlgorithm()
        super().__init__()
        
    def unload(self):
        pass
        
    def id(self):
        return self.NAME
        
    def name(self):
        return self.NAME
        
    def longName(self):
        return self.name()
        
    def loadAlgorithms(self):
        for a in self.alglist:
            self.addAlgorithm(a)
            
            
class TestAlg(QgsProcessingAlgorithm):

    ALG_NAME = "testalg"

    LAYERS = "LAYERS"
    EXTENT = "EXTENT"
    NUMBER = "NUMBER"
    MATRIX = "MATRIX"
    OUTPUT = "OUTPUT"

    def tr(self, string):
        return QCoreApplication.translate('Processing', string)
        
    def createInstance(self):
        return TestAlg()
        
    def name(self):
        return self.ALG_NAME
        
    def displayName(self):
        return self.tr("1 - Prepare landscape")
        
    def shortHelpString(self):
        return self.tr("This algorithms prepares land cover data by applying selection (from expression) and dissolving geometries")

    def initAlgorithm(self, config=None):
        self.addParameter(
            QgsProcessingParameterMultipleLayers(
                self.LAYERS,
                self.tr("Raster layers")))
        self.addParameter(
            QgsProcessingParameterExtent (
                self.EXTENT,
                description=self.tr("Extent"),
                optional=True))
        self.addParameter(
            QgsProcessingParameterNumber (
                self.NUMBER,
                description=self.tr("Number"),
                optional=True))
        self.addParameter(
            QgsProcessingParameterMatrix (
                self.MATRIX,
                "Matrix",
                numberRows=1,
                hasFixedNumberRows=False,
                headers=['c1','c2','c3']))
        self.addParameter(
            QgsProcessingParameterFeatureSink(
                self.OUTPUT,
                self.tr("Output layer")))
                
    def processAlgorithm(self,parameters,context,feedback):
        return None
        
class SelectVExprAlg(QgsProcessingAlgorithm):

    ALG_NAME = 'selectvexpr'
    
    INPUT = 'INPUT'
    EXPR = 'EXPR'
    CLASS = 'CLASS'
    CODE = 'CODE'
    OUTPUT = 'OUTPUT'
    
    def tr(self, string):
        return QCoreApplication.translate('Processing', string)
        
    def createInstance(self):
        return SelectVExprAlg()
        
    def name(self):
        return self.ALG_NAME
        
    def displayName(self):
        return self.tr('Selection (VExpr)')
        
    def shortHelpString(self):
        return self.tr('Code layer creation from input layer')

    def initAlgorithm(self, config=None):
        self.addParameter(
            QgsProcessingParameterFeatureSource(
                self.INPUT,
                description=self.tr('Input layer')))
        self.addParameter(
            QgsProcessingParameterExpression (
                self.EXPR,
                description=self.tr('Expression'),
                defaultValue="",
                parentLayerParameterName=self.INPUT,
                optional=True))
        self.addParameter(
            QgsProcessingParameterString (
                self.CLASS,
                description=self.tr('Class')))
        self.addParameter(
            QgsProcessingParameterNumber (
                self.CODE,
                description=self.tr('Code'),
                type=QgsProcessingParameterNumber.Integer))
        self.addParameter(
            QgsProcessingParameterFeatureSink(
                self.OUTPUT,
                self.tr("Output layer")))
                
    def processAlgorithm(self,parameters,context,feedback):
        input = self.parameterAsVectorLayer(parameters,self.INPUT,context)
        feedback.pushDebugInfo("input = " + str(input))
        if input is None:
            raise QgsProcessingException(self.invalidSourceError(parameters, self.INPUT))
        qgsUtils.normalizeEncoding(input)
        expr = self.parameterAsExpression(parameters,self.EXPR,context)
        class_name = self.parameterAsString(parameters,self.CLASS,context)
        code = self.parameterAsInt(parameters,self.CODE,context)
        out_fields = QgsFields()
        orig_field = QgsField("Origin", QVariant.String)
        class_field = QgsField("Class", QVariant.String)
        code_field = QgsField("Code", QVariant.Int)
        out_fields.append(orig_field)
        out_fields.append(class_field)
        out_fields.append(code_field)
        (sink, dest_id) = self.parameterAsSink(
            parameters,
            self.OUTPUT,
            context,
            out_fields,
            input.wkbType(),
            input.sourceCrs()
        )
        if sink is None:
            raise QgsProcessingException(self.invalidSinkError(parameters, self.OUTPUT))
            
        if expr is None or expr == "":
            nb_feats = input.featureCount()
            feats = input.getFeatures()
        else:
            qgsTreatments.selectByExpression(input,expr)
            nb_feats = input.selectedFeatureCount()
            feats = input.getSelectedFeatures()
            
        if nb_feats == 0:
            raise QgsProcessingException("No feature selected")
        progress_step = 100.0 / nb_feats
        curr_step = 0
        for f in feats:
            new_f = QgsFeature(out_fields)
            new_f["Origin"] = input.sourceName()
            new_f["Class"] = class_name
            new_f["Code"] = code
            new_f.setGeometry(f.geometry())
            sink.addFeature(new_f,QgsFeatureSink.FastInsert)
            curr_step += 1
            feedback.setProgress(int(curr_step * progress_step))
            
        res = { self.OUTPUT : dest_id }
        return res

        
class SelectVFieldAlg(QgsProcessingAlgorithm):

    ALG_NAME = 'selectvfield'
    
    INPUT = 'INPUT'
    FIELD = 'FIELD'
    GROUP = 'GROUP'
    ASSOC = 'ASSOC'
    OUTPUT = 'OUTPUT'
    
    HEADER_FIELD_VAL = 'Field value'
    HEADER_INT_VAL = 'New integer value'
    
    def tr(self, string):
        return QCoreApplication.translate('Processing', string)
        
    def createInstance(self):
        return SelectVFieldAlg()
        
    def name(self):
        return self.ALG_NAME
        
    def displayName(self):
        return self.tr('Selection (VField)')
        
    def shortHelpString(self):
        return self.tr('Code layer creation from input layer')

    def initAlgorithm(self, config=None):
        self.addParameter(
            QgsProcessingParameterFeatureSource(
                self.INPUT,
                description=self.tr('Input layer')))
        self.addParameter(
            QgsProcessingParameterField(
                self.FIELD,
                description=self.tr('Field'),
                defaultValue=None,
                parentLayerParameterName=self.INPUT))
        self.addParameter(
            QgsProcessingParameterString (
                self.GROUP,
                description=self.tr('Group')))
        self.addParameter(
            QgsProcessingParameterMatrix (
                self.ASSOC,
                description=self.tr('Value / code association'),
                numberRows=1,
                hasFixedNumberRows=False,
                headers=[self.HEADER_FIELD_VAL,self.HEADER_INT_VAL]))
        self.addParameter(
            QgsProcessingParameterFeatureSink(
                self.OUTPUT,
                self.tr("Output layer")))
                
    def processAlgorithm(self,parameters,context,feedback):
        input = self.parameterAsVectorLayer(parameters,self.INPUT,context)
        feedback.pushDebugInfo("input = " + str(input))
        if input is None:
            raise QgsProcessingException(self.invalidSourceError(parameters, self.INPUT))
        qgsUtils.normalizeEncoding(input)
        fieldname = self.parameterAsString(parameters,self.FIELD,context)
        if not fieldname:
            raise QgsProcessingException("No field given")
        grp_name = self.parameterAsString(parameters,self.GROUP,context)
        assoc = self.parameterAsMatrix(parameters,self.ASSOC,context)
        out_fields = QgsFields()
        orig_field = QgsField("Origin", QVariant.String)
        class_field = QgsField("Class", QVariant.String)
        code_field = QgsField("Code", QVariant.Int)
        out_fields.append(orig_field)
        out_fields.append(class_field)
        out_fields.append(code_field)
        (sink, dest_id) = self.parameterAsSink(
            parameters,
            self.OUTPUT,
            context,
            out_fields,
            input.wkbType(),
            input.sourceCrs()
        )
        if sink is None:
            raise QgsProcessingException(self.invalidSinkError(parameters, self.OUTPUT))
        i = iter(assoc)
        assoc_table = dict(zip(i,i))
        feedback.pushDebugInfo("assoc_table : " + str(assoc_table))
        nb_feats = input.featureCount()
        if nb_feats == 0:
            raise QgsProcessingException("No feature in input layer")
        progress_step = 100.0 / nb_feats
        curr_step = 0
        for f in input.getFeatures():
            field_val = str(f[fieldname])
            if field_val not in assoc_table:
                raise QgsProcessingException("Value '" + str(field_val) + "' does not exist in association")
            new_f = QgsFeature(out_fields)
            new_f["Origin"] = input.sourceName()
            new_f["Class"] = grp_name + "_" + str(field_val)
            try:
                code = int(assoc_table[field_val])
            except ValueError:
                raise QgsProcessingException("Matrix contains non-integer value " + str(assoc_table[field_val]))
            new_f["Code"] = code
            new_f.setGeometry(f.geometry())
            sink.addFeature(new_f)
            curr_step += 1
            feedback.setProgress(int(curr_step * progress_step))
        res = { self.OUTPUT : dest_id }
        return res        
      

      
class WeightingByValue(QgsProcessingAlgorithm):

    ALG_NAME = 'weightingbyvalue'
    
    INPUT_LAYER = 'INPUT_LAYER'
    WEIGHT_LAYER = 'WEIGHT_LAYER'
    INTERVALS = 'INTERVALS'
    OUTPUT = 'OUTPUT'
    
    LOW_BOUND = 'LOW_BOUND'
    UP_BOUND = 'UP_BOUND'
    POND_VAL = 'POND_VALUE'
    
    def tr(self, string):
        return QCoreApplication.translate('Processing', string)
        
    def createInstance(self):
        return WeightingByValue()
        
    def name(self):
        return self.ALG_NAME
        
    def displayName(self):
        return self.tr('Weighting (By value)')
        
    def shortHelpString(self):
        return self.tr('TODO')

    def initAlgorithm(self, config=None):
        self.addParameter(
            QgsProcessingParameterRasterLayer(
                self.INPUT_LAYER,
                description=self.tr('Input layer')))
        self.addParameter(
            QgsProcessingParameterRasterLayer(
                self.WEIGHT_LAYER,
                description=self.tr('Weighting layer')))
        self.addParameter(
            QgsProcessingParameterMatrix (
                self.INTERVALS,
                description=self.tr('Value intervals'),
                numberRows=1,
                hasFixedNumberRows=False,
                headers=[self.LOW_BOUND,self.UP_BOUND,self.POND_VAL]))
        self.addParameter(
            QgsProcessingParameterRasterDestination(
                self.OUTPUT,
                self.tr("Output layer")))
                
    def processAlgorithm(self,parameters,context,feedback):
        input = self.parameterAsRasterLayer(parameters,self.INPUT_LAYER,context)
        if input is None:
            raise QgsProcessingException(self.invalidRasterError(parameters, self.INPUT_LAYER))
        weighting = self.parameterAsRasterLayer(parameters,self.WEIGHT_LAYER,context)
        if weighting is None:
            raise QgsProcessingException(self.invalidRasterError(parameters, self.WEIGHT_LAYER))
        #intervals = self.parameterAsMatrix(parameters,self.INTERVALS,context)
        output = self.parameterAsOutputLayer(parameters, self.OUTPUT, context)
        nodata_val = -9999
        reclass_params = { 'DATA_TYPE' : 5,
                           'INPUT_RASTER' : input,
                           'NODATA_FOR_MISSING' : True,
                           'NO_DATA' : nodata_val,
                           'OUTPUT' : 'TEMPORARY_OUTPUT',
                           'RANGE_BOUNDARIES' : 2,
                           'RASTER_BAND' : 1,
                           'TABLE' : parameters[self.INTERVALS] }
        reclassed = processing.run('native:reclassifybytable',reclass_params,context=context,feedback=feedback)
        reclassed_layer = reclassed['OUTPUT']
        expr = "A*B"
        rastercalc_params = { 'BAND_A' : 1,
                              'BAND_B' : 1,
                              'FORMULA' : expr,
                              'INPUT_A' : input,
                              'INPUT_B' : reclassed_layer,
                              'NO_DATA' : nodata_val,
                              'OUTPUT' : output,
                              'RTYPE' : 5 }
        calc = processing.run('gdal:rastercalculator',rastercalc_params,context=context,feedback=feedback)
        return calc
