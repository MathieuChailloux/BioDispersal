# -*- coding: utf-8 -*-
"""
/***************************************************************************
 BioDispersal
                                 A QGIS plugin
 Computes ecological continuities based on environments permeability
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2018-04-12
        git sha              : $Format:%H$
        copyright            : (C) 2018 by IRSTEA
        email                : mathieu.chailloux@irstea.fr
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os
import stat
import math
import xml.etree.ElementTree as ET
from pathlib import Path

try:
    import scipy
    import numpy as np
    import_scipy_ok = True
except ImportError:
    import_scipy_ok = False

from PyQt5.QtCore import QCoreApplication, QVariant
from PyQt5.QtGui import QIcon
from qgis.core import (Qgis,
                       QgsProject,
                       QgsFields,
                       QgsField,
                       QgsFeature,
                       QgsProcessing,
                       QgsProcessingUtils,
                       QgsProcessingAlgorithm,
                       QgsProcessingException,
                       QgsProcessingProvider,
                       QgsProcessingParameterFeatureSource,
                       QgsProcessingParameterMultipleLayers,
                       QgsProcessingParameterExtent,
                       QgsProcessingParameterNumber,
                       QgsProcessingParameterMatrix,
                       QgsProcessingParameterFeatureSink,
                       QgsProcessingParameterExpression,
                       QgsProcessingParameterString,
                       QgsProcessingParameterField,
                       QgsProcessingParameterVectorDestination,
                       QgsProcessingParameterRasterDestination,
                       QgsProcessingParameterFileDestination,
                       QgsProcessingParameterFolderDestination,
                       QgsProcessingParameterRasterLayer,
                       QgsProcessingParameterEnum,
                       QgsProcessingParameterBoolean,
                       QgsProcessingParameterFile,
                       QgsFeatureSink)

import processing
from processing.algs.gdal.rasterize import rasterize

from ..qgis_lib_mc import utils, qgsUtils, qgsTreatments, feedbacks, styles
from ..BioDispersal_model import BioDispersalModel

MEMORY_LAYER_NAME = qgsTreatments.MEMORY_LAYER_NAME

class BioDispersalAlgorithmsProvider(QgsProcessingProvider):

    NAME = "BioDispersal"

    def __init__(self):
        self.alglist = [SelectVExprAlg(),
                        SelectVFieldAlg(),
                        WeightingBasics(),
                        WeightingByIntervals(),
                        WeightingByDistance(),
                        RasterSelectionByValue(),
                        BioDispersalAlgorithm(),
                        RasterizeFixAllTouch(),
                        ExportToGraphab(),
                        ExportPatchesToCircuitscape(),
                        ExportFrictionToCircuitscape(),
                        RandomStartPointsCircuitscape(),
                        AggregateCirctuitscapeCurrentMaps(),
                        AggregateCirctuitscapeResults(),
                        ChangeNoDataVal()]
        for a in self.alglist:
            a.initAlgorithm()
        super().__init__()
        
    def unload(self):
        pass
        
    def id(self):
        return self.NAME
        
    def name(self):
        return self.NAME
        
    def longName(self):
        return self.name()
        
    def icon(self):
        icon_path = os.path.join(os.path.dirname(__file__), "..", "icons", "cerf.png")
        return QIcon(icon_path)

    def loadAlgorithms(self):
        for a in self.alglist:
            self.addAlgorithm(a)
            
    def supportedOutputRasterLayerExtensions(self):
        return ['tif','asc']

class BaseAlgorithm(QgsProcessingAlgorithm):
    def tr(self, string):
        return QCoreApplication.translate(self.__class__.__name__, string)
class SelectionAlgorithm(BaseAlgorithm):
    def group(self):
        return "Selection step"
    def groupId(self):
        return 'selection'
    def tr(self, string):
        return QCoreApplication.translate(self.__class__.__name__, string)
    
class WeightingBaseAlgorithm(BaseAlgorithm):
    def group(self):
        return "Weighting step"
    def groupId(self):
        return 'weighting'
        
class GraphabAlgorithm(QgsProcessingAlgorithm):
    def group(self):
        return "Graphab"
    def groupId(self):
        return 'graphab'
    def tr(self, string):
        return QCoreApplication.translate('Processing', string)
        
class CircuitscapeAlgorithm(QgsProcessingAlgorithm):
    def group(self):
        return "Circuitscape"
    def groupId(self):
        return 'circuitscape'
    def tr(self, string):
        return QCoreApplication.translate('Processing', string)
    def name(self):
        return self.ALG_NAME
    def createInstance(self):
        return type(self)()
               
class BioDispersalAlgorithm(QgsProcessingAlgorithm):

    # Algorithm parameters
    INPUT_CONFIG = "INPUT"
    LOG_FILE = "LOG"
    OUTPUT = "OUTPUT"
    
    def tr(self, string):
        return QCoreApplication.translate('Processing', string)
        
    def createInstance(self):
        return BioDispersalAlgorithm()
        
    def name(self):
        return "BioDispersalAlgorithm"
        
    def displayName(self):
        return self.tr("Run BioDispersal from configuration file")
        
    def shortHelpString(self):
        return self.tr("Executes complete process from XML configuration file")

    def initAlgorithm(self,config=None):
        self.addParameter(
            QgsProcessingParameterFile(
                self.INPUT_CONFIG,
                description=self.tr("Input configuration file")))
        self.addParameter(
            QgsProcessingParameterFileDestination(
                self.LOG_FILE,
                description=self.tr("Log file")))
                
    def processAlgorithm(self,parameters,context,feedback):
        feedback.pushInfo("begin")
        utils.print_func = feedback.pushInfo
        # Parameters
        log_file = self.parameterAsFile(parameters,self.LOG_FILE,context)
        feedback.pushDebugInfo("log file = " + str(log_file))
        if utils.fileExists(log_file):
            os.remove(log_file)
        with open(log_file,"w+") as f:
            f.write("BioDispersal from configuration file " + str(log_file) + "\n")
            #raise QgsProcessingException("Log file " + str(log_file) + " already exists")
        log_feedback = feedbacks.FileFeedback(log_file)
        log_feedback.pushInfo("File feedback initialized")
        config_file = self.parameterAsFile(parameters,self.INPUT_CONFIG,context)
        config_tree = ET.parse(config_file)
        config_root = config_tree.getroot()
        bdModel = BioDispersalModel(context,log_feedback)
        log_feedback.pushInfo("from log")
        bdModel.feedback.pushInfo("from model")
        bdModel.fromXMLRoot(config_root)
        bdModel.runModel()
        outputs = [bdModel.getOrigPath(item.dict["out_layer"]) for item in bdModel.costModel.items]
        #qgsUtils.loadVectorLayer(res,loadProject=True)
        return {self.OUTPUT: outputs}
               
class SelectVExprAlg(SelectionAlgorithm):

    ALG_NAME = 'selectvexpr'
    
    INPUT = 'INPUT'
    EXPR = 'EXPR'
    CLASS = 'CLASS'
    CODE = 'CODE'
    OUTPUT = 'OUTPUT'
    
    #def tr(self, string):
    #    return QCoreApplication.translate(self.__class__.__name__, string)
        
    def createInstance(self):
        return SelectVExprAlg()
        
    def name(self):
        return self.ALG_NAME
        
    def displayName(self):
        return self.tr('Selection (VExpr)')
        
    def shortHelpString(self):
        return self.tr('Code layer creation from input layer')

    def initAlgorithm(self, config=None):
        self.addParameter(
            QgsProcessingParameterFeatureSource(
                self.INPUT,
                description=self.tr('Input layer')))
        self.addParameter(
            QgsProcessingParameterExpression (
                self.EXPR,
                description=self.tr('Expression'),
                defaultValue="",
                parentLayerParameterName=self.INPUT,
                optional=True))
        self.addParameter(
            QgsProcessingParameterString (
                self.CLASS,
                description=self.tr('Class')))
        self.addParameter(
            QgsProcessingParameterNumber (
                self.CODE,
                description=self.tr('Code'),
                type=QgsProcessingParameterNumber.Integer))
        self.addParameter(
            QgsProcessingParameterFeatureSink(
                self.OUTPUT,
                self.tr("Output layer")))
                
    def processAlgorithm(self,parameters,context,feedback):
        input = self.parameterAsVectorLayer(parameters,self.INPUT,context)
        feedback.pushDebugInfo("input = " + str(input))
        if input is None:
            raise QgsProcessingException(self.invalidSourceError(parameters, self.INPUT))
        qgsUtils.normalizeEncoding(input)
        expr = self.parameterAsExpression(parameters,self.EXPR,context)
        class_name = self.parameterAsString(parameters,self.CLASS,context)
        code = self.parameterAsInt(parameters,self.CODE,context)
        out_fields = QgsFields()
        orig_field = QgsField("Origin", QVariant.String)
        class_field = QgsField("Class", QVariant.String)
        code_field = QgsField("Code", QVariant.Int)
        out_fields.append(orig_field)
        out_fields.append(class_field)
        out_fields.append(code_field)
        (sink, dest_id) = self.parameterAsSink(
            parameters,
            self.OUTPUT,
            context,
            out_fields,
            input.wkbType(),
            input.sourceCrs()
        )
        if sink is None:
            raise QgsProcessingException(self.invalidSinkError(parameters, self.OUTPUT))
            
        if expr is None or expr == "":
            nb_feats = input.featureCount()
            feats = input.getFeatures()
        else:
            qgsTreatments.selectByExpression(input,expr)
            nb_feats = input.selectedFeatureCount()
            feats = input.getSelectedFeatures()
            
        if nb_feats == 0:
            raise QgsProcessingException("No feature selected")
        progress_step = 100.0 / nb_feats
        curr_step = 0
        for f in feats:
            new_f = QgsFeature(out_fields)
            new_f["Origin"] = input.sourceName()
            new_f["Class"] = class_name
            new_f["Code"] = code
            new_f.setGeometry(f.geometry())
            sink.addFeature(new_f,QgsFeatureSink.FastInsert)
            curr_step += 1
            feedback.setProgress(int(curr_step * progress_step))
            
        res = { self.OUTPUT : dest_id }
        return res

        
class SelectVFieldAlg(SelectionAlgorithm):

    ALG_NAME = 'selectvfield'
    
    INPUT = 'INPUT'
    FIELD = 'FIELD'
    GROUP = 'GROUP'
    ASSOC = 'ASSOC'
    OUTPUT = 'OUTPUT'
    
    HEADER_FIELD_VAL = 'Field value'
    HEADER_INT_VAL = 'New integer value'
    
    def tr(self, string):
        return QCoreApplication.translate('Processing', string)
        
    def createInstance(self):
        return SelectVFieldAlg()
        
    def name(self):
        return self.ALG_NAME
        
    def displayName(self):
        return self.tr('Selection (VField)')
        
    def shortHelpString(self):
        return self.tr('Code layer creation from input layer')

    def initAlgorithm(self, config=None):
        self.addParameter(
            QgsProcessingParameterFeatureSource(
                self.INPUT,
                description=self.tr('Input layer')))
        self.addParameter(
            QgsProcessingParameterField(
                self.FIELD,
                description=self.tr('Field'),
                defaultValue=None,
                parentLayerParameterName=self.INPUT))
        self.addParameter(
            QgsProcessingParameterString (
                self.GROUP,
                description=self.tr('Group')))
        self.addParameter(
            QgsProcessingParameterMatrix (
                self.ASSOC,
                description=self.tr('Value / code association'),
                numberRows=1,
                hasFixedNumberRows=False,
                headers=[self.HEADER_FIELD_VAL,self.HEADER_INT_VAL]))
        self.addParameter(
            QgsProcessingParameterFeatureSink(
                self.OUTPUT,
                self.tr("Output layer")))
                
    def processAlgorithm(self,parameters,context,feedback):
        input = self.parameterAsVectorLayer(parameters,self.INPUT,context)
        feedback.pushDebugInfo("input = " + str(input))
        if input is None:
            raise QgsProcessingException(self.invalidSourceError(parameters, self.INPUT))
        qgsUtils.normalizeEncoding(input)
        fieldname = self.parameterAsString(parameters,self.FIELD,context)
        if not fieldname:
            raise QgsProcessingException("No field given")
        grp_name = self.parameterAsString(parameters,self.GROUP,context)
        assoc = self.parameterAsMatrix(parameters,self.ASSOC,context)
        out_fields = QgsFields()
        orig_field = QgsField("Origin", QVariant.String)
        class_field = QgsField("Class", QVariant.String)
        code_field = QgsField("Code", QVariant.Int)
        out_fields.append(orig_field)
        out_fields.append(class_field)
        out_fields.append(code_field)
        (sink, dest_id) = self.parameterAsSink(
            parameters,
            self.OUTPUT,
            context,
            out_fields,
            input.wkbType(),
            input.sourceCrs()
        )
        if sink is None:
            raise QgsProcessingException(self.invalidSinkError(parameters, self.OUTPUT))
        i = iter(assoc)
        assoc_table = dict(zip(i,i))
        feedback.pushDebugInfo("assoc_table : " + str(assoc_table))
        nb_feats = input.featureCount()
        if nb_feats == 0:
            raise QgsProcessingException("No feature in input layer")
        progress_step = 100.0 / nb_feats
        curr_step = 0
        for f in input.getFeatures():
            field_val = str(f[fieldname])
            if field_val not in assoc_table:
                raise QgsProcessingException("Value '" + str(field_val) + "' does not exist in association")
            new_f = QgsFeature(out_fields)
            new_f["Origin"] = input.sourceName()
            new_f["Class"] = grp_name + "_" + str(field_val)
            try:
                code = int(assoc_table[field_val])
            except ValueError:
                raise QgsProcessingException("Matrix contains non-integer value " + str(assoc_table[field_val]))
            new_f["Code"] = code
            new_f.setGeometry(f.geometry())
            sink.addFeature(new_f)
            curr_step += 1
            feedback.setProgress(int(curr_step * progress_step))
        res = { self.OUTPUT : dest_id }
        return res        
      
class WeightingAlgorithm(WeightingBaseAlgorithm):
    
    INPUT_LAYER = 'INPUT_LAYER'
    WEIGHT_LAYER = 'WEIGHT_LAYER'
    RESAMPLING = 'RESAMPLING'
    OUTPUT = 'OUTPUT'
        
    def name(self):
        return self.ALG_NAME
        
    def group(self):
        return "Weighting step"
        
    def groupId(self):
        return 'weighting'

    def initAlgorithm(self, config=None):
        self.methods = ((self.tr('Nearest neighbour'), 'near'),
                        (self.tr('Bilinear'), 'bilinear'),
                        (self.tr('Cubic'), 'cubic'),
                        (self.tr('Cubic spline'), 'cubicspline'),
                        (self.tr('Lanczos windowed sinc'), 'lanczos'),
                        (self.tr('Average'), 'average'),
                        (self.tr('Mode'), 'mode'),
                        (self.tr('Maximum'), 'max'),
                        (self.tr('Minimum'), 'min'),
                        (self.tr('Median'), 'med'),
                        (self.tr('First quartile'), 'q1'),
                        (self.tr('Third quartile'), 'q3'))
                        
        self.addParameter(
            QgsProcessingParameterRasterLayer(
                self.INPUT_LAYER,
                description=self.tr('Input layer')))
        self.addParameter(
            QgsProcessingParameterRasterLayer(
                self.WEIGHT_LAYER,
                description=self.tr('Weighting layer')))
        self.addParameter(QgsProcessingParameterEnum(self.RESAMPLING,
                                                     self.tr('Resampling method to use'),
                                                     options=[i[0] for i in self.methods],
                                                     optional=True,
                                                     defaultValue=0))
        self.addParameter(
            QgsProcessingParameterRasterDestination(
                self.OUTPUT,
                self.tr("Output layer")))
                
    def prepareParameters(self,parameters,context,feedback):
        input = self.parameterAsRasterLayer(parameters,self.INPUT_LAYER,context)
        if input is None:
            raise QgsProcessingException(self.invalidRasterError(parameters, self.INPUT_LAYER))
        weighting = self.parameterAsRasterLayer(parameters,self.WEIGHT_LAYER,context)
        if weighting is None:
            raise QgsProcessingException(self.invalidRasterError(parameters, self.WEIGHT_LAYER))
        resampling = parameters[self.RESAMPLING]
        output = self.parameterAsOutputLayer(parameters, self.OUTPUT, context)
        return (input, weighting, resampling, output)
        
    def warpWeightingLayer(self,parameters,context,feedback):
        input, weighting, resampling, output = self.prepareParameters(parameters,context,feedback)
        input_dp = input.dataProvider()
        nodata_val = input_dp.sourceNoDataValue(1)
        resolution = input.rasterUnitsPerPixelX()
        crs = input.crs()
        out = QgsProcessingUtils.generateTempFilename('warped.tif')
        warp_params = { 'INPUT' : weighting,
                        'TARGET_CRS' : crs,
                        'RESAMPLING' : resampling,
                        'NODATA' : nodata_val,
                        'TARGET_RESOLUTION' : resolution,
                        'TARGET_EXTENT' : input.extent(),
                        'TARGET_EXTENT_CRS' : crs,
                        'OUTPUT' : out }
        warped = processing.run('gdal:warpreproject',warp_params,context=context,feedback=feedback)
        return warped['OUTPUT']
        
    def warpFromCustomLayer(self,input,resampling,output,context,feedback):
        input_dp = input.dataProvider()
        nodata_val = input_dp.sourceNoDataValue(1)
        resolution = input.rasterUnitsPerPixelX()
        crs = input.crs()
        warp_params = { 'INPUT' : input,
                        'TARGET_CRS' : crs,
                        'RESAMPLING' : resampling,
                        'NODATA' : nodata_val,
                        'TARGET_RESOLUTION' : resolution,
                        'TARGET_EXTENT' : input.extent(),
                        'TARGET_EXTENT_CRS' : crs,
                        'OUTPUT' : output }
        warped = processing.run('gdal:warpreproject',warp_params,context=context,feedback=feedback)
        return warped['OUTPUT']


class WeightingBasics(WeightingAlgorithm):

    ALG_NAME = 'weightingbasics'

    OPERATOR = 'OPERATOR'
        
    def createInstance(self):
        return WeightingBasics()
        
    def displayName(self):
        return self.tr('Weighting (Basics)')
        
    def shortHelpString(self):
        helpStr = "Weighting of friction layer A by another layer B. Layers must be aligned.\n"
        helpStr += "Available weighting operations :\n"
        helpStr += " * Minimum (pixResult = min(pixA, pixB))\n"
        helpStr += " * Maximum (pixResult = max(pixA, pixB))\n"
        helpStr += " * Multiplication (pixResult = pixA * pixB)"
        return self.tr(helpStr)

    def initAlgorithm(self, config=None):
        self.operators = [ self.tr('Minimum'),
                           self.tr('Maximum'),
                           self.tr('Multiplication') ]
        super().initAlgorithm()
        self.addParameter(QgsProcessingParameterEnum(self.OPERATOR,
                                                     self.tr('Weighting method to use'),
                                                     options=self.operators,
                                                     defaultValue=0))
                                                             
    def processAlgorithm(self,parameters,context,feedback):
        input, weighting, resampling, output = self.prepareParameters(parameters,context,feedback)
        operator = self.parameterAsEnum(parameters,self.OPERATOR,context)
        #output = self.parameterAsOutputLayer(parameters, self.OUTPUT, context)
        warped_path = self.warpWeightingLayer(parameters,context,feedback)
        feedback.pushDebugInfo('warped_path = ' + str(warped_path))
        warped_layer = qgsUtils.loadRasterLayer(warped_path)
        nodata_val = input.dataProvider().sourceNoDataValue(1)
        min, max = qgsUtils.getRastersMinMax([input,weighting])
        range = [min,max]
        layers = [qgsUtils.pathOfLayer(input),qgsUtils.pathOfLayer(weighting)]
        out_path = parameters['OUTPUT']
        feedback.pushDebugInfo('out_path = ' + str(out_path))
        feedback.pushDebugInfo('output = ' + str(output))
        # if os.path.isfile(out_path):
            # qgsUtils.removeRaster(out_path)
        if operator == 0:
            # out = qgsTreatments.applyRSeries(layers,4,range,output,
                                             # context=context,feedback=feedback)
            out = qgsTreatments.applyRasterCalcMin(input,warped_layer,output,
                                                   nodata_val=nodata_val,out_type=4,
                                                   context=context,feedback=feedback)
        elif operator == 1:
            # out = qgsTreatments.applyRSeries(layers,6,range,output,
                                             # context=context,feedback=feedback)
            out = qgsTreatments.applyRasterCalcMax(input,warped_layer,output,
                                                   nodata_val=nodata_val,out_type=4,
                                                   context=context,feedback=feedback)
        elif operator == 2:
            out = qgsTreatments.applyRasterCalcMult(input,warped_layer,output,
                                                    nodata_val=nodata_val,out_type=4,
                                                    context=context,feedback=feedback)
        else:
            assert(False)
        return { 'OUTPUT' : out }

            
class WeightingIntervalsAlgorithm(WeightingAlgorithm):
    
    INTERVALS = 'INTERVALS'
    RANGE_BOUNDARIES = 'RANGE_BOUNDARIES'
    
    LOW_BOUND = 'LOW_BOUND'
    UP_BOUND = 'UP_BOUND'
    POND_VAL = 'POND_VALUE'
    NODATA_POND_VAL = 'NODATA_POND_VALUE'

    def initAlgorithm(self, config=None):
        self.range_boundaries = [self.tr('min < value <= max'),
                                 self.tr('min <= value < max'),
                                 self.tr('min <= value <= max'),
                                 self.tr('min < value < max')]
        super().initAlgorithm(config)
        self.addParameter(
            QgsProcessingParameterMatrix (
                self.INTERVALS,
                description=self.tr('Intervals'),
                numberRows=1,
                hasFixedNumberRows=False,
                headers=[self.LOW_BOUND,self.UP_BOUND,self.POND_VAL]))
        self.addParameter(QgsProcessingParameterEnum(self.RANGE_BOUNDARIES,
                                                     self.tr('Range boundaries'),
                                                     options=self.range_boundaries,
                                                     optional=True,
                                                     defaultValue=2))
                
   
class WeightingByIntervals(WeightingIntervalsAlgorithm):

    ALG_NAME = 'weightingbyintervals'
        
    def createInstance(self):
        return WeightingByIntervals()
        
    def displayName(self):
        return self.tr('Weighting (By intervals)')
        
    def shortHelpString(self):
        helpStr = "Weighting of friction layer A by another layer B. Layers must be aligned.\n"
        helpStr += "Value intervals [lowBound, upBound] and weighting value 'pond_val' are defined for layer B.\n"
        helpStr += "If pixB belongs to [lowBound, upBound] then pixResult = pixA * pond_val."
        return self.tr(helpStr)

    def initAlgorithm(self, config=None):
        super().initAlgorithm(config)
                
    def processAlgorithm(self,parameters,context,feedback):
        input, weighting, resampling, output = self.prepareParameters(parameters,context,feedback)
        range_boundaries = self.parameterAsEnum(parameters,self.RANGE_BOUNDARIES,context)
        # WARP
        warped_layer = self.warpWeightingLayer(parameters,context,feedback)
        # RECLASSIFY
        nodata_val = input.dataProvider().sourceNoDataValue(1)
        out_reclassed = QgsProcessingUtils.generateTempFilename('Reclassed.tif')
        reclass_params = { 'DATA_TYPE' : 5,
                           'INPUT_RASTER' : warped_layer,
                           'NODATA_FOR_MISSING' : True,
                           'NO_DATA' : nodata_val,
                           'OUTPUT' : out_reclassed,
                           'RANGE_BOUNDARIES' : range_boundaries,
                           'RASTER_BAND' : 1,
                           'TABLE' : parameters[self.INTERVALS] }
        reclassed = processing.run('native:reclassifybytable',reclass_params,context=context,feedback=feedback)
        reclassed_layer = reclassed['OUTPUT']
        # WEIGHTING
        weighted = qgsTreatments.applyRasterCalcMult(input,reclassed_layer,output,
                                                     nodata_val=nodata_val,out_type=5,
                                                     context=context,feedback=feedback)
        return { 'OUTPUT' : weighted }
   
class WeightingByDistance(WeightingIntervalsAlgorithm):

    ALG_NAME = 'weightingbydistance'
        
    def createInstance(self):
        return WeightingByDistance()
        
    def displayName(self):
        return self.tr('Weighting (By distance)')
        
    def shortHelpString(self):
        helpStr = "Weighting of friction layer A by distance to another layer B. Layers must be aligned.\n"
        helpStr += "Distance intervals [lowBound, upBound] and weighting value 'pond_val' are defined for layer B.\n"
        helpStr += "Distance of pixA to layer B is computed as the minimum distance from pixA to a pixel of B that is not NoData"
        helpStr += "If distance(pixA,B) belongs to [lowBound, upBound] then pixResult = pixA * pond_val."
        return self.tr(helpStr)

    def initAlgorithm(self, config=None):
        super().initAlgorithm(config)
                
    def processAlgorithm(self,parameters,context,feedback):
        input, weighting, resampling, output = self.prepareParameters(parameters,context,feedback)
        range_boundaries = self.parameterAsEnum(parameters,self.RANGE_BOUNDARIES,context)
        intervals = self.parameterAsMatrix(parameters,self.INTERVALS,context)
        # WARP
        warped_layer = self.warpWeightingLayer(parameters,context,feedback)
        # BUFFER
        feedback.pushDebugInfo('intervals = ' +str(intervals))
        distances = intervals[1::3]
        feedback.pushDebugInfo('distances = ' +str(distances))
        distances_str = ",".join([str(d) for d in distances])
        feedback.pushDebugInfo('distances_str = ' +str(distances_str))
        out_buffer = QgsProcessingUtils.generateTempFilename('out_buffer.tif')
        buffer_params = { 'input' : warped_layer,
                          'output' : out_buffer,
                          'distances' : distances_str,
                          'units' : 0, # 0 = meters ?
                          'GRASS_RASTER_FORMAT_META' : '',
                          'GRASS_RASTER_FORMAT_OPT' : '',
                          'GRASS_REGION_CELLSIZE_PARAMETER' : 0,
                          'GRASS_REGION_PARAMETER' : None,
                          '-z' : False }
                          #'--type' : 'Int32'
                          #'--overwrite' : False}
        feedback.pushDebugInfo("buffer_params = " + str(buffer_params))
        buffered = processing.run('grass7:r.buffer',buffer_params,context=context,feedback=feedback)
        feedback.pushDebugInfo("buffered = " + str(buffered))
        buffered_layer = buffered['output']
        feedback.pushDebugInfo("buffered_layer = " + str(buffered_layer))
        # RECLASSIFY
        pond_vals = intervals[2::3]
        feedback.pushDebugInfo('pond_vals = ' + str(pond_vals))
        pv1 = pond_vals[0]
        pond_table = [1,1,pv1]
        for idx, pv in enumerate(pond_vals,2):
            pond_table.append(idx)
            pond_table.append(idx)
            pond_table.append(pv)
        feedback.pushDebugInfo('pond_table = ' + str(pond_table))
        nodata_val = input.dataProvider().sourceNoDataValue(1)
        out_reclassed = QgsProcessingUtils.generateTempFilename('Reclassed.tif')
        reclass_params = { 'DATA_TYPE' : 5,
                           'INPUT_RASTER' : buffered_layer,
                           'NODATA_FOR_MISSING' : True,
                           'NO_DATA' : nodata_val,
                           'OUTPUT' : out_reclassed,
                           'RANGE_BOUNDARIES' : range_boundaries,
                           'RASTER_BAND' : 1,
                           'TABLE' : pond_table }
        feedback.pushDebugInfo("reclass_params = " + str(reclass_params))
        reclassed = processing.run('native:reclassifybytable',reclass_params,context=context,feedback=feedback)
        reclassed_layer = reclassed['OUTPUT']
        # NODATA
        reclassed_nonull = QgsProcessingUtils.generateTempFilename('reclassed_nonull.tif')
        nonull = qgsTreatments.applyRNull(reclassed_layer,1,reclassed_nonull,context=context,feedback=feedback)
        # WEIGHTING
        weighted = qgsTreatments.applyRasterCalcMult(input,nonull,output,
                                                     nodata_val=nodata_val,out_type=5,
                                                     context=context,feedback=feedback)
        return { 'OUTPUT' : weighted }
   
class RasterSelectionByValue(QgsProcessingAlgorithm):

    ALG_NAME = 'rasterselectionbyvalue'

    INPUT = 'INPUT'
    OPERATOR = 'OPERATOR'
    VALUE = 'VALUE'
    OUTPUT = 'OUTPUT'
    
    OPERATORS = ['<','<=','>','>=','==','!=']
    OPERATORS_CMPL = ['>=','>','<=','<','!=','==']
    
    def tr(self, string):
        return QCoreApplication.translate('Processing', string)
        
    def createInstance(self):
        return RasterSelectionByValue()
        
    def name(self):
        return self.ALG_NAME
        
    def displayName(self):
        return self.tr('Raster selection by value')
        
    def shortHelpString(self):
        return self.tr('Creates new raster with input raster values veryfing specified operation.')

    def initAlgorithm(self, config=None):
        self.addParameter(
            QgsProcessingParameterRasterLayer(
                self.INPUT,
                description=self.tr('Input layer')))
        self.addParameter(
            QgsProcessingParameterEnum(self.OPERATOR,
                                       self.tr('Operator'),
                                       options=self.OPERATORS,
                                       defaultValue=4))
        self.addParameter(
            QgsProcessingParameterNumber (
                self.VALUE,
                description=self.tr('Value'),
                defaultValue=0.0,
                type=QgsProcessingParameterNumber.Double))
        self.addParameter(
            QgsProcessingParameterRasterDestination(
                self.OUTPUT,
                self.tr("Output layer")))
                
    def getDataType(self,in_type):
        typeAssoc = { Qgis.Byte : 0,
                      Qgis.Int16 : 1,
                      Qgis.UInt16 : 2,
                      Qgis.UInt32 : 3,
                      Qgis.Int32 : 4,
                      Qgis.Float32 : 5,
                      Qgis.Float64 : 6 }
        if in_type in typeAssoc:
            return typeAssoc[in_type]
            #return 5
        else:
            return 5
                
    def processAlgorithm(self,parameters,context,feedback):
        input = self.parameterAsRasterLayer(parameters,self.INPUT,context)
        if input is None:
            raise QgsProcessingException(self.invalidRasterError(parameters, self.INPUT))
        operator = self.parameterAsEnum(parameters,self.OPERATOR,context)
        value = self.parameterAsDouble(parameters,self.VALUE,context)
        output = self.parameterAsOutputLayer(parameters, self.OUTPUT, context)
        # Type
        input_type = input.dataProvider().sourceDataType(1)
        out_type = self.getDataType(input_type)
        # Expression
        input_nodata_val = input.dataProvider().sourceNoDataValue(1)
        operator_str = self.OPERATORS[operator]
        operator_cmpl_str = self.OPERATORS_CMPL[operator]
        value_str = str(value)
        nodata_str = str(input_nodata_val)
        cmp_expr = '(A {} {})'.format(operator_str,value_str)
        cmp_expr_cmpl = '(A {} {})'.format(operator_cmpl_str,value_str)
        expr = "A * " + str(cmp_expr)
        mult_expr = "A * B"
        if math.isnan(input_nodata_val):
            nodata_val = None
        else:
            nodata_val = input_nodata_val
        feedback.pushDebugInfo("nodata_val = " + nodata_str)
        feedback.pushDebugInfo("gdalcalc expr = " + str(expr))
        # Call
        tmp = QgsProcessingUtils.generateTempFilename('tmp.tif')
        out = qgsTreatments.applyRasterCalc(input,tmp,expr,
                                      nodata_val=0,out_type=out_type,
                                      context=context,feedback=feedback)
        out = qgsTreatments.applyRSetNull(tmp,0,output,context,feedback)
        return { 'OUTPUT' : out }
        
    
    
class RasterizeFixAllTouch(rasterize):

    ALG_NAME = 'rasterizefixalltouch'

    def createInstance(self):
        return RasterizeFixAllTouch()
        
    def name(self):
        return self.ALG_NAME
        
    def displayName(self):
        return self.tr('Rasterize (with ALL_TOUCH fix)')
        
    def group(self):
        return "Auxiliary algorithms"
        
    def groupId(self):
        return 'aux'
        
    def shortHelpString(self):
        return self.tr('Wrapper for gdal:rasterize algorithm allowing to use ALL_TOUCH option (every pixel touching input geometry are rasterized).')

    def initAlgorithm(self, config=None):
        super().initAlgorithm(config)
        self.addParameter(
            QgsProcessingParameterBoolean(
                self.ALL_TOUCH,
                description = 'ALL_TOUCH option',
                defaultValue=False,
                optional=True))
    
# Apply rasterization on field 'field' of vector layer 'in_path'.
# Output raster layer in 'out_path'.
# Resolution set to 25 if not given.
# Extent can be given through 'extent_path'. If not, it is extracted from input layer.
# Output raster layer is loaded in QGIS if 'load_flag' is True.
def applyRasterizationFixAllTouch(in_path,out_path,extent,resolution,
                   field=None,burn_val=None,out_type=Qgis.Float32,
                   nodata_val=qgsTreatments.nodata_val,all_touch=False,overwrite=False,
                   context=None,feedback=None):
    TYPES = ['Byte', 'Int16', 'UInt16', 'UInt32', 'Int32', 'Float32',
         'Float64', 'CInt16', 'CInt32', 'CFloat32', 'CFloat64']
    if overwrite:
        qgsUtils.removeRaster(out_path)
    extra_param_name = 'EXTRA'
    if hasattr(rasterize,extra_param_name):
        res = qgsTreatments.applyRasterization(in_path,out_path,extent,resolution,
                field,burn_val,out_type,nodata_val,all_touch,overwrite,
                context,feedback)
    else:
        parameters = { 'ALL_TOUCH' : True,
                   'BURN' : burn_val,
                   'DATA_TYPE' : out_type,
                   'EXTENT' : extent,
                   'FIELD' : field,
                   'HEIGHT' : resolution,
                   'INPUT' : in_path,
                   'NODATA' : nodata_val,
                   'OUTPUT' : out_path,
                   'UNITS' : 1, 
                   'WIDTH' : resolution }
        res = qgsTreatments.applyProcessingAlg("BioDispersal","rasterizefixalltouch",parameters,context,feedback)
    return res
    
    
class ChangeNoDataVal(QgsProcessingAlgorithm):

    ALG_NAME = 'changenodata'
    
    INPUT = 'INPUT'
    NODATA_VAL = 'NODATA_VAL'
    OUTPUT = 'OUTPUT'

    def tr(self, string):
        return QCoreApplication.translate('Processing', string)
        
    def createInstance(self):
        return ChangeNoDataVal()
        
    def name(self):
        return self.ALG_NAME
        
    def group(self):
        return "Auxiliary algorithms"
        
    def groupId(self):
        return 'aux'
        
    def displayName(self):
        return self.tr('Change NoData value')
        
    def shortHelpString(self):
        return self.tr('Change NoData value and reclassifies old NoData pixels to new NoData value.')

    def initAlgorithm(self, config=None):
        self.addParameter(
            QgsProcessingParameterRasterLayer(
                self.INPUT,
                description=self.tr('Input layer')))
        self.addParameter(
            QgsProcessingParameterNumber (
                self.NODATA_VAL,
                description=self.tr('New NoData value'),
                type=QgsProcessingParameterNumber.Double))
        self.addParameter(
            QgsProcessingParameterRasterDestination(
                self.OUTPUT,
                self.tr("Output layer")))
                
    def processAlgorithm(self,parameters,context,feedback):
        input = self.parameterAsRasterLayer(parameters,self.INPUT,context)
        if input is None:
            raise QgsProcessingException(self.invalidRasterError(parameters, self.INPUT))
        new_val = self.parameterAsDouble(parameters,self.NODATA_VAL,context)
        output = self.parameterAsOutputLayer(parameters, self.OUTPUT, context)
        input_nodata_val = input.dataProvider().sourceNoDataValue(1)
        feedback.pushDebugInfo("Input NoData value = " + str(input_nodata_val))
        #input_vals = qgsUtils.getRasterValsBis(input)
        input_vals = qgsTreatments.getRasterUniqueVals(input,feedback)
        feedback.pushDebugInfo("Input values = " + str(input_vals))
        if input_vals == []:
            feedback.pushInfo("Empty input layer (no input values)")
        if new_val in input_vals:
            raise QgsProcessingException("Input layer contains pixels with new NoData value '"
                    + str(new_val) + "'.")
        tmp = QgsProcessingUtils.generateTempFilename('tmp.tif')
        qgsTreatments.applyRNull(input,new_val,tmp,context,feedback)
        qgsTreatments.applyRSetNull(tmp,new_val,output,context,feedback)
        return { 'OUTPUT' : output }
    
    
class ExportToGraphab(GraphabAlgorithm):

    ALG_NAME = 'exporttographab'
    
    INPUT = 'INPUT'
    OUTPUT = 'OUTPUT'
        
    def createInstance(self):
        return ExportToGraphab()
        
    def name(self):
        return self.ALG_NAME
        
    def displayName(self):
        return self.tr('Export to Graphab')
        
    def shortHelpString(self):
        return self.tr('Ensures that friction layer is compatible with Graphab.')

    def initAlgorithm(self, config=None):
        self.addParameter(
            QgsProcessingParameterRasterLayer(
                self.INPUT,
                description=self.tr('Input layer (friction)')))
        self.addParameter(
            QgsProcessingParameterRasterDestination(
                self.OUTPUT,
                self.tr("Exported layer (friction)")))
                
    def processAlgorithm(self,parameters,context,feedback):
        input = self.parameterAsRasterLayer(parameters,self.INPUT,context)
        if input is None:
            raise QgsProcessingException(self.invalidRasterError(parameters, self.INPUT))
        output = self.parameterAsOutputLayer(parameters, self.OUTPUT, context)
        input_nodata_val = input.dataProvider().sourceNoDataValue(1)
        feedback.pushDebugInfo("Input NoData value = " + str(input_nodata_val))
        #input_vals = qgsUtils.getRasterValsBis(input)
        input_vals = qgsTreatments.getRasterUniqueVals(input,feedback)
        feedback.pushDebugInfo("Input values = " + str(input_vals))
        if input_vals == []:
            raise QgsProcessingException("Empty input layer (no input values)")
        for v in input_vals:
            if v <= 0:
                raise QgsProcessingException("Input layer contains value '"
                        + str(v) + "', but Graphab expects strictly positive (> 0) values")
                
        if input_nodata_val == 0 and 0 in input_vals:
            raise QgsProcessingException("Input layer contains value 0, but 0 represents NoData in Graphab")
        tmp = QgsProcessingUtils.generateTempFilename('tmp.tif')
        qgsTreatments.applyRNull(input,0,tmp,context,feedback)
        qgsTreatments.applyRSetNull(tmp,0,output,context,feedback)
        return {'OUTPUT' : output }
    
    
class ASCIIOutput(QgsProcessingParameterRasterDestination):
    def __init__(self, name, description):
        super().__init__(name, description)
    def defaultFileExtension(self):
        return 'asc'
    def supportedOutputRasterLayerExtensions(self):
        return ['asc']
    
    
class ExportPatchesToCircuitscape(CircuitscapeAlgorithm):

    ALG_NAME = 'exportpatchestocircuitscape'
    
    INPUT = 'INPUT'
    CLASS = 'CLASS'
    OUTPUT = 'OUTPUT'
        
    # def createInstance(self):
        # return ExportPatchesToCircuitscape()
        
    def displayName(self):
        return self.tr('Export to Circuitscape (start points)')
        
    def shortHelpString(self):
        return self.tr('Export patch layer (focal nodes, biodiversity reservois, ...) to Circuitscape')

    def initAlgorithm(self, config=None):
        self.addParameter(
            QgsProcessingParameterRasterLayer(
                self.INPUT,
                description=self.tr('Input cost layer')))
        self.addParameter(QgsProcessingParameterNumber(
            self.CLASS, "Choose Landscape Class", type=QgsProcessingParameterNumber.Integer,
            defaultValue=None,optional=True))
        self.addParameter(
            ASCIIOutput(
                self.OUTPUT,
                self.tr("Exported layer (start points)")))
                
    def processAlgorithm(self,parameters,context,feedback):
        if not import_scipy_ok:
            msg = "Scipy (python library) import failed. You can install it through OSGEO installer"
            raise QgsProcessingException(msg)
    
        input = self.parameterAsRasterLayer(parameters,self.INPUT,context)
        if input is None:
            raise QgsProcessingException(self.invalidRasterError(parameters, self.INPUT))
        cl = self.parameterAsInt(parameters, self.CLASS, context)
        cl_param = parameters[self.CLASS]
        output = self.parameterAsOutputLayer(parameters, self.OUTPUT, context)
                
        input_filename = input.source()
        input_nodata_val = input.dataProvider().sourceNoDataValue(1)
        feedback.pushDebugInfo("Input NoData value = " + str(input_nodata_val))
        if input_nodata_val == 1:
            raise QgsProcessingException("Input NoData value cannot be equal to 1.")
        input_type = input.dataProvider().dataType(1)
        feedback.pushDebugInfo("Input type = " + str(input_type))
        # if 0 in input_vals:
            # raise QgsProcessingException("Input layer contains 0 value")
        feedback.pushDebugInfo("output = " + str(output))
        output_basename, ext = os.path.splitext(output)
        output_tif = output_basename + ".tif"
                
        classes, array = qgsUtils.getRasterValsAndArray(str(input_filename))
        new_array = np.copy(array)
        feedback.pushDebugInfo("class = " + str(cl) + ", " + str(parameters[self.CLASS]))
        feedback.pushDebugInfo("array = " + str(array[0][0]))
        feedback.pushDebugInfo("new_array = " + str(new_array[0][0]))
        if cl_param is None:
            new_array[array!=input_nodata_val] = 1
            new_array[array==input_nodata_val] = 0
            new_array[array!=array] = 0
        elif cl not in classes:
            raise QgsProcessingException("No pixel found with class value " + str(cl))
        else:
            new_array[new_array!=cl] = 0
            new_array[array==cl] = 1
        struct = scipy.ndimage.generate_binary_structure(2,2)
        labeled_array, nb_patches = scipy.ndimage.label(new_array,struct)
        labeled_array[labeled_array==0] = input_nodata_val
        
        qgsUtils.exportRaster(labeled_array,input_filename,output_tif,
            nodata=input_nodata_val,type=input_type)
        out = qgsTreatments.applyTranslate(output_tif,output,data_type=input_type,
            nodata_val=input_nodata_val,context=context,feedback=feedback)
        # Data type coule be problematic if input layer has small type 
        # (suchs as Byte but BioDispersal exports Float32) and lot of patches.
        return {'OUTPUT' : out }
      
      
class ExportFrictionToCircuitscape(CircuitscapeAlgorithm):

    ALG_NAME = 'exportfrictiontocircuitscape'
    
    INPUT = 'INPUT'
    OUTPUT = 'OUTPUT'
        
    # def createInstance(self):
        # return ExportFrictionToCircuitscape()
        
    def displayName(self):
        return self.tr('Export to Circuitscape (friction layer)')
        
    def shortHelpString(self):
        return self.tr('Export friction (resistance) layer to Circuitscape, converting existing layer to ASCII format.')

    def initAlgorithm(self, config=None):
        self.addParameter(
            QgsProcessingParameterRasterLayer(
                self.INPUT,
                description=self.tr('Input resistance layer')))
        self.addParameter(
            ASCIIOutput(
                self.OUTPUT,
                self.tr("Exported layer (resistance)")))
                
    def processAlgorithm(self,parameters,context,feedback):    
        input = self.parameterAsRasterLayer(parameters,self.INPUT,context)
        if input is None:
            raise QgsProcessingException(self.invalidRasterError(parameters, self.INPUT))
        output = self.parameterAsOutputLayer(parameters, self.OUTPUT, context)        
                
        if output is None:
            raise QgsProcessingException("Empty output layer")
        base, ext = os.path.splitext(output)
        if ext != '.asc':
            raise QgsProcessingException("Invalid extension for output ASCII file : " + str(output))
        input_filename = input.source()
        input_nodata_val = input.dataProvider().sourceNoDataValue(1)
        feedback.pushDebugInfo("Input NoData value = " + str(input_nodata_val))
        if input_nodata_val == 1:
            raise QgsProcessingException("Input NoData value cannot be equal to 1.")
            
        input_type = input.dataProvider().dataType(1)
        out = qgsTreatments.applyTranslate(input_filename,output,data_type=input_type,
            nodata_val=input_nodata_val,context=context,feedback=feedback)
        return {'OUTPUT' : output }
        
        
class RandomStartPointsCircuitscape(CircuitscapeAlgorithm):

    ALG_NAME = 'randomStartPointsCircuitscape'
    
    def displayName(self):
        return self.tr('Random start points (Circuitscape)')
        
    def shortHelpString(self):
        return self.tr('Generates random start points layer for circuitscape input')
        
    PATCH_LAYER = 'PATCH_LAYER'
    NB_POINTS = 'NB_POINTS'
    NB_LAUNCHES = 'NB_LAUNCHES'
    DEFAULT_NB_LAUNCHES = 1
    RESISTANCE_LAYER = 'RESISTANCE_LAYER'
    # OUTPUT_DIR = 'OUTPUT_DIR'
    OUTPUT = 'OUTPUT'

    POINTS_VECTOR = 'POINTS_VECTOR'

    def initAlgorithm(self,config=None):
        self.addParameter(
            QgsProcessingParameterFeatureSource(
                self.PATCH_LAYER,
                description=self.tr('Patch layer')))
        self.addParameter(
            QgsProcessingParameterRasterLayer(
                self.RESISTANCE_LAYER,
                description=self.tr('Resistance layer')))
        self.addParameter(
            QgsProcessingParameterNumber (
                self.NB_POINTS,
                description=self.tr('Number of points'),
                type=QgsProcessingParameterNumber.Integer))
        self.addParameter(
            QgsProcessingParameterNumber (
                self.NB_LAUNCHES,
                description=self.tr('Number of launches'),
                type=QgsProcessingParameterNumber.Integer,
                defaultValue=self.DEFAULT_NB_LAUNCHES))
        self.addParameter(
            QgsProcessingParameterFolderDestination (
                self.OUTPUT,
                description=self.tr('Output directory')))
        
        
    def processAlgorithm(self,parameters,context,feedback):
        # Parameters
        patch_source, patch_layer = qgsTreatments.parameterAsSourceLayer(
            self,parameters,self.PATCH_LAYER,context,feedback=feedback)
        resistance_layer = self.parameterAsRasterLayer(parameters,self.RESISTANCE_LAYER,context)
        nb_points = self.parameterAsInt(parameters, self.NB_POINTS, context)
        nb_launches = self.parameterAsInt(parameters, self.NB_LAUNCHES, context)
        out_dir = self.parameterAsFileOutput(parameters,self.OUTPUT,context)
        resistance_path = qgsUtils.pathOfLayer(resistance_layer)
        # Init input / output
        utils.mkDir(out_dir)
        dirname = os.path.dirname(__file__)
        base_config_file = os.path.join(dirname,"baseConfig.ini")
        fin = open(base_config_file,"rt")
        config_content = fin.read()
        fin.close()
        # Resistance translation
        EPT = ExportFrictionToCircuitscape
        out_resistance = os.path.join(out_dir,'resistance.asc')
        parameters = { EPT.INPUT : resistance_layer , EPT.OUTPUT : out_resistance } 
        qgsTreatments.applyProcessingAlg('BioDispersal',EPT.ALG_NAME,
            parameters,context=context,feedback=feedback)
        # Loop
        step_feedback = feedbacks.ProgressMultiStepFeedback(nb_launches*4,feedback)
        outfiles = []
        for i in range(nb_launches):
            bname = "launch" + str(i)
            basepath = os.path.join(out_dir,bname)
            # Sort random points from patch layer
            points_vector = basepath + "_start.gpkg"
            qgsTreatments.applyVRandom(patch_layer,nb_points,points_vector,
                context=context,feedback=step_feedback)
            #qgsUtils.loadVectorLayer(points_vector,loadProject=True)
            step_feedback.setCurrentStep(4*i+1)
            # Rasterize points layer
            extent = resistance_layer.extent()
            resolution = resistance_layer.rasterUnitsPerPixelX()
            #points_tif = QgsProcessingUtils.generateTempFilename('points_raster.tif')
            points_tif = basepath + "_start.tif"
            qgsUtils.removeRaster(points_tif)
            qgsTreatments.applyRasterization(points_vector,points_tif,extent,resolution,
                field='cat',out_type=Qgis.Int16,nodata_val=-9999,
                context=context,feedback=step_feedback)
            #qgsUtils.loadRasterLayer(points_tif,loadProject=True)
            step_feedback.setCurrentStep(4*i+2)
            # Convert to asc
            #points_asc = QgsProcessingUtils.generateTempFilename('points_raster.asc')
            points_asc = basepath + "_start.asc"
            qgsUtils.removeRaster(points_asc)
            qgsTreatments.applyTranslate(points_tif,points_asc,
                nodata_val=0,context=context,feedback=step_feedback)
            #qgsUtils.loadRasterLayer(points_asc,loadProject=True)
            step_feedback.setCurrentStep(4*i+3)
            # Out config file
            out_content = config_content.replace('OUTPUT_DIR',out_dir)
            out_content = out_content.replace('OUTPUT_BNAME',bname)
            out_content = out_content.replace('START_LAYER',points_asc)
            out_content = out_content.replace('RESISTANCE_LAYER',out_resistance)
            outfile = basepath + "_config.ini"
            with open(outfile,"wt") as fout:
                fout.write(out_content)
            outfiles.append(outfile)
            step_feedback.setCurrentStep(4*i+4)
        # Output Julia script
        outscript = os.path.join(out_dir,"launchCircuitscape.jl")
        outscript = utils.normPath(outscript)
        script_text = "#include(\"" + outscript +"\")\n"
        script_text += "using Circuitscape\n"
        for outfile in outfiles:
            # f_posix = str(Path(outfile))
            # f_posix = f_posix.replace("\\","/")
            f_posix = utils.normPath(outfile)
            script_text += "compute(\"" + f_posix + "\")\n"
        utils.removeFile(outscript)
        with open(outscript,"w+") as fout:
            fout.write(script_text)
        os.chmod(outscript,0o7242)
        #os.chmod(outscript,stat.S_IXUSR)
        return { self.OUTPUT : out_dir }
        
        
class AggregateCirctuitscapeCurrentMaps(CircuitscapeAlgorithm):

    ALG_NAME = 'aggrCurrMapsLayers'
    
    def displayName(self):
        return self.tr('Aggregates current maps')
        
    def shortHelpString(self):
        return self.tr('Aggregates current maps (Circuitscape output) into one cumulative current map')
        
    INPUT_LAYERS = 'INPUT_LAYERS'
    OUTPUT = 'OUTPUT'

    def initAlgorithm(self,config=None):
        self.addParameter(
            QgsProcessingParameterMultipleLayers(
                self.INPUT_LAYERS,
                description=self.tr('Input layers'),
                layerType=QgsProcessing.TypeRaster))
        self.addParameter(
            QgsProcessingParameterRasterDestination(
                self.OUTPUT,
                self.tr("Output layer")))
                
    # def createFileFilter(self):
        # return "*.asc"
                
    def processAlgorithm(self,parameters,context,feedback):
        # Parameters
        input_layers = self.parameterAsLayerList(parameters,self.INPUT_LAYERS,context)
        output = self.parameterAsOutputLayer(parameters, self.OUTPUT, context)
        # Serie
        aggregate = QgsProcessingUtils.generateTempFilename('aggregate.tif')
        qgsTreatments.applyRSeries(input_layers,aggr_func=0,output=aggregate,
            context=context,feedback=feedback)
        # Set null
        qgsTreatments.applyRSetNull(aggregate,0,output,context=context,feedback=feedback)
        # Set style
        # self.output = output
        # self.out_layer = qgsUtils.loadRasterLayer(output)
        return { self.OUTPUT : output }

    # def postProcessAlgorithm(self, context, feedback):
        # out_layer = self.out_layer#qgsUtils.loadRasterLayer(output)
        # color_ramp = styles.mkColorRamp('Plasma')
        # shader = styles.mkRasterShader(out_layer,color_ramp)
        # styles.setSBPCRasterRenderer(out_layer,shader)
        # out_layer.triggerRepaint()
        # return { self.OUTPUT : self.out_layer }
        
        
class AggregateCirctuitscapeResults(CircuitscapeAlgorithm):

    ALG_NAME = 'aggrCircuitscapeResults'
    
    def displayName(self):
        return self.tr('Aggregates Circuitscape results')
        
    def shortHelpString(self):
        return self.tr('Aggregates Circuitscape results (start points and current maps) from directory')
        
    RESULTS_DIR = 'RESULTS_DIR'
    AGGR_CURR = 'AGGR_CURR'
    AGGR_START = 'AGGR_START'

    def initAlgorithm(self,config=None):
        self.addParameter(
            QgsProcessingParameterFile(
                self.RESULTS_DIR,
                description=self.tr('Results directory'),
                behavior=QgsProcessingParameterFile.Folder))
        self.addParameter(
            QgsProcessingParameterRasterDestination(
                self.AGGR_CURR,
                self.tr("Aggregate current map")))
        self.addParameter(
            QgsProcessingParameterVectorDestination(
                self.AGGR_START,
                self.tr("Aggregate start points")))
                
    def processAlgorithm(self,parameters,context,feedback):
        # Parameters
        input_dir = self.parameterAsFile(parameters,self.RESULTS_DIR,context)
        aggr_curr = self.parameterAsOutputLayer(parameters, self.AGGR_CURR, context)
        aggr_start = self.parameterAsOutputLayer(parameters, self.AGGR_START, context)
        # Retrieve files
        files = os.listdir(input_dir)
        curr_maps = [os.path.join(input_dir,f) for f in files if f.endswith("_cum_curmap.asc")]
        start_layers = [os.path.join(input_dir,f) for f in files if f.endswith("_start.gpkg")]
        nb_curr_maps, nb_start_layers = len(curr_maps), len(start_layers)
        if nb_curr_maps != nb_start_layers:
            raise QgsProcessingException("Inconsistent number of maps : "
                + str(nb_curr_maps) + " current maps vs "
                + str(nb_start_layers) + " start points layers")
        if nb_curr_maps == 0:
            raise QgsProcessingException("No layers found in " + str(input_dir))
        # Aggregate current
        ACC = AggregateCirctuitscapeCurrentMaps
        parameters = { ACC.INPUT_LAYERS : curr_maps, ACC.OUTPUT : aggr_curr} 
        qgsTreatments.applyProcessingAlg('BioDispersal',ACC.ALG_NAME,parameters,
            context=context,feedback=feedback)
        # Aggregate start points
        layer = qgsUtils.loadVectorLayer(start_layers[0])
        crs = layer.crs()
        qgsTreatments.mergeVectorLayers(start_layers,crs,aggr_start,
            context=context,feedback=feedback)
        # Return
        return { self.AGGR_CURR : aggr_curr, self.AGGR_START : aggr_start }
    
