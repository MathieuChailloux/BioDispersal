# -*- coding: utf-8 -*-
"""
/***************************************************************************
 BioDispersal
                                 A QGIS plugin
 Computes ecological continuities based on environments permeability
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2018-04-12
        git sha              : $Format:%H$
        copyright            : (C) 2018 by IRSTEA
        email                : mathieu.chailloux@irstea.fr
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os
import stat
import math
import xml.etree.ElementTree as ET
from pathlib import Path
from abc import ABC, abstractmethod

try:
    import scipy
    from scipy import ndimage
    import_scipy_ok = True
except ImportError:
    import_scipy_ok = False
try:
    import numpy as np
    import_numpy_ok = True
except ImportError:
    import_numpy_ok = False
try:
    from osgeo import gdal
except ImportError:
    import gdal
    
from PyQt5.QtCore import QCoreApplication, QVariant
from PyQt5.QtGui import QIcon
from qgis.core import (Qgis,
                       QgsProject,
                       QgsFields,
                       QgsField,
                       QgsFeature,
                       QgsProcessing,
                       QgsProcessingUtils,
                       QgsProcessingAlgorithm,
                       QgsProcessingException,
                       QgsProcessingProvider,
                       QgsProcessingMultiStepFeedback,
                       QgsProcessingParameterDefinition,
                       QgsProcessingParameterFeatureSource,
                       QgsProcessingParameterMultipleLayers,
                       QgsProcessingParameterExtent,
                       QgsProcessingParameterNumber,
                       QgsProcessingParameterMatrix,
                       QgsProcessingParameterFeatureSink,
                       QgsProcessingParameterExpression,
                       QgsProcessingParameterString,
                       QgsProcessingParameterField,
                       QgsProcessingParameterRange,
                       QgsProcessingParameterVectorDestination,
                       QgsProcessingParameterRasterDestination,
                       QgsProcessingParameterFileDestination,
                       QgsProcessingParameterFolderDestination,
                       QgsProcessingParameterRasterLayer,
                       QgsProcessingParameterMapLayer,
                       QgsProcessingParameterEnum,
                       QgsProcessingParameterBoolean,
                       QgsProcessingParameterFile,
                       QgsFeatureSink)

import processing
from processing.algs.gdal.rasterize import rasterize

from ..qgis_lib_mc import utils, qgsUtils, qgsTreatments, feedbacks, styles
from ..BioDispersal_model import BioDispersalModel

MEMORY_LAYER_NAME = qgsTreatments.MEMORY_LAYER_NAME

class BioDispersalAlgorithmsProvider(QgsProcessingProvider):

    NAME = "BioDispersal"

    def __init__(self):
        super().__init__()
        
    def unload(self):
        pass
        
    def id(self):
        return self.NAME
        
    def name(self):
        return self.NAME
        
    def longName(self):
        return self.name()
        
    def icon(self):
        icon_path = os.path.join(os.path.dirname(__file__), "..", "icons", "cerf.png")
        return QIcon(icon_path)

    def loadAlgorithms(self):
        alglist = [SelectVExprAlg(),
            SelectVFieldAlg(),
            WeightingBasics(),
            WeightingByIntervals(),
            WeightingByDistance(),
            RasterSelectionByValue(),
            ExtractPatchesR(),
            # BioDispersalAlgorithm(),
            RasterizeFixAllTouch(),
            ExportToGraphab(),
            ExportPatchesToCircuitscape(),
            ExportFrictionToCircuitscape(),
            RandomStartPointsCircuitscape(),
            AggregateCirctuitscapeCurrentMaps(),
            AggregateCirctuitscapeResults(),
            ChangeNoDataVal(),
            DistanceToBorderRaster(),
            LabelPatches(),
            PatchSizeRaster(),
            PatchAreaWindow(),
            # PatchSizeDistrib(),
            PatchSizeWindowRedistrib(),
            ConnectivityIndex(),
            # ConnectivityIndexRedistrib(),
            ConnectivityIndexSimplified(),
            # ConnectivityIndexSimplified2(),
            # SurfaceIndex2(),
            # IsolationIndex(),
            # IsolationIndex2(),
            # IsolationIndex3(),
            # IsolationIndex4(),
            # AreaDistrib(),
            QuantileDistance(),
            MedianDistance(),
            # MedianDistanceDistrib(),
            # ConnexityIndex(),
            # ConnexityIndex2(),
            # NbContactDistrib(),
            # MedianDistanceDistrib2(),
            # NbContactMedianDistrib(),
            NeighboursCount(),
            RelativeSurface()]
        for a in alglist:
            self.addAlgorithm(a)
            
    def supportedOutputRasterLayerExtensions(self):
        return ['tif','asc']

#class BaseAlgorithm(QgsProcessingAlgorithm):
#    def tr(self, string):
#        return QCoreApplication.translate(self.__class__.__name__, string)
class StepAlgorithm(qgsUtils.BaseProcessingAlgorithm):
    def group(self):
        return self.tr("Steps")
    def groupId(self):
        return 'steps'
SelectionAlgorithm = StepAlgorithm
WeightingBaseAlgorithm = StepAlgorithm
class GraphabAlgorithm(qgsUtils.BaseProcessingAlgorithm):
    def group(self):
        return self.tr("Graphab")
    def groupId(self):
        return 'graphab'
class CircuitscapeAlgorithm(qgsUtils.BaseProcessingAlgorithm):
    def group(self):
        return self.tr("Circuitscape")
    def groupId(self):
        return 'circuitscape'
class AuxAlgorithm(qgsUtils.BaseProcessingAlgorithm):
    def group(self):
        return self.tr("Other algorithms")
    def groupId(self):
        return 'misc'
class PatchAlgorithm(qgsUtils.BaseProcessingAlgorithm):
    def group(self):
        return self.tr("Patch utils")
    def groupId(self):
        return 'patch'
    def debugRaster(self,feedback,arr,inputPath,outName,
            nodata=-9999,type=gdal.GDT_Float32):
        if self.DEBUG:
            feedback.pushDebugInfo(outName + " = " + str(arr))
            feedback.pushDebugInfo(outName + ".dtype = " + str(arr.dtype))
            outPath = QgsProcessingUtils.generateTempFilename(outName + ".tif")
            feedback.pushDebugInfo(outName + "path = " + str(outPath))
            qgsUtils.exportRaster(arr,inputPath,outPath,nodata=nodata,type=type)
class IndexAlgorithm(qgsUtils.BaseProcessingAlgorithm):
    def group(self):
        return self.tr("Connectivity index")
    def groupId(self):
        return 'index'
class QualifAlgorithm(qgsUtils.BaseProcessingAlgorithm):
    def group(self):
        return self.tr("Habitat qualification")
    def groupId(self):
        return 'qualif'
               
class BioDispersalAlgorithm(AuxAlgorithm):

    ALG_NAME = 'BioDispersalAlgorithm'
    
    # Algorithm parameters
    INPUT_CONFIG = "INPUT"
    LOG_FILE = "LOG"
        
    def displayName(self):
        return self.tr("Run BioDispersal from configuration file")
        
    def shortHelpString(self):
        return self.tr("Executes complete process from XML configuration file")

    def initAlgorithm(self,config=None):
        self.addParameter(
            QgsProcessingParameterFile(
                self.INPUT_CONFIG,
                description=self.tr("Input configuration file")))
        self.addParameter(
            QgsProcessingParameterFileDestination(
                self.LOG_FILE,
                description=self.tr("Log file")))
                
    def processAlgorithm(self,parameters,context,feedback):
        feedback.pushInfo("begin")
        utils.print_func = feedback.pushInfo
        # Parameters
        log_file = self.parameterAsFile(parameters,self.LOG_FILE,context)
        feedback.pushDebugInfo("log file = " + str(log_file))
        if utils.fileExists(log_file):
            os.remove(log_file)
        with open(log_file,"w+") as f:
            f.write("BioDispersal from configuration file " + str(log_file) + "\n")
            #raise QgsProcessingException("Log file " + str(log_file) + " already exists")
        log_feedback = feedbacks.FileFeedback(log_file)
        log_feedback.pushInfo("File feedback initialized")
        config_file = self.parameterAsFile(parameters,self.INPUT_CONFIG,context)
        config_tree = ET.parse(config_file)
        config_root = config_tree.getroot()
        bdModel = BioDispersalModel(context,log_feedback)
        log_feedback.pushInfo("from log")
        bdModel.feedback.pushInfo("from model")
        bdModel.fromXMLRoot(config_root)
        bdModel.runModel()
        outputs = [bdModel.getOrigPath(item.dict["out_layer"]) for item in bdModel.costModel.items]
        #qgsUtils.loadVectorLayer(res,loadProject=True)
        return {self.OUTPUT: outputs}
               
class SelectVExprAlg(SelectionAlgorithm):

    ALG_NAME = 'selectvexpr'
    
    EXPR = 'EXPR'
    CLASS = 'CLASS'
    CODE = 'CODE'
        
    def displayName(self):
        return self.tr('Selection (by expression)')
        
    def shortHelpString(self):
        return self.tr('Code layer creation from input layer and expression')

    def initAlgorithm(self, config=None):
        self.addParameter(
            QgsProcessingParameterFeatureSource(
                self.INPUT,
                description=self.tr('Input layer')))
        self.addParameter(
            QgsProcessingParameterExpression (
                self.EXPR,
                description=self.tr('Expression'),
                defaultValue="",
                parentLayerParameterName=self.INPUT,
                optional=True))
        self.addParameter(
            QgsProcessingParameterString (
                self.CLASS,
                description=self.tr('Class')))
        self.addParameter(
            QgsProcessingParameterNumber (
                self.CODE,
                description=self.tr('Code'),
                type=QgsProcessingParameterNumber.Integer))
        self.addParameter(
            QgsProcessingParameterFeatureSink(
                self.OUTPUT,
                self.tr("Output layer")))
                
    def processAlgorithm(self,parameters,context,feedback):
        input = self.parameterAsVectorLayer(parameters,self.INPUT,context)
        feedback.pushDebugInfo("input = " + str(input))
        if input is None:
            raise QgsProcessingException(self.invalidSourceError(parameters, self.INPUT))
        qgsUtils.normalizeEncoding(input)
        expr = self.parameterAsExpression(parameters,self.EXPR,context)
        class_name = self.parameterAsString(parameters,self.CLASS,context)
        code = self.parameterAsInt(parameters,self.CODE,context)
        out_fields = QgsFields()
        orig_field = QgsField("Origin", QVariant.String)
        class_field = QgsField("Class", QVariant.String)
        code_field = QgsField("Code", QVariant.Int)
        out_fields.append(orig_field)
        out_fields.append(class_field)
        out_fields.append(code_field)
        (sink, dest_id) = self.parameterAsSink(
            parameters,
            self.OUTPUT,
            context,
            out_fields,
            input.wkbType(),
            input.sourceCrs()
        )
        if sink is None:
            raise QgsProcessingException(self.invalidSinkError(parameters, self.OUTPUT))
            
        if expr is None or expr == "":
            nb_feats = input.featureCount()
            feats = input.getFeatures()
        else:
            qgsTreatments.selectByExpression(input,expr,feedback=feedback)
            nb_feats = input.selectedFeatureCount()
            feats = input.getSelectedFeatures()
            
        if nb_feats == 0:
            raise QgsProcessingException("No feature selected")
        progress_step = 100.0 / nb_feats
        curr_step = 0
        for f in feats:
            new_f = QgsFeature(out_fields)
            new_f["Origin"] = input.sourceName()
            new_f["Class"] = class_name
            new_f["Code"] = code
            new_f.setGeometry(f.geometry())
            sink.addFeature(new_f,QgsFeatureSink.FastInsert)
            curr_step += 1
            feedback.setProgress(int(curr_step * progress_step))
            
        res = { self.OUTPUT : dest_id }
        return res

        
class SelectVFieldAlg(SelectionAlgorithm):

    ALG_NAME = 'selectvfield'
    
    FIELD = 'FIELD'
    GROUP = 'GROUP'
    ASSOC = 'ASSOC'
    
    HEADER_FIELD_VAL = 'Field value'
    HEADER_INT_VAL = 'New integer value'
        
    def displayName(self):
        return self.tr('Selection (by field value)')
        
    def shortHelpString(self):
        return self.tr('Code layer creation from input layer and field values')

    def initAlgorithm(self, config=None):
        self.addParameter(
            QgsProcessingParameterFeatureSource(
                self.INPUT,
                description=self.tr('Input layer')))
        self.addParameter(
            QgsProcessingParameterField(
                self.FIELD,
                description=self.tr('Field'),
                defaultValue=None,
                parentLayerParameterName=self.INPUT))
        self.addParameter(
            QgsProcessingParameterString (
                self.GROUP,
                description=self.tr('Group')))
        self.addParameter(
            QgsProcessingParameterMatrix (
                self.ASSOC,
                description=self.tr('Value / code association'),
                numberRows=1,
                hasFixedNumberRows=False,
                headers=[self.HEADER_FIELD_VAL,self.HEADER_INT_VAL]))
        self.addParameter(
            QgsProcessingParameterFeatureSink(
                self.OUTPUT,
                self.tr("Output layer")))
                
    def processAlgorithm(self,parameters,context,feedback):
        input = self.parameterAsVectorLayer(parameters,self.INPUT,context)
        feedback.pushDebugInfo("input = " + str(input))
        if input is None:
            raise QgsProcessingException(self.invalidSourceError(parameters, self.INPUT))
        qgsUtils.normalizeEncoding(input)
        fieldname = self.parameterAsString(parameters,self.FIELD,context)
        if not fieldname:
            raise QgsProcessingException("No field given")
        grp_name = self.parameterAsString(parameters,self.GROUP,context)
        assoc = self.parameterAsMatrix(parameters,self.ASSOC,context)
        out_fields = QgsFields()
        orig_field = QgsField("Origin", QVariant.String)
        class_field = QgsField("Class", QVariant.String)
        code_field = QgsField("Code", QVariant.Int)
        out_fields.append(orig_field)
        out_fields.append(class_field)
        out_fields.append(code_field)
        (sink, dest_id) = self.parameterAsSink(
            parameters,
            self.OUTPUT,
            context,
            out_fields,
            input.wkbType(),
            input.sourceCrs()
        )
        if sink is None:
            raise QgsProcessingException(self.invalidSinkError(parameters, self.OUTPUT))
        i = iter(assoc)
        assoc_table = dict(zip(i,i))
        feedback.pushDebugInfo("assoc_table : " + str(assoc_table))
        nb_feats = input.featureCount()
        if nb_feats == 0:
            raise QgsProcessingException("No feature in input layer")
        progress_step = 100.0 / nb_feats
        curr_step = 0
        for f in input.getFeatures():
            field_val = str(f[fieldname])
            if field_val not in assoc_table:
                raise QgsProcessingException("Value '" + str(field_val) + "' does not exist in association")
            new_f = QgsFeature(out_fields)
            new_f["Origin"] = input.sourceName()
            new_f["Class"] = grp_name + "_" + str(field_val)
            try:
                code = int(assoc_table[field_val])
            except ValueError:
                raise QgsProcessingException("Matrix contains non-integer value " + str(assoc_table[field_val]))
            new_f["Code"] = code
            new_f.setGeometry(f.geometry())
            sink.addFeature(new_f)
            curr_step += 1
            feedback.setProgress(int(curr_step * progress_step))
        res = { self.OUTPUT : dest_id }
        return res        
      
class WeightingAlgorithm(WeightingBaseAlgorithm):
    
    INPUT_LAYER = 'INPUT_LAYER'
    WEIGHT_LAYER = 'WEIGHT_LAYER'
    RESAMPLING = 'RESAMPLING'

    def initAlgorithm(self, config=None):
        self.methods = ((self.tr('Nearest neighbour'), 'near'),
                        (self.tr('Bilinear'), 'bilinear'),
                        (self.tr('Cubic'), 'cubic'),
                        (self.tr('Cubic spline'), 'cubicspline'),
                        (self.tr('Lanczos windowed sinc'), 'lanczos'),
                        (self.tr('Average'), 'average'),
                        (self.tr('Mode'), 'mode'),
                        (self.tr('Maximum'), 'max'),
                        (self.tr('Minimum'), 'min'),
                        (self.tr('Median'), 'med'),
                        (self.tr('First quartile'), 'q1'),
                        (self.tr('Third quartile'), 'q3'))
                        
        self.addParameter(
            QgsProcessingParameterRasterLayer(
                self.INPUT_LAYER,
                description=self.tr('Input layer')))
        self.addParameter(
            QgsProcessingParameterRasterLayer(
                self.WEIGHT_LAYER,
                description=self.tr('Weighting layer')))
        self.addParameter(QgsProcessingParameterEnum(self.RESAMPLING,
                                                     self.tr('Resampling method to use'),
                                                     options=[i[0] for i in self.methods],
                                                     optional=True,
                                                     defaultValue=0))
        self.addParameter(
            QgsProcessingParameterRasterDestination(
                self.OUTPUT,
                self.tr("Output layer")))
                
    def prepareParameters(self,parameters,context,feedback):
        input = self.parameterAsRasterLayer(parameters,self.INPUT_LAYER,context)
        if input is None:
            raise QgsProcessingException(self.invalidRasterError(parameters, self.INPUT_LAYER))
        weighting = self.parameterAsRasterLayer(parameters,self.WEIGHT_LAYER,context)
        if weighting is None:
            raise QgsProcessingException(self.invalidRasterError(parameters, self.WEIGHT_LAYER))
        resampling = parameters[self.RESAMPLING]
        output = self.parameterAsOutputLayer(parameters, self.OUTPUT, context)
        return (input, weighting, resampling, output)
        
    def warpWeightingLayer(self,parameters,context,feedback):
        input, weighting, resampling, output = self.prepareParameters(parameters,context,feedback)
        input_dp = input.dataProvider()
        nodata_val = input_dp.sourceNoDataValue(1)
        resolution = input.rasterUnitsPerPixelX()
        crs = input.crs()
        out = QgsProcessingUtils.generateTempFilename('warped.tif')
        warp_params = { 'INPUT' : weighting,
                        'TARGET_CRS' : crs,
                        'RESAMPLING' : resampling,
                        'NODATA' : nodata_val,
                        'TARGET_RESOLUTION' : resolution,
                        'TARGET_EXTENT' : input.extent(),
                        'TARGET_EXTENT_CRS' : crs,
                        'OUTPUT' : out }
        warped = processing.run('gdal:warpreproject',warp_params,context=context,feedback=feedback)
        return warped['OUTPUT']
        
    def warpFromCustomLayer(self,input,resampling,output,context,feedback):
        input_dp = input.dataProvider()
        nodata_val = input_dp.sourceNoDataValue(1)
        resolution = input.rasterUnitsPerPixelX()
        crs = input.crs()
        warp_params = { 'INPUT' : input,
                        'TARGET_CRS' : crs,
                        'RESAMPLING' : resampling,
                        'NODATA' : nodata_val,
                        'TARGET_RESOLUTION' : resolution,
                        'TARGET_EXTENT' : input.extent(),
                        'TARGET_EXTENT_CRS' : crs,
                        'OUTPUT' : output }
        warped = processing.run('gdal:warpreproject',warp_params,context=context,feedback=feedback)
        return warped['OUTPUT']


class WeightingBasics(WeightingAlgorithm):

    ALG_NAME = 'weightingbasics'

    OPERATOR = 'OPERATOR'
        
    def displayName(self):
        return self.tr('Weighting (Basics)')
        
    def shortHelpString(self):
        helpStr = "Weighting of friction layer A by another layer B. Layers must be aligned.\n"
        helpStr += "Available weighting operations :\n"
        helpStr += " * Minimum (pixResult = min(pixA, pixB))\n"
        helpStr += " * Maximum (pixResult = max(pixA, pixB))\n"
        helpStr += " * Multiplication (pixResult = pixA * pixB)"
        return self.tr(helpStr)

    def initAlgorithm(self, config=None):
        self.operators = [ self.tr('Minimum'),
                           self.tr('Maximum'),
                           self.tr('Multiplication') ]
        super().initAlgorithm()
        self.addParameter(QgsProcessingParameterEnum(self.OPERATOR,
                                                     self.tr('Weighting method to use'),
                                                     options=self.operators,
                                                     defaultValue=0))
                                                             
    def processAlgorithm(self,parameters,context,feedback):
        input, weighting, resampling, output = self.prepareParameters(parameters,context,feedback)
        operator = self.parameterAsEnum(parameters,self.OPERATOR,context)
        #output = self.parameterAsOutputLayer(parameters, self.OUTPUT, context)
        warped_path = self.warpWeightingLayer(parameters,context,feedback)
        feedback.pushDebugInfo('warped_path = ' + str(warped_path))
        warped_layer = qgsUtils.loadRasterLayer(warped_path)
        nodata_val = input.dataProvider().sourceNoDataValue(1)
        min, max = qgsUtils.getRastersMinMax([input,weighting])
        range = [min,max]
        layers = [qgsUtils.pathOfLayer(input),qgsUtils.pathOfLayer(weighting)]
        out_path = parameters['OUTPUT']
        feedback.pushDebugInfo('out_path = ' + str(out_path))
        feedback.pushDebugInfo('output = ' + str(output))
        # if os.path.isfile(out_path):
            # qgsUtils.removeRaster(out_path)
        if operator == 0:
            out = qgsTreatments.applyRasterCalcMin(input,warped_layer,output,
                                                   nodata_val=nodata_val,out_type=Qgis.Int32,
                                                   context=context,feedback=feedback)
        elif operator == 1:
            out = qgsTreatments.applyRasterCalcMax(input,warped_layer,output,
                                                   nodata_val=nodata_val,out_type=Qgis.Int32,
                                                   context=context,feedback=feedback)
        elif operator == 2:
            out = qgsTreatments.applyRasterCalcMult(input,warped_layer,output,
                                                    nodata_val=nodata_val,out_type=Qgis.Int32,
                                                    context=context,feedback=feedback)
        else:
            assert(False)
        return { 'OUTPUT' : out }

            
class WeightingIntervalsAlgorithm(WeightingAlgorithm):
    
    INTERVALS = 'INTERVALS'
    RANGE_BOUNDARIES = 'RANGE_BOUNDARIES'
    
    LOW_BOUND = 'LOW_BOUND'
    UP_BOUND = 'UP_BOUND'
    POND_VAL = 'POND_VALUE'
    NODATA_POND_VAL = 'NODATA_POND_VALUE'

    def initAlgorithm(self, config=None):
        self.range_boundaries = [self.tr('min < value <= max'),
                                 self.tr('min <= value < max'),
                                 self.tr('min <= value <= max'),
                                 self.tr('min < value < max')]
        super().initAlgorithm(config)
        self.addParameter(
            QgsProcessingParameterMatrix (
                self.INTERVALS,
                description=self.tr('Intervals'),
                numberRows=1,
                hasFixedNumberRows=False,
                headers=[self.LOW_BOUND,self.UP_BOUND,self.POND_VAL]))
        self.addParameter(QgsProcessingParameterEnum(self.RANGE_BOUNDARIES,
                                                     self.tr('Range boundaries'),
                                                     options=self.range_boundaries,
                                                     optional=True,
                                                     defaultValue=2))
                
   
class WeightingByIntervals(WeightingIntervalsAlgorithm):

    ALG_NAME = 'weightingbyintervals'
        
    def displayName(self):
        return self.tr('Weighting (By intervals)')
        
    def shortHelpString(self):
        helpStr = "Weighting of friction layer A by another layer B. Layers must be aligned.\n"
        helpStr += "Value intervals [lowBound, upBound] and weighting value 'pond_val' are defined for layer B.\n"
        helpStr += "If pixB belongs to [lowBound, upBound] then pixResult = pixA * pond_val."
        return self.tr(helpStr)

    def initAlgorithm(self, config=None):
        super().initAlgorithm(config)
                
    def processAlgorithm(self,parameters,context,feedback):
        input, weighting, resampling, output = self.prepareParameters(parameters,context,feedback)
        range_boundaries = self.parameterAsEnum(parameters,self.RANGE_BOUNDARIES,context)
        # WARP
        warped_layer = self.warpWeightingLayer(parameters,context,feedback)
        # RECLASSIFY
        nodata_val = input.dataProvider().sourceNoDataValue(1)
        out_reclassed = QgsProcessingUtils.generateTempFilename('Reclassed.tif')
        reclass_params = { 'DATA_TYPE' : 5,
                           'INPUT_RASTER' : warped_layer,
                           'NODATA_FOR_MISSING' : True,
                           'NO_DATA' : nodata_val,
                           'OUTPUT' : out_reclassed,
                           'RANGE_BOUNDARIES' : range_boundaries,
                           'RASTER_BAND' : 1,
                           'TABLE' : parameters[self.INTERVALS] }
        reclassed = processing.run('native:reclassifybytable',reclass_params,context=context,feedback=feedback)
        reclassed_layer = reclassed['OUTPUT']
        # WEIGHTING
        weighted = qgsTreatments.applyRasterCalcMult(input,reclassed_layer,output,
                                                     nodata_val=nodata_val,out_type=Qgis.Float32,
                                                     context=context,feedback=feedback)
        return { 'OUTPUT' : weighted }
   
class WeightingByDistance(WeightingIntervalsAlgorithm):

    ALG_NAME = 'weightingbydistance'
        
    def displayName(self):
        return self.tr('Weighting (By distance)')
        
    def shortHelpString(self):
        helpStr = "Weighting of friction layer A by distance to another layer B. Layers must be aligned.\n"
        helpStr += "Distance intervals [lowBound, upBound] and weighting value 'pond_val' are defined for layer B.\n"
        helpStr += "Distance of pixA to layer B is computed as the minimum distance from pixA to a pixel of B that is not NoData"
        helpStr += "If distance(pixA,B) belongs to [lowBound, upBound] then pixResult = pixA * pond_val."
        return self.tr(helpStr)

    def initAlgorithm(self, config=None):
        super().initAlgorithm(config)
                
    def processAlgorithm(self,parameters,context,feedback):
        input, weighting, resampling, output = self.prepareParameters(parameters,context,feedback)
        range_boundaries = self.parameterAsEnum(parameters,self.RANGE_BOUNDARIES,context)
        intervals = self.parameterAsMatrix(parameters,self.INTERVALS,context)
        # WARP
        warped_layer = self.warpWeightingLayer(parameters,context,feedback)
        # BUFFER
        feedback.pushDebugInfo('intervals = ' +str(intervals))
        distances = intervals[1::3]
        feedback.pushDebugInfo('distances = ' +str(distances))
        distances_str = ",".join([str(d) for d in distances])
        feedback.pushDebugInfo('distances_str = ' +str(distances_str))
        out_buffer = QgsProcessingUtils.generateTempFilename('out_buffer.tif')
        buffer_params = { 'input' : warped_layer,
                          'output' : out_buffer,
                          'distances' : distances_str,
                          'units' : 0, # 0 = meters ?
                          'GRASS_RASTER_FORMAT_META' : '',
                          'GRASS_RASTER_FORMAT_OPT' : '',
                          'GRASS_REGION_CELLSIZE_PARAMETER' : 0,
                          'GRASS_REGION_PARAMETER' : None,
                          '-z' : False }
                          #'--type' : 'Int32'
                          #'--overwrite' : False}
        feedback.pushDebugInfo("buffer_params = " + str(buffer_params))
        buffered = processing.run('grass7:r.buffer',buffer_params,context=context,feedback=feedback)
        feedback.pushDebugInfo("buffered = " + str(buffered))
        buffered_layer = buffered['output']
        feedback.pushDebugInfo("buffered_layer = " + str(buffered_layer))
        # RECLASSIFY
        pond_vals = intervals[2::3]
        feedback.pushDebugInfo('pond_vals = ' + str(pond_vals))
        pv1 = pond_vals[0]
        pond_table = [1,1,pv1]
        for idx, pv in enumerate(pond_vals,2):
            pond_table.append(idx)
            pond_table.append(idx)
            pond_table.append(pv)
        feedback.pushDebugInfo('pond_table = ' + str(pond_table))
        nodata_val = input.dataProvider().sourceNoDataValue(1)
        out_reclassed = QgsProcessingUtils.generateTempFilename('Reclassed.tif')
        reclass_params = { 'DATA_TYPE' : 5,
                           'INPUT_RASTER' : buffered_layer,
                           'NODATA_FOR_MISSING' : True,
                           'NO_DATA' : nodata_val,
                           'OUTPUT' : out_reclassed,
                           'RANGE_BOUNDARIES' : range_boundaries,
                           'RASTER_BAND' : 1,
                           'TABLE' : pond_table }
        feedback.pushDebugInfo("reclass_params = " + str(reclass_params))
        reclassed = processing.run('native:reclassifybytable',reclass_params,context=context,feedback=feedback)
        reclassed_layer = reclassed['OUTPUT']
        # NODATA
        reclassed_nonull = QgsProcessingUtils.generateTempFilename('reclassed_nonull.tif')
        nonull = qgsTreatments.applyRNull(reclassed_layer,1,reclassed_nonull,context=context,feedback=feedback)
        # WEIGHTING
        weighted = qgsTreatments.applyRasterCalcMult(input,nonull,output,
                                                     nodata_val=nodata_val,out_type=Qgis.Float32,
                                                     context=context,feedback=feedback)
        return { 'OUTPUT' : weighted }
   
class RasterSelectionByValue(AuxAlgorithm):

    ALG_NAME = 'rasterselectionbyvalue'

    OPERATOR = 'OPERATOR'
    VALUE = 'VALUE'
    
    OPERATORS = ['<','<=','>','>=','==','!=']
    OPERATORS_CMPL = ['>=','>','<=','<','!=','==']
        
    def displayName(self):
        return self.tr('Raster selection by value')
        
    def shortHelpString(self):
        return self.tr('Creates new raster with input raster values veryfing specified operation.')

    def initAlgorithm(self, config=None):
        self.addParameter(
            QgsProcessingParameterRasterLayer(
                self.INPUT,
                description=self.tr('Input layer')))
        self.addParameter(
            QgsProcessingParameterEnum(self.OPERATOR,
                                       self.tr('Operator'),
                                       options=self.OPERATORS,
                                       defaultValue=4))
        self.addParameter(
            QgsProcessingParameterNumber (
                self.VALUE,
                description=self.tr('Value'),
                defaultValue=0.0,
                type=QgsProcessingParameterNumber.Double))
        self.addParameter(
            QgsProcessingParameterRasterDestination(
                self.OUTPUT,
                self.tr("Output layer")))
                
                
    def processAlgorithm(self,parameters,context,feedback):
        input = self.parameterAsRasterLayer(parameters,self.INPUT,context)
        if input is None:
            raise QgsProcessingException(self.invalidRasterError(parameters, self.INPUT))
        operator = self.parameterAsEnum(parameters,self.OPERATOR,context)
        value = self.parameterAsDouble(parameters,self.VALUE,context)
        output = self.parameterAsOutputLayer(parameters, self.OUTPUT, context)
        # Type
        input_type = input.dataProvider().sourceDataType(1)
        # Expression
        input_nodata_val = input.dataProvider().sourceNoDataValue(1)
        operator_str = self.OPERATORS[operator]
        operator_cmpl_str = self.OPERATORS_CMPL[operator]
        value_str = str(value)
        nodata_str = str(input_nodata_val)
        cmp_expr = '(A {} {})'.format(operator_str,value_str)
        cmp_expr_cmpl = '(A {} {})'.format(operator_cmpl_str,value_str)
        expr = "A * " + str(cmp_expr)
        mult_expr = "A * B"
        if math.isnan(input_nodata_val):
            nodata_val = None
        else:
            nodata_val = input_nodata_val
        feedback.pushDebugInfo("nodata_val = " + nodata_str)
        feedback.pushDebugInfo("gdalcalc expr = " + str(expr))
        # Call
        tmp = QgsProcessingUtils.generateTempFilename('tmp.tif')
        out = qgsTreatments.applyRasterCalc(input,tmp,expr,
                                      nodata_val=0,out_type=input_type,
                                      context=context,feedback=feedback)
        out = qgsTreatments.applyRSetNull(tmp,0,output,context,feedback)
        return { 'OUTPUT' : out }
        

class ExtractPatchesR(AuxAlgorithm):

    ALG_NAME = 'extractPatchesR'

    VALUES = 'VALUES'
    SURFACE = 'SURFACE'
        
    def displayName(self):
        return self.tr('Extract patches (Raster)')
        
    def shortHelpString(self):
        s = "Extract patches from land use raster layer according to"
        s += " specified land use types and minimum surface."
        s += "\nLand use values are integer separated by semicolons (';')."
        return self.tr(s)

    def initAlgorithm(self, config=None):
        self.addParameter(
            QgsProcessingParameterRasterLayer(
                self.INPUT,
                description=self.tr('Input layer')))
        self.addParameter(
            QgsProcessingParameterString (
                self.VALUES,
                description=self.tr('Land use values (separated by \';\')')))
        self.addParameter(
            QgsProcessingParameterNumber (
                self.SURFACE,
                description=self.tr('Patch minimum surface (expressed in pixels)'),
                type=QgsProcessingParameterNumber.Double,
                optional=True))
        self.addParameter(
            QgsProcessingParameterRasterDestination(
                self.OUTPUT,
                self.tr("Output layer")))
                
    def getDataType(self,in_type):
        typeAssoc = { Qgis.Byte : 0,
                      Qgis.Int16 : 1,
                      Qgis.UInt16 : 2,
                      Qgis.UInt32 : 3,
                      Qgis.Int32 : 4,
                      Qgis.Float32 : 5,
                      Qgis.Float64 : 6 }
        if in_type in typeAssoc:
            return typeAssoc[in_type]
            #return 5
        else:
            return 5
                
    def processAlgorithm(self,parameters,context,feedback):
        input = self.parameterAsRasterLayer(parameters,self.INPUT,context)
        if input is None:
            raise QgsProcessingException(self.invalidRasterError(parameters, self.INPUT))
        values = self.parameterAsInts(parameters,self.VALUES,context)
        surface = self.parameterAsDouble(parameters,self.SURFACE,context)
        feedback.pushDebugInfo("values = " + str(values))
        nb_vals = len(values)
        if nb_vals == 0:
            raise QgsProcessingException("No land use values specified (check string format)")
        output = self.parameterAsOutputLayer(parameters, self.OUTPUT, context)
        # Expression
        input_nodata_val = input.dataProvider().sourceNoDataValue(1)
        if nb_vals == 1:
            expr_str = 'A == {}'.format(values[0])
        else:
            expr_str = ''
            for v in values[:-1]:
                expr_str += 'logical_or(A == {},'.format(v)
            expr_str += 'A == {}'.format(values[-1])
            expr_str += ")" * (nb_vals - 1)
        feedback.pushDebugInfo("raster calc expr = " + expr_str)
        # Raster calc
        selection_path = QgsProcessingUtils.generateTempFilename('landuse_selection.tif')
        out_calc = selection_path if surface else output
        qgsTreatments.applyRasterCalc(input,out_calc,expr_str,
                                      nodata_val=0,out_type=0,
                                      context=context,feedback=feedback)
        # Labelling
        if surface:
            if not (import_scipy_ok and import_numpy_ok):
                raise QgsProcessingException("Import of numpy/scipy failed, please install these libraries from OSGEO installer")
            selection = qgsUtils.loadRasterLayer(selection_path)
            classes, array = qgsUtils.getRasterValsAndArray(selection_path)
            struct = ndimage.generate_binary_structure(2,1)
            labeled_array, nb_patches = ndimage.label(array,struct)
            medians = ndimage.sum(array,labeled_array,range(1,nb_patches+1))
            # x_res = selection.rasterUnitsPerPixelX()
            # y_res = selection.rasterUnitsPerPixelY()
            indices = np.where(medians > surface)[0] + 1
            new_array = np.zeros(labeled_array.shape)
            for i in indices:
                new_array[labeled_array == i] = 1
            qgsUtils.exportRaster(new_array,selection.source(),output,nodata=0,type=1)
        # return
        return { 'OUTPUT' : output }
        
    
class RasterizeFixAllTouch(AuxAlgorithm,rasterize):

    ALG_NAME = 'rasterizefixalltouch'
        
    def displayName(self):
        return self.tr('Rasterize (with ALL_TOUCH fix)')
        
    #def group(self):
    #    return "Auxiliary algorithms"
        
    #def groupId(self):
    #    return 'aux'
        
    def shortHelpString(self):
        return self.tr('Wrapper for gdal:rasterize algorithm allowing to use ALL_TOUCH option (every pixel touching input geometry are rasterized).')

    def initAlgorithm(self, config=None):
        super().initAlgorithm(config)
        self.addParameter(
            QgsProcessingParameterBoolean(
                self.ALL_TOUCH,
                description = 'ALL_TOUCH option',
                defaultValue=False,
                optional=True))
    
# Apply rasterization on field 'field' of vector layer 'in_path'.
# Output raster layer in 'out_path'.
# Resolution set to 25 if not given.
# Extent can be given through 'extent_path'. If not, it is extracted from input layer.
# Output raster layer is loaded in QGIS if 'load_flag' is True.
def applyRasterizationFixAllTouch(in_path,out_path,extent,resolution,
                   field=None,burn_val=None,out_type=Qgis.Float32,
                   nodata_val=qgsTreatments.nodata_val,all_touch=False,overwrite=False,
                   context=None,feedback=None):
    #TYPES = ['Byte', 'Int16', 'UInt16', 'UInt32', 'Int32', 'Float32', 'Float64', 'CInt16', 'CInt32', 'CFloat32', 'CFloat64']
    out_type = qgsTreatments.qgsTypeToInt(out_type,shift=True)
    if overwrite:
        qgsUtils.removeRaster(out_path)
    extra_param_name = 'EXTRA'
    if hasattr(rasterize,extra_param_name):
        res = qgsTreatments.applyRasterization(in_path,out_path,extent,resolution,
                field,burn_val,out_type,nodata_val,all_touch,overwrite,
                context,feedback)
    else:
        parameters = { 'ALL_TOUCH' : True,
                   'BURN' : burn_val,
                   'DATA_TYPE' : out_type,
                   'EXTENT' : extent,
                   'FIELD' : field,
                   'HEIGHT' : resolution,
                   'INPUT' : in_path,
                   'NODATA' : nodata_val,
                   'OUTPUT' : out_path,
                   'UNITS' : 1, 
                   'WIDTH' : resolution }
        res = qgsTreatments.applyProcessingAlg("BioDispersal",
            "rasterizefixalltouch",parameters,context,feedback)
    return res
    
    
class ChangeNoDataVal(AuxAlgorithm):

    ALG_NAME = 'changenodata'
    
    NODATA_VAL = 'NODATA_VAL'
        
    def displayName(self):
        return self.tr('Change NoData value')
        
    def shortHelpString(self):
        return self.tr('Change NoData value and reclassifies old NoData pixels to new NoData value.')

    def initAlgorithm(self, config=None):
        self.addParameter(
            QgsProcessingParameterRasterLayer(
                self.INPUT,
                description=self.tr('Input layer')))
        self.addParameter(
            QgsProcessingParameterNumber (
                self.NODATA_VAL,
                description=self.tr('New NoData value'),
                type=QgsProcessingParameterNumber.Double))
        self.addParameter(
            QgsProcessingParameterRasterDestination(
                self.OUTPUT,
                self.tr("Output layer")))
                
    def processAlgorithm(self,parameters,context,feedback):
        input = self.parameterAsRasterLayer(parameters,self.INPUT,context)
        if input is None:
            raise QgsProcessingException(self.invalidRasterError(parameters, self.INPUT))
        new_val = self.parameterAsDouble(parameters,self.NODATA_VAL,context)
        output = self.parameterAsOutputLayer(parameters, self.OUTPUT, context)
        input_nodata_val = input.dataProvider().sourceNoDataValue(1)
        feedback.pushDebugInfo("Input NoData value = " + str(input_nodata_val))
        #input_vals = qgsUtils.getRasterValsBis(input)
        input_vals = qgsTreatments.getRasterUniqueVals(input,feedback)
        feedback.pushDebugInfo("Input values = " + str(input_vals))
        if input_vals == []:
            feedback.pushInfo("Empty input layer (no input values)")
        if new_val in input_vals:
            raise QgsProcessingException("Input layer contains pixels with new NoData value '"
                    + str(new_val) + "'.")
        tmp = QgsProcessingUtils.generateTempFilename('tmp.tif')
        qgsTreatments.applyRNull(input,new_val,tmp,context,feedback)
        qgsTreatments.applyRSetNull(tmp,new_val,output,context,feedback)
        return { 'OUTPUT' : output }
    
    
class ExportToGraphab(GraphabAlgorithm):

    ALG_NAME = 'exporttographab'
        
    def name(self):
        return self.ALG_NAME
        
    def displayName(self):
        return self.tr('Export to Graphab')
        
    def shortHelpString(self):
        return self.tr('Ensures that friction layer is compatible with Graphab.')

    def initAlgorithm(self, config=None):
        self.addParameter(
            QgsProcessingParameterRasterLayer(
                self.INPUT,
                description=self.tr('Input layer (friction)')))
        self.addParameter(
            QgsProcessingParameterRasterDestination(
                self.OUTPUT,
                self.tr("Exported layer (friction)")))
                
    def processAlgorithm(self,parameters,context,feedback):
        input = self.parameterAsRasterLayer(parameters,self.INPUT,context)
        if input is None:
            raise QgsProcessingException(self.invalidRasterError(parameters, self.INPUT))
        output = self.parameterAsOutputLayer(parameters, self.OUTPUT, context)
        input_nodata_val = input.dataProvider().sourceNoDataValue(1)
        feedback.pushDebugInfo("Input NoData value = " + str(input_nodata_val))
        #input_vals = qgsUtils.getRasterValsBis(input)
        input_vals = qgsTreatments.getRasterUniqueVals(input,feedback)
        feedback.pushDebugInfo("Input values = " + str(input_vals))
        if input_vals == []:
            raise QgsProcessingException("Empty input layer (no input values)")
        for v in input_vals:
            if v <= 0:
                raise QgsProcessingException("Input layer contains value '"
                        + str(v) + "', but Graphab expects strictly positive (> 0) values")
                
        if input_nodata_val == 0 and 0 in input_vals:
            raise QgsProcessingException("Input layer contains value 0, but 0 represents NoData in Graphab")
        tmp = QgsProcessingUtils.generateTempFilename('tmp.tif')
        qgsTreatments.applyRNull(input,0,tmp,context,feedback)
        qgsTreatments.applyRSetNull(tmp,0,output,context,feedback)
        return {'OUTPUT' : output }
    
    
class ASCIIOutput(QgsProcessingParameterRasterDestination):
    def __init__(self, name, description):
        super().__init__(name, description)
    def defaultFileExtension(self):
        return 'asc'
    def supportedOutputRasterLayerExtensions(self):
        return ['asc']
    
    
class ExportPatchesToCircuitscape(CircuitscapeAlgorithm):

    ALG_NAME = 'exportpatchestocircuitscape'
    
    CLASS = 'CLASS'
        
    def displayName(self):
        return self.tr('Export to Circuitscape (start points)')
        
    def shortHelpString(self):
        return self.tr('Export patch layer (focal nodes, biodiversity reservois, ...) to Circuitscape')

    def initAlgorithm(self, config=None):
        self.addParameter(
            QgsProcessingParameterRasterLayer(
                self.INPUT,
                description=self.tr('Input patch layer')))
        self.addParameter(QgsProcessingParameterNumber(
            self.CLASS, "Choose Landscape Class", type=QgsProcessingParameterNumber.Integer,
            defaultValue=None,optional=True))
        self.addParameter(
            ASCIIOutput(
                self.OUTPUT,
                self.tr("Exported layer (start points)")))
                
    def processAlgorithm(self,parameters,context,feedback):
        if not import_scipy_ok:
            msg = "Scipy (python library) import failed. You can install it through OSGEO installer"
            raise QgsProcessingException(msg)
    
        input = self.parameterAsRasterLayer(parameters,self.INPUT,context)
        if input is None:
            raise QgsProcessingException(self.invalidRasterError(parameters, self.INPUT))
        cl = self.parameterAsInt(parameters, self.CLASS, context)
        cl_param = parameters[self.CLASS]
        output = self.parameterAsOutputLayer(parameters, self.OUTPUT, context)
                
        input_filename = input.source()
        input_nodata_val = input.dataProvider().sourceNoDataValue(1)
        feedback.pushDebugInfo("Input NoData value = " + str(input_nodata_val))
        if input_nodata_val == 1:
            raise QgsProcessingException("Input NoData value cannot be equal to 1.")
        input_type = input.dataProvider().dataType(1)
        feedback.pushDebugInfo("Input type = " + str(input_type))
        # if 0 in input_vals:
            # raise QgsProcessingException("Input layer contains 0 value")
        feedback.pushDebugInfo("output = " + str(output))
        output_basename, ext = os.path.splitext(output)
        output_tif = output_basename + ".tif"
                
        classes, array = qgsUtils.getRasterValsAndArray(str(input_filename))
        new_array = np.copy(array)
        feedback.pushDebugInfo("class = " + str(cl) + ", " + str(parameters[self.CLASS]))
        feedback.pushDebugInfo("array = " + str(array[0][0]))
        feedback.pushDebugInfo("new_array = " + str(new_array[0][0]))
        if cl_param is None:
            new_array[array!=input_nodata_val] = 1
            new_array[array==input_nodata_val] = 0
            new_array[array!=array] = 0
        elif cl not in classes:
            raise QgsProcessingException("No pixel found with class value " + str(cl))
        else:
            new_array[new_array!=cl] = 0
            new_array[array==cl] = 1
        struct = scipy.ndimage.generate_binary_structure(2,2)
        labeled_array, nb_patches = scipy.ndimage.label(new_array,struct)
        labeled_array[labeled_array==0] = input_nodata_val
        
        qgsUtils.exportRaster(labeled_array,input_filename,output_tif,
            nodata=input_nodata_val,type=input_type)
        out = qgsTreatments.applyTranslate(output_tif,output,data_type=input_type,
            nodata_val=input_nodata_val,context=context,feedback=feedback)
        # Data type coule be problematic if input layer has small type 
        # (suchs as Byte but BioDispersal exports Float32) and lot of patches.
        return {'OUTPUT' : out }
      
      
class ExportFrictionToCircuitscape(CircuitscapeAlgorithm):

    ALG_NAME = 'exportfrictiontocircuitscape'
        
    def displayName(self):
        return self.tr('Export to Circuitscape (friction layer)')
        
    def shortHelpString(self):
        return self.tr('Export friction (resistance) layer to Circuitscape, converting existing layer to ASCII format.')

    def initAlgorithm(self, config=None):
        self.addParameter(
            QgsProcessingParameterRasterLayer(
                self.INPUT,
                description=self.tr('Input resistance layer')))
        self.addParameter(
            ASCIIOutput(
                self.OUTPUT,
                self.tr("Exported layer (resistance)")))
                
    def processAlgorithm(self,parameters,context,feedback):    
        input = self.parameterAsRasterLayer(parameters,self.INPUT,context)
        if input is None:
            raise QgsProcessingException(self.invalidRasterError(parameters, self.INPUT))
        output = self.parameterAsOutputLayer(parameters, self.OUTPUT, context)        
                
        if output is None:
            raise QgsProcessingException("Empty output layer")
        base, ext = os.path.splitext(output)
        if ext != '.asc':
            raise QgsProcessingException("Invalid extension for output ASCII file : " + str(output))
        input_filename = input.source()
        input_nodata_val = input.dataProvider().sourceNoDataValue(1)
        feedback.pushDebugInfo("Input NoData value = " + str(input_nodata_val))
        if input_nodata_val == 1:
            raise QgsProcessingException("Input NoData value cannot be equal to 1.")
            
        input_type = input.dataProvider().dataType(1)
        out = qgsTreatments.applyTranslate(input_filename,output,data_type=input_type,
            nodata_val=input_nodata_val,context=context,feedback=feedback)
        return {'OUTPUT' : output }
        
        
class RandomStartPointsCircuitscape(CircuitscapeAlgorithm):

    ALG_NAME = 'randomStartPointsCircuitscape'
    
    def displayName(self):
        return self.tr('Random start points (Circuitscape)')
        
    def shortHelpString(self):
        return self.tr('Generates random start points layer for circuitscape input')
        
    PATCH_LAYER = 'PATCH_LAYER'
    NB_POINTS = 'NB_POINTS'
    NB_LAUNCHES = 'NB_LAUNCHES'
    DEFAULT_NB_LAUNCHES = 1
    RESISTANCE_LAYER = 'RESISTANCE_LAYER'
    # OUTPUT_DIR = 'OUTPUT_DIR'
    OUTPUT = 'OUTPUT'

    POINTS_VECTOR = 'POINTS_VECTOR'

    def initAlgorithm(self,config=None):
        self.addParameter(
            QgsProcessingParameterFeatureSource(
                self.PATCH_LAYER,
                description=self.tr('Patch layer')))
        self.addParameter(
            QgsProcessingParameterRasterLayer(
                self.RESISTANCE_LAYER,
                description=self.tr('Resistance layer')))
        self.addParameter(
            QgsProcessingParameterNumber (
                self.NB_POINTS,
                description=self.tr('Number of points'),
                type=QgsProcessingParameterNumber.Integer))
        self.addParameter(
            QgsProcessingParameterNumber (
                self.NB_LAUNCHES,
                description=self.tr('Number of launches'),
                type=QgsProcessingParameterNumber.Integer,
                defaultValue=self.DEFAULT_NB_LAUNCHES))
        self.addParameter(
            QgsProcessingParameterFolderDestination (
                self.OUTPUT,
                description=self.tr('Output directory')))
        
        
    def processAlgorithm(self,parameters,context,feedback):
        # Parameters
        patch_source, patch_layer = qgsTreatments.parameterAsSourceLayer(
            self,parameters,self.PATCH_LAYER,context,feedback=feedback)
        resistance_layer = self.parameterAsRasterLayer(parameters,self.RESISTANCE_LAYER,context)
        nb_points = self.parameterAsInt(parameters, self.NB_POINTS, context)
        nb_launches = self.parameterAsInt(parameters, self.NB_LAUNCHES, context)
        out_dir = self.parameterAsFileOutput(parameters,self.OUTPUT,context)
        resistance_path = qgsUtils.pathOfLayer(resistance_layer)
        # Init input / output
        utils.mkDir(out_dir)
        dirname = os.path.dirname(__file__)
        base_config_file = os.path.join(dirname,"baseConfig.ini")
        fin = open(base_config_file,"rt")
        config_content = fin.read()
        fin.close()
        # Resistance translation
        EPT = ExportFrictionToCircuitscape
        out_resistance = os.path.join(out_dir,'resistance.asc')
        parameters = { EPT.INPUT : resistance_layer , EPT.OUTPUT : out_resistance } 
        qgsTreatments.applyProcessingAlg('BioDispersal',EPT.ALG_NAME,
            parameters,context=context,feedback=feedback)
        # Loop
        step_feedback = feedbacks.ProgressMultiStepFeedback(nb_launches*4,feedback)
        outfiles = []
        for i in range(nb_launches):
            bname = "launch" + str(i)
            basepath = os.path.join(out_dir,bname)
            # Sort random points from patch layer
            points_vector = basepath + "_start.gpkg"
            qgsTreatments.applyVRandom(patch_layer,nb_points,points_vector,
                context=context,feedback=step_feedback)
            #qgsUtils.loadVectorLayer(points_vector,loadProject=True)
            step_feedback.setCurrentStep(4*i+1)
            # Rasterize points layer
            extent = resistance_layer.extent()
            resolution = resistance_layer.rasterUnitsPerPixelX()
            #points_tif = QgsProcessingUtils.generateTempFilename('points_raster.tif')
            points_tif = basepath + "_start.tif"
            qgsUtils.removeRaster(points_tif)
            qgsTreatments.applyRasterization(points_vector,points_tif,extent,resolution,
                field='cat',out_type=Qgis.Int16,nodata_val=-9999,
                context=context,feedback=step_feedback)
            #qgsUtils.loadRasterLayer(points_tif,loadProject=True)
            step_feedback.setCurrentStep(4*i+2)
            # Convert to asc
            #points_asc = QgsProcessingUtils.generateTempFilename('points_raster.asc')
            points_asc = basepath + "_start.asc"
            qgsUtils.removeRaster(points_asc)
            qgsTreatments.applyTranslate(points_tif,points_asc,
                nodata_val=0,context=context,feedback=step_feedback)
            #qgsUtils.loadRasterLayer(points_asc,loadProject=True)
            step_feedback.setCurrentStep(4*i+3)
            # Out config file
            out_content = config_content.replace('OUTPUT_DIR',out_dir)
            out_content = out_content.replace('OUTPUT_BNAME',bname)
            out_content = out_content.replace('START_LAYER',points_asc)
            out_content = out_content.replace('RESISTANCE_LAYER',out_resistance)
            outfile = basepath + "_config.ini"
            with open(outfile,"wt") as fout:
                fout.write(out_content)
            outfiles.append(outfile)
            step_feedback.setCurrentStep(4*i+4)
        # Output Julia script
        outscript = os.path.join(out_dir,"launchCircuitscape.jl")
        outscript = utils.normPath(outscript)
        script_text = "#include(\"" + outscript +"\")\n"
        script_text += "using Circuitscape\n"
        for outfile in outfiles:
            # f_posix = str(Path(outfile))
            # f_posix = f_posix.replace("\\","/")
            f_posix = utils.normPath(outfile)
            script_text += "compute(\"" + f_posix + "\")\n"
        utils.removeFile(outscript)
        with open(outscript,"w+") as fout:
            fout.write(script_text)
        os.chmod(outscript,0o7242)
        #os.chmod(outscript,stat.S_IXUSR)
        return { self.OUTPUT : out_dir }
        
        
class AggregateCirctuitscapeCurrentMaps(CircuitscapeAlgorithm):

    ALG_NAME = 'aggrCurrMapsLayers'
    
    def displayName(self):
        return self.tr('Aggregates current maps')
        
    def shortHelpString(self):
        return self.tr('Aggregates current maps (Circuitscape output) into one cumulative current map')
        
    INPUT_LAYERS = 'INPUT_LAYERS'

    def initAlgorithm(self,config=None):
        self.addParameter(
            QgsProcessingParameterMultipleLayers(
                self.INPUT_LAYERS,
                description=self.tr('Input layers'),
                layerType=QgsProcessing.TypeRaster))
        self.addParameter(
            QgsProcessingParameterRasterDestination(
                self.OUTPUT,
                self.tr("Output layer")))
                
    # def createFileFilter(self):
        # return "*.asc"
                
    def processAlgorithm(self,parameters,context,feedback):
        # Parameters
        input_layers = self.parameterAsLayerList(parameters,self.INPUT_LAYERS,context)
        output = self.parameterAsOutputLayer(parameters, self.OUTPUT, context)
        # Serie
        aggregate = QgsProcessingUtils.generateTempFilename('aggregate.tif')
        qgsTreatments.applyRSeries(input_layers,aggr_func=0,output=aggregate,
            context=context,feedback=feedback)
        # Set null
        qgsTreatments.applyRSetNull(aggregate,0,output,context=context,feedback=feedback)
        # Set style
        # self.output = output
        # self.out_layer = qgsUtils.loadRasterLayer(output)
        return { self.OUTPUT : output }

    # def postProcessAlgorithm(self, context, feedback):
        # out_layer = self.out_layer#qgsUtils.loadRasterLayer(output)
        # color_ramp = styles.mkColorRamp('Plasma')
        # shader = styles.mkRasterShader(out_layer,color_ramp)
        # styles.setSBPCRasterRenderer(out_layer,shader)
        # out_layer.triggerRepaint()
        # return { self.OUTPUT : self.out_layer }
        
        
class AggregateCirctuitscapeResults(CircuitscapeAlgorithm):

    ALG_NAME = 'aggrCircuitscapeResults'
    
    def displayName(self):
        return self.tr('Aggregates Circuitscape results')
        
    def shortHelpString(self):
        return self.tr('Aggregates Circuitscape results (start points and current maps) from directory')
        
    RESULTS_DIR = 'RESULTS_DIR'
    AGGR_CURR = 'AGGR_CURR'
    AGGR_START = 'AGGR_START'

    def initAlgorithm(self,config=None):
        self.addParameter(
            QgsProcessingParameterFile(
                self.RESULTS_DIR,
                description=self.tr('Results directory'),
                behavior=QgsProcessingParameterFile.Folder))
        self.addParameter(
            QgsProcessingParameterRasterDestination(
                self.AGGR_CURR,
                self.tr("Aggregate current map")))
        self.addParameter(
            QgsProcessingParameterVectorDestination(
                self.AGGR_START,
                self.tr("Aggregate start points")))
                
    def processAlgorithm(self,parameters,context,feedback):
        # Parameters
        input_dir = self.parameterAsFile(parameters,self.RESULTS_DIR,context)
        aggr_curr = self.parameterAsOutputLayer(parameters, self.AGGR_CURR, context)
        aggr_start = self.parameterAsOutputLayer(parameters, self.AGGR_START, context)
        # Retrieve files
        files = os.listdir(input_dir)
        curr_maps = [os.path.join(input_dir,f) for f in files if f.endswith("_cum_curmap.asc")]
        start_layers = [os.path.join(input_dir,f) for f in files if f.endswith("_start.gpkg")]
        nb_curr_maps, nb_start_layers = len(curr_maps), len(start_layers)
        if nb_curr_maps != nb_start_layers:
            raise QgsProcessingException("Inconsistent number of maps : "
                + str(nb_curr_maps) + " current maps vs "
                + str(nb_start_layers) + " start points layers")
        if nb_curr_maps == 0:
            raise QgsProcessingException("No layers found in " + str(input_dir))
        # Aggregate current
        ACC = AggregateCirctuitscapeCurrentMaps
        parameters = { ACC.INPUT_LAYERS : curr_maps, ACC.OUTPUT : aggr_curr} 
        qgsTreatments.applyProcessingAlg('BioDispersal',ACC.ALG_NAME,parameters,
            context=context,feedback=feedback)
        # Aggregate start points
        layer = qgsUtils.loadVectorLayer(start_layers[0])
        crs = layer.crs()
        qgsTreatments.mergeVectorLayers(start_layers,crs,aggr_start,
            context=context,feedback=feedback)
        # Return
        return { self.AGGR_CURR : aggr_curr, self.AGGR_START : aggr_start }
    
        

class DistanceToBorderVector(PatchAlgorithm):

    ALG_NAME = 'distanceToBorderVector'
    
    EXTENT = 'EXTENT'
    RESOLUTION = 'RESOLUTION'
    
    def displayName(self):
        return self.tr("Distance to borders (vector)")
        
    def shortHelpString(self):
        return self.tr("Distance to border")
        
    def initAlgorithm(self, config=None, report_opt=True):
        self.addParameter(QgsProcessingParameterMapLayer(
            self.INPUT,
            "Input landuse layer",
            types=[Qgis.Polygon]))
        self.addParameter(QgsProcessingParameterExtent(
            self.EXTENT,
            "Output extent"))
        self.addParameter(QgsProcessingParameterNumber(
            self.RESOLUTION,
            "Output resolution",
            defaultValue=10.0,
            type=QgsProcessingParameterNumber.Double))
        self.addParameter(QgsProcessingParameterRasterDestination(
            self.OUTPUT,
            self.tr("Output layer")))
            
    def processAlgorithm(self,parameters,context,feedback):
        input = self.parameterAsMapLayer(parameters,self.INPUT,context)
        if input is None:
            raise QgsProcessingException(self.invalidRasterError(parameters, self.INPUT))
        extent = self.parameterAsExtent(parameters,self.EXTENT,context)
        resolution = self.parameterAsDouble(parameters,self.RESOLUTION,context)
        output = self.parameterAsOutputLayer(parameters, self.OUTPUT, context)
        # Processing
        border_path = self.mkTmpPath('borders.gpkg')
        # type = 2 <=> LineString
        qgsTreatments.convertGeomType(input,2,border_path,context,feedback)
        border_raster_path = self.mkTmpPath('borders.tif')
        qgsTreatments.applyRasterization(border_path,border_raster_path,
            extent,resolution,burn_val=1,out_type=Qgis.Byte,
            context=context,feedback=feedback)

   

class DistanceToBorderRaster(PatchAlgorithm):

    ALG_NAME = 'distanceToBorderRaster'
    
    def displayName(self):
        return self.tr("Distance to borders (Raster)")
        
    def shortHelpString(self):
        return self.tr("Distance for each pixel to patch border.")
        
    def initAlgorithm(self, config=None, report_opt=True):
        self.addParameter(QgsProcessingParameterRasterLayer(
            self.INPUT,
            "Input landuse layer"))
        self.addParameter(QgsProcessingParameterRasterDestination(
            self.OUTPUT,
            self.tr("Output layer")))
            
    def processAlgorithm(self,parameters,context,feedback):
        input = self.parameterAsRasterLayer(parameters,self.INPUT,context)
        if input is None:
            raise QgsProcessingException(self.invalidRasterError(parameters, self.INPUT))
        output = self.parameterAsOutputLayer(parameters, self.OUTPUT, context)
        # Processing
        extent = input.extent()
        input_nodata = input.dataProvider().sourceNoDataValue(1)
        unique_vals = qgsTreatments.getRasterUniqueVals(input,feedback)
        nb_vals = len(unique_vals)
        mf = QgsProcessingMultiStepFeedback(nb_vals * 2 + 2, feedback)
        prox_layers = []
        mf.pushDebugInfo("classes = " + str(unique_vals))
        for count, v in enumerate(unique_vals,start=0):
            classes = list(unique_vals)
            classes.remove(v)
            mf.pushDebugInfo("classes = " + str(classes))
            classes_str = ",".join([str(c) for c in classes])
            mf.pushDebugInfo("classes_str = " + str(classes_str))
            prox_v_path = self.mkTmpPath("proximity_" + str(v) + ".tif")
            qgsTreatments.applyProximity(input,prox_v_path,classes=classes_str,context=context,feedback=mf)
            mf.setCurrentStep(count * 2 + 1)
            prox_vnull_path = self.mkTmpPath("proximity_" + str(v) + "_null.tif")
            # expr_v = "logical_and(A != " + str(v) + ", A != " + str(input_nodata) + ") * B"
            # qgsTreatments.applyRasterCalcAB(input,prox_v_path,prox_vnull_path,expr_v,
                # nodata_val=0,context=context,feedback=mf)
            extract_params = { RasterSelectionByValue.INPUT : prox_v_path,
                RasterSelectionByValue.OPERATOR : 2,
                RasterSelectionByValue.VALUE : 0,
                RasterSelectionByValue.OUTPUT : prox_vnull_path
            }
            processing.run("BioDispersal:" + RasterSelectionByValue.ALG_NAME,
                extract_params,context=context,feedback=mf)
            prox_layers.append(prox_vnull_path)
            # qgsUtils.removeRaster(prox_v_path)
            mf.setCurrentStep(count * 2 + 2)
        min_prox_path = self.mkTmpPath("min_prox.tif")
        qgsTreatments.applyRSeries(prox_layers,4,min_prox_path,
            context=context,feedback=mf)
        mf.setCurrentStep(nb_vals+1)
        expr = "((A != " + str(input_nodata) + ") * B)"
        qgsTreatments.applyRasterCalcAB(input,min_prox_path,output,expr,
            nodata_val=0,context=context,feedback=mf)
        mf.setCurrentStep(nb_vals+2)
        return { self.OUTPUT : output }
        
        
   

class LabelPatches(PatchAlgorithm):

    ALG_NAME = 'labelPatches'
    
    def displayName(self):
        return self.tr("Label patches")
        
    def shortHelpString(self):
        return self.tr("Patch labelling")
        
    def initAlgorithm(self, config=None, report_opt=True):
        self.addParameter(QgsProcessingParameterRasterLayer(
            self.INPUT,
            "Input layer"))
        self.addParameter(QgsProcessingParameterRasterDestination(
            self.OUTPUT,
            self.tr("Output layer")))
            
    def processAlgorithm(self,parameters,context,feedback):
        input = self.parameterAsRasterLayer(parameters,self.INPUT,context)
        if input is None:
            raise QgsProcessingException(self.invalidRasterError(parameters, self.INPUT))
        input_path = qgsUtils.pathOfLayer(input)
        output = self.parameterAsOutputLayer(parameters, self.OUTPUT, context)
        # Processing
        classes, array = qgsUtils.getRasterValsAndArray(input_path)
        mf = QgsProcessingMultiStepFeedback(len(classes), feedback)
        struct = scipy.ndimage.generate_binary_structure(2,1)
        res_array = np.zeros(array.shape)
        class_array = np.copy(array)
        prev_nb_patches = 0
        for count, c in enumerate(classes,start=1):
            # mf.pushDebugInfo("Labelling class " + str(c))
            class_array[array==c] = 1
            class_array[array!=c] = 0
            labeled_array, nb_patches = ndimage.label(class_array,struct)
            mf.pushDebugInfo("labeled_array = " + str(labeled_array))
            labeled_array[array==c] += prev_nb_patches
            mf.pushDebugInfo("labeled_array = " + str(labeled_array))
            tmp_path = self.mkTmpPath("labeled_" + str(c) + ".tif")
            # qgsUtils.exportRaster(res_array,input_path,tmp_path)
            res_array = np.add(res_array,labeled_array)
            mf.pushDebugInfo("res_array = " + str(res_array))
            prev_nb_patches += nb_patches
            mf.setCurrentStep(count)
        qgsUtils.exportRaster(res_array,input_path,output,nodata=0,type=gdal.GDT_UInt16)
        return {self.OUTPUT : output}
    

class PatchSizeRaster(PatchAlgorithm):

    ALG_NAME = 'patchSizeRaster'
    LABELLED = 'LABELLED'
    
    def displayName(self):
        return self.tr("Patch size")
        
    def shortHelpString(self):
        return self.tr("Computes patch size (pixel value = pixel patch size)")
        
    def initAlgorithm(self, config=None, report_opt=True):
        self.addParameter(QgsProcessingParameterRasterLayer(
            self.INPUT,
            "Input layer"))
        self.addParameter(
            QgsProcessingParameterBoolean(
                self.LABELLED,
                description = 'Input is already labelled',
                defaultValue=False,
                optional=True))
        self.addParameter(QgsProcessingParameterRasterDestination(
            self.OUTPUT,
            self.tr("Output layer")))
            
    def processAlgorithm(self,parameters,context,feedback):
        input = self.parameterAsRasterLayer(parameters,self.INPUT,context)
        if input is None:
            raise QgsProcessingException(self.invalidRasterError(parameters, self.INPUT))
        input_path = qgsUtils.pathOfLayer(input)
        is_labelled = self.parameterAsBool(parameters,self.LABELLED,context)
        output = self.parameterAsOutputLayer(parameters, self.OUTPUT, context)
        # Processing
        if is_labelled:
            labelled_path = input_path
        else:
            labelled_path = self.mkTmpPath("labelled.tif")
            label_params = { LabelPatches.INPUT : input,
                LabelPatches.OUTPUT : labelled_path }
            processing.run("BioDispersal:" + LabelPatches.ALG_NAME,
                label_params,context=context,feedback=feedback)
        classes, array = qgsUtils.getRasterValsAndArray(labelled_path)
        mf = QgsProcessingMultiStepFeedback(len(classes), feedback)
        res_array = np.zeros(array.shape)
        for count, c in enumerate(classes,start=1):
            mf.pushDebugInfo("Labelling class " + str(c))
            nb_pix = np.count_nonzero(array == c)
            res_array[array==c] = nb_pix
            mf.setCurrentStep(count)
        qgsUtils.exportRaster(res_array,input_path,output,nodata=0,type=gdal.GDT_UInt32)
        return {self.OUTPUT : output}
        

class NeighboursCount(PatchAlgorithm):

    ALG_NAME = 'neigboursCount'
    
    def displayName(self):
        return self.tr("Neigbours count")
        
    def shortHelpString(self):
        return self.tr("Computes for each pixel the number of immediate neighbours of same value")
    
    def initAlgorithm(self, config=None, report_opt=True):
        self.addParameter(QgsProcessingParameterRasterLayer(
            self.INPUT,
            "Input layer"))
        self.addParameter(QgsProcessingParameterRasterDestination(
            self.OUTPUT,
            self.tr("Output layer")))
            
    def processAlgorithm(self,parameters,context,feedback):
        input = self.parameterAsRasterLayer(parameters,self.INPUT,context)
        if input is None:
            raise QgsProcessingException(self.invalidRasterError(parameters, self.INPUT))
        output = self.parameterAsOutputLayer(parameters, self.OUTPUT, context)
        # Processing
        in_path = qgsUtils.pathOfLayer(input)
        in_nodata = input.dataProvider().sourceNoDataValue(1)
        classes, array = qgsUtils.getRasterValsAndArray(in_path)
        struct = ndimage.generate_binary_structure(2,1)
        nb_neighbours_arr = ndimage.generic_filter(array,
            self.countNeighbours,footprint=struct, mode="constant",cval=in_nodata)
        qgsUtils.exportRaster(nb_neighbours_arr,input.source(),output)
        return {self.OUTPUT : output}
            
    def countNeighbours(self,array):
        cell_val = array[2]
        return np.count_nonzero(array == cell_val) - 1


class SlidingWindowCircle(PatchAlgorithm):
    
    WINDOW_SIZE = 'WINDOW_SIZE'
    # METHOD = "METHOD"
    # METHODsel = ["mean", "sum","minimum","maximum","standard deviation","variance","median","variety"]
    MODE = "MODE"
    m = ["reflect", "constant", "nearest", "mirror", "wrap"]
    
    DIST_MODE = 'DIST_MODE'
    DIST_COEFF_MODE = 'DIST_COEFF_MODE'
    AGR_FUNC = 'AGR_FUNC'
    agr_funcs = ['KeepValue','AddWindow','DivWindow']
    ADD_FUNC = 'ADD_FUNC'
    ADD_FUNC_NAMES = ['sum','nansum','nanmean','None']
    add_funcs = [np.sum,np.nansum,np.nanmean,None]

    QUANTILE = 'QUANTILE'
    REDISTRIB_VAL = 'REDISTRIB_VAL'
    FINAL_FUNC = 'FINAL_FUNC'
    final_funcs = ['None','Log10','Exp','Sqrt','Index']
    
    CLASSES_ORDER = "CLASSES_ORDER"
    CLASS = "CLASS"
    OUTPUT_FILE = "OUTPUT"
    
    DEBUG_FIELDNAME = 'DEBUG'
    DEBUG = False
        
    def initAlgorithm(self, classesParam=False, classParam=False, agrFuncParam=False,
            addFuncParam=False, quantParam=False, finalFuncParam=False,
            distModeParam=False,distModeCoeffParam=False,
            redistribParams=False, config=None, report_opt=True):
        self.classesParamFlag = classesParam
        self.classParamFlag = classParam
        self.distModeParamFlag = distModeParam
        self.distModeCoeffParamFlag = distModeCoeffParam
        self.agrFuncParamFlag = agrFuncParam
        self.addFuncParamFlag = addFuncParam
        self.quantParamFlag = quantParam
        self.redistribParamsFlag = redistribParams
        self.finalFuncParamFlag = finalFuncParam
        self.addParameter(QgsProcessingParameterRasterLayer(
            self.INPUT,
            "Input layer"))
        self.addParameter(
            QgsProcessingParameterNumber(
                self.WINDOW_SIZE,
                description = self.tr('Window size (pixels)'),
                type=QgsProcessingParameterNumber.Integer,
                defaultValue=5))
        # self.addParameter(
            # QgsProcessingParameterEnum(
                # self.MODE,
                # description = self.tr('Behaviour at Edges'),
                # options=self.m,
                # defaultValue=0))
        if classesParam:
            self.addParameter(
                QgsProcessingParameterString(
                    self.CLASSES_ORDER,
                    description = self.tr('Classes order (from unfavorable to very favorable)')))
        if classParam:
            self.addParameter(
                QgsProcessingParameterNumber(
                    self.CLASS,
                    description = self.tr('Class'),
                    type=QgsProcessingParameterNumber.Integer,
                    optional=True))
        if quantParam:
            self.addParameter(
                QgsProcessingParameterNumber(
                    self.QUANTILE,
                    description = self.tr('Percentile'),
                    type=QgsProcessingParameterNumber.Double,
                    defaultValue=0.75))
        self.addParameter(
            QgsProcessingParameterBoolean(
                self.DEBUG_FIELDNAME,
                description = self.tr('Print debug messages'),
                defaultValue=False,
                optional=True))
        self.addParameter(
            QgsProcessingParameterRasterDestination(
            self.OUTPUT,
            description = self.tr('Output layer')))
        self.addAdvancedParams()
        
    def addAdvancedParams(self):
        # if self.agrFuncParamFlag:
            # self.addAgrFuncParam()
        if self.distModeParamFlag:
            self.addDistModeParam()
        if self.distModeCoeffParamFlag:
            self.addDistModeCoeffParam()
        if self.redistribParamsFlag:
            self.addRedistribParams()
        if self.agrFuncParamFlag:
            self.addAgrFuncParam()
        if self.addFuncParamFlag:
            self.addAddFuncParam()
        if self.finalFuncParamFlag:
            finalFuncParam = QgsProcessingParameterEnum(
                self.FINAL_FUNC,
                description = self.tr('Final function'),
                options=self.final_funcs,
                defaultValue=4)
            self.addAdvancedParam(finalFuncParam)
            
    def addRedistribParams(self):
        redistribValueParam = QgsProcessingParameterNumber(
            self.REDISTRIB_VAL,
            description = self.tr('Redistribution value'),
            type=QgsProcessingParameterNumber.Double,
            defaultValue=1.0)
        self.addAdvancedParam(redistribValueParam)
    def addAgrFuncParam(self):
        agrFuncParam = QgsProcessingParameterEnum(
            self.AGR_FUNC,
            description = self.tr('Agregate function'),
            options=self.agr_funcs,
            defaultValue=0)
        self.addAdvancedParam(agrFuncParam)
    def addAddFuncParam(self):
        addFuncParam = QgsProcessingParameterEnum(
            self.ADD_FUNC,
            description = self.tr('Additive function'),
            options=self.ADD_FUNC_NAMES,
            defaultValue=0)
        self.addAdvancedParam(addFuncParam)
    def addDistModeParam(self):
        dist_modes = [self.tr('Minimum'),self.tr('Minimum + 1'),self.tr('Median')]
        distModeParam = QgsProcessingParameterEnum(
            self.DIST_MODE,
            description = self.tr('Distance mode'),
            options=dist_modes,
            defaultValue=0)
        self.addAdvancedParam(distModeParam)
    def addDistModeCoeffParam(self):
        self.coeff_modes = [self.tr('Exponential'),self.tr('Linear')]
        distModeCoeffParam = QgsProcessingParameterEnum(
            self.DIST_COEFF_MODE,
            description = self.tr('Distance weighting mode'),
            options=self.coeff_modes,
            defaultValue=0)
        self.addAdvancedParam(distModeCoeffParam)
            
    def pushDebug(self,msg,feedback=None):
        feedback = feedback if feedback else self.feedback
        if self.DEBUG:
            feedback.pushDebugInfo(msg)
            
    def parseParams(self,parameters,context,feedback):
        self.input = self.parameterAsRasterLayer(parameters,self.INPUT,context)
        if self.input is None:
            raise QgsProcessingException(self.invalidRasterError(parameters, self.INPUT))
        self.input_path = qgsUtils.pathOfLayer(self.input)
        self.input_nodata = self.input.dataProvider().sourceNoDataValue(1)
        self.size = self.parameterAsInt(parameters,self.WINDOW_SIZE,context)
        self.pixel_area = self.input.rasterUnitsPerPixelX() * self.input.rasterUnitsPerPixelY()
        
        # mode = self.m[self.parameterAsEnum(parameters, self.MODE, context)]
        if self.classesParamFlag:
            self.classes_order = self.parameterAsString(parameters,self.CLASSES_ORDER,context)
            feedback.pushDebugInfo("classes_order = " + str(self.classes_order)) 
            self.classes_ordered = [int(c) for c in self.classes_order.split(",")]
            feedback.pushDebugInfo("classes_ordered = " + str(self.classes_ordered))
            if not self.classes_ordered:
                raise QgsProcessingException("Please specify classes order (empty list)")
        if self.classParamFlag:
            self.classParam = self.parameterAsInt(parameters,self.CLASS,context)
        if self.quantParamFlag:
            self.quantile = self.parameterAsDouble(parameters,self.QUANTILE,context)
        if self.redistribParamsFlag:
            self.redistribVal = self.parameterAsDouble(parameters,self.REDISTRIB_VAL,context)
        if self.distModeParamFlag:
            self.distMode = self.parameterAsBool(parameters,self.DIST_MODE,context)
        if self.distModeCoeffParamFlag:
            self.distCoeffMode = self.parameterAsBool(parameters,
                self.DIST_COEFF_MODE,context)
        if self.agrFuncParamFlag:
            self.agr_func_mode = self.parameterAsEnum(parameters,self.AGR_FUNC,context)
            feedback.pushDebugInfo("agr_func_mode = " + str(self.agr_func_mode))
        if self.addFuncParamFlag:
            self.add_func_mode = self.parameterAsInt(parameters,self.CLASS,context)
            self.add_func_mode = self.parameterAsEnum(parameters,self.ADD_FUNC,context)
            feedback.pushDebugInfo("add_func_mode = " + str(self.add_func_mode))
            self.add_func = self.add_funcs[self.add_func_mode]
            if self.add_func is None:
                self.add_func = self.getCenterPixel
            self.filter_neutral = 0 if self.add_func_mode == 0 else math.nan#math.nan
        if self.finalFuncParamFlag:
            self.final_func_mode = self.parameterAsEnum(parameters,self.FINAL_FUNC,context)
            feedback.pushDebugInfo("final_func_mode = " + str(self.final_func_mode))
        self.DEBUG = self.parameterAsBool(parameters,self.DEBUG_FIELDNAME,context)
        self.output = self.parameterAsOutputLayer(parameters, self.OUTPUT, context)
        # Processing
        self.feedback = feedback
        self.nodata = self.input.dataProvider().sourceNoDataValue(1)
        feedback.pushDebugInfo("nodata = " + str(self.nodata))
        self.out_nodata = -1
        
    def prepareWindow(self,feedback=None):        
        self.array_median = self.size * 2 + 1
        self.val_idx = int((self.array_median + 1) / 2)
        self.pushDebug("val_idx = " + str(self.val_idx)) 
        self.dist_shape = (self.array_median, self.array_median)
        self.pushDebug("dist_shape = " + str(self.dist_shape)) 
        self.dist_array = np.fromfunction(self.distFromCenter,self.dist_shape)
        self.pushDebug("dist_array = " + str(self.dist_array))
        self.footprint = np.ones(self.dist_shape,dtype='bool')
        self.pushDebug("foot_shape = " + str(self.footprint.shape))
        self.footprint[self.dist_array > self.size] = False
        self.nbPixDist = np.count_nonzero(self.dist_array > self.size)
        self.pushDebug("footprint = " + str(self.footprint))
        self.dist_array2 = self.dist_array[self.dist_array <= self.size]
        self.pushDebug("dist_array2 = " + str(self.dist_array2))
        nb_elem_footprint = np.count_nonzero(self.footprint != False)
        self.val_idx_footprint = int(nb_elem_footprint/2)
        self.dist_array[self.dist_array > self.size] = math.nan
        self.pushDebug("dist_array = " + str(self.dist_array))
        self.dist_array_flatten = self.dist_array2.flatten()
        self.pushDebug("self.dist_array_flatten = " + str(self.dist_array_flatten))
        # Distance rate
        self.dist_rate_arr_flatten = (self.size - self.dist_array_flatten) / self.size
        self.pushDebug("dist_rate_arr_flatten = " + str(self.dist_rate_arr_flatten))
        self.dist_arr_exp = np.exp(np.negative(self.dist_array_flatten))
        self.pushDebug("dist_arr_exp = " + str(self.dist_arr_exp))
        if self.distModeParamFlag:
            if self.distMode == 0:
                self.distFunc = self.getDistMin
            elif self.distMode == 1:
                self.distFunc = self.getDistMinPlusOne
            elif self.distMode == 2:
                self.distFunc = self.getDistMed
            else:
                assert(False)
        if self.distModeCoeffParamFlag:
            if self.distCoeffMode == 0:
                self.dist_arr = self.dist_arr_exp
                self.coeffFunc = self.expFunc
            elif self.distCoeffMode == 1:
                self.dist_arr = self.dist_rate_arr_flatten
                self.coeffFunc = self.rateFunc
            else:
                assert(False)
            self.dist_base_sum = np.sum(self.dist_arr)
        # Computing immediate neighbours (4-connexity)
        
    def getCenterPixel(self,array):
        return array[self.val_idx_footprint]
                
    def getDistMin(self,array,v):
        return np.amin(self.dist_array_flatten[array==v])
    def getDistMinPlusOne(self,array,v):
        return np.amin(self.dist_array_flatten[array==v]) + 1
    def getDistMed(self,array,v):
        return np.nanmedian(self.dist_array_flatten[array==v])
        
    def expFunc(self,val):
        return math.exp(-val)
    def rateFunc(self,val):
        return (self.size - val) / self.size
                
    def distFromCenter(self,X,Y):
        self.pushDebug("X = " + str(X))
        self.pushDebug("Y = " + str(Y))
        return np.sqrt(((X.astype(int) - self.size) ** 2) + ((Y.astype(int) - self.size) ** 2))

    @abstractmethod
    def filter_func(self,array):
        pass
        
    def getFirstToEnd(self):
        return False
        # return self.agr_func_mode == 2
        
    def prepareClasses(self,classes,feedback,firstToEnd=None):
        feedback.pushDebugInfo("classes = " + str(classes))
        excludeClasses = [c for c in classes if c not in self.classes_ordered]
        for c in excludeClasses:
            if c not in self.classes_ordered:
                feedback.pushWarning("Class " + str(c) + " order not specified")
        keepClasses = [c for c in self.classes_ordered if c in classes]
        feedback.pushDebugInfo("classes = " + str(keepClasses))
        firstToEnd = self.getFirstToEnd()
        feedback.pushDebugInfo("firstToEnd = " + str(firstToEnd))
        if firstToEnd:
            keepClasses = keepClasses[1:] + keepClasses[:1]
        feedback.pushDebugInfo("classes = " + str(keepClasses))
        return keepClasses
        
    @abstractmethod
    def prepareArray(self,feedback):
        assert False

    def applyAddFunc(self,arr):
        res_arr = ndimage.generic_filter(arr,
            self.add_func,footprint=self.footprint,
            mode="constant",cval=self.filter_neutral)
        return res_arr

    def processDistrib(self,feedback,arr=None):
        if arr is None:
            arr = self.preparedArr
        # Computes quantiles
        arr[self.array==self.inNodata] = math.nan
        quants = {}
        for c in self.classes:
            q = np.nanquantile(arr[self.array==c],q=self.quantile)
            quants[c] = q
        feedback.pushDebugInfo("quants = " + str(quants))
        arr[self.array==self.inNodata] = 0
        # Add cumulative quantile to each class pixel
        acc_q = 0
        for c in self.classes:
            acc_q += quants[c]
            feedback.pushDebugInfo("acc_q = " + str(acc_q))
            arr[self.array==c] += acc_q
        self.debugRaster(feedback,arr,self.input_path,"prepared",
            nodata=-1,type=gdal.GDT_Float32)
        return arr
        
    def processAgr(self,feedback):
        # Agregation
        self.preparedArr[self.array==self.inNodata] = self.filter_neutral
        if self.agr_func_mode == 0:
            res_arr = np.copy(self.preparedArr)
        elif self.agr_func_mode == 1:
            res_arr = self.applyAddFunc(self.preparedArr)
        elif self.agr_func_mode == 2:
            # TODO : split processDistrib in different functions
            tmp_arr = np.copy(self.preparedArr)
            res_u_arr = ndimage.generic_filter(tmp_arr,
                self.add_func,footprint=self.footprint,
                mode="constant",cval=self.filter_neutral)
            tmp_arr[self.array==self.classes[-1]] = self.filter_neutral
            res_arr = ndimage.generic_filter(tmp_arr,
                self.add_func,footprint=self.footprint,
                mode="constant",cval=self.filter_neutral)
            res_u_arr += 1
            res_arr /= res_u_arr
        else:
            assert(False)
        return res_arr
        
    def processFinal(self,res_arr,minVal=None,maxVal=None):
        if not self.finalFuncParamFlag:
            pass
        elif self.final_func_mode == 1:
            res_arr = np.log10(res_arr)
        elif self.final_func_mode == 2:
            res_arr = np.exp(res_arr)
        elif self.final_func_mode == 3:
            res_arr = np.sqrt(res_arr)
        elif self.final_func_mode == 4:
            minVal = np.amin(res_arr) if minVal is None else minVal
            maxVal = np.amax(res_arr) if maxVal is None else maxVal
            self.pushDebug("minVal = " + str(minVal))
            self.pushDebug("maxVal = " + str(maxVal))
            res_arr -= minVal
            res_arr /= (maxVal - minVal)
        return res_arr
        
    def processOutput(self,res_arr,feedback):
        # Writes output
        feedback.pushDebugInfo("out_nodata = " + str(self.out_nodata))
        res_arr[self.array==self.inNodata] = self.out_nodata
        qgsUtils.exportRaster(res_arr,self.input_path,self.output,
            nodata=self.out_nodata,type=gdal.GDT_Float32)
        # out_layer = qgsUtils.loadRasterLayer(self.output)
        # styles.setRendererSBPCGnYlRdCont(out_layer)
        # out_layer.triggerRepaint()
        return { self.OUTPUT_FILE : self.output }

    def processAlgorithm(self,parameters,context,feedback):
        self.parseParams(parameters,context,feedback)
        self.prepareWindow(feedback)
        # Retrieve classes and array
        classes, self.array, self.inNodata = qgsUtils.getRasterValsArrayND(
            str(self.input_path))
        self.classes = self.prepareClasses(classes,feedback)
        self.preparedArr = self.prepareArray(context,feedback).astype(np.float32)
        self.processDistrib(feedback)
        res_arr = self.applyAddFunc(self.preparedArr)
        res_arr = self.processFinal(res_arr)
        return self.processOutput(res_arr,feedback)
        



class QuantileDistance(SlidingWindowCircle):

    ALG_NAME = 'quantileDistance'
    
    def initAlgorithm(self, config=None, report_opt=True):
        super().initAlgorithm(classParam=True,quantParam=True)
    
    def displayName(self):
        return self.tr("Quantile distance")
        
    def shortHelpString(self):
        return self.tr("Distance to pixel of same values inside sliding window.")
        
    # def icon(self):
        # return QIcon(os.path.dirname(__file__) + os.sep+"icons"+os.sep+"img_neighboranalysis.png")

    def processAlgorithm(self,parameters,context,feedback):
        self.parseParams(parameters,context,feedback)
        self.prepareWindow(feedback)
        classes, array = qgsUtils.getRasterValsAndArray(str(self.input_path))
        feedback.pushDebugInfo("classes = " + str(classes))
        self.nb_vals = len(classes)
        feedback.pushDebugInfo("array shape = " + str(array.shape))
        res_arr = ndimage.generic_filter(array,
            self.filter_func,footprint=self.footprint,
            mode="constant",cval=0,output=np.float32)
        # Output
        qgsUtils.exportRaster(res_arr,self.input_path,self.output,
            nodata=self.out_nodata,type=gdal.GDT_Float32)
        return { self.OUTPUT_FILE : self.output }

    def filter_func(self,array):
        cell_val = self.classParam if self.classParam else array[self.val_idx_footprint]
        if cell_val == self.nodata:
            res = self.out_nodata
        else:
            # self.pushDebug("cell_val = " + str(cell_val))
            dist_val = self.dist_array_flatten[array==cell_val]
            # self.pushDebug("dist_val = " + str(dist_val))
            # val_median = np.nanp.nanquantile(dist_val,self.quantile)nmedian(dist_val)
            val_quantile = np.nanquantile(dist_val,self.quantile)
            res = val_quantile
        return res
        
    def computeQuantile(self,arr):
        quantile_arr = ndimage.generic_filter(array,
            self.filter_func,footprint=self.footprint,
            mode="constant",cval=0,output=np.float32)
        return quantile_arr

    

class MedianDistance(SlidingWindowCircle):

    ALG_NAME = 'medianDistance'
    
    def initAlgorithm(self, config=None, quantParam=False,report_opt=True):
        super().initAlgorithm(classParam=True,quantParam=quantParam)
    
    def displayName(self):
        return self.tr("Median distance")
        
    def shortHelpString(self):
        return self.tr("Median distance to pixel of same values inside sliding window.")
        
    # def icon(self):
        # return QIcon(os.path.dirname(__file__) + os.sep+"icons"+os.sep+"img_neighboranalysis.png")

    def processAlgorithm(self,parameters,context,feedback):
        self.parseParams(parameters,context,feedback)
        self.prepareWindow(feedback)
        classes, array = qgsUtils.getRasterValsAndArray(str(self.input_path))
        feedback.pushDebugInfo("classes = " + str(classes))
        self.nb_vals = len(classes)
        # Computing immediate neighbours (4-connexity)
        feedback.pushDebugInfo("array shape = " + str(array.shape))
        # Encoding value with immediate neighbouts
        # new_arr = array * 10 + nb_neighbours_arr
        # feedback.pushDebugInfo("new_arr shape = " + str(new_arr.shape))
        res_arr = ndimage.generic_filter(array,
            self.filter_func,footprint=self.footprint,
            mode="constant",cval=0,output=np.float32)
        # Output
        qgsUtils.exportRaster(res_arr,self.input_path,self.output,
            nodata=self.out_nodata,type=gdal.GDT_Float32)
        # qgsUtils.exportRaster(result,self.input_path,output,
            # nodata=self.out_nodata,type=gdal.GDT_UInt16)
        return { self.OUTPUT_FILE : self.output }

    def filter_func(self,array):
        # self.pushDebug("array = " + str(array))
        cell_val = self.classParam if self.classParam else array[self.val_idx_footprint]
        if cell_val == self.nodata:
            res = self.out_nodata
        else:
            # self.pushDebug("cell_val = " + str(cell_val))
            dist_val = self.dist_array_flatten[array==cell_val]
            # self.pushDebug("dist_val = " + str(dist_val))
            # val_median = np.nanmedian(dist_val)
            val_median = np.nanmedian(dist_val)
            res = val_median
        return res
        
    def computeMedian(self,arr):
        median_arr = ndimage.generic_filter(arr,
            self.filter_func,footprint=self.footprint,
            mode="constant",cval=0,output=np.float32)
        return median_arr
        
    # def filterFuncDistrib(self,array):
        # cell_val = array[self.val_idx_footprint]
        # if cell_val == self.nodata:
            # res = self.out_nodata
        # else:
            # for c in self.classes_ordered:
                # dist_val = self.dist_array_flatten[array==c]
                # val_median = np.nanmedian(dist_val)
                
                
        
        

class PatchAreaWindow(SlidingWindowCircle):

    ALG_NAME = 'patchAreaWindow'
    
    def displayName(self):
        return self.tr("Patch size (sliding window)")
        
    def shortHelpString(self):
        return self.tr("Patch area inside sliding window")
        
    # def icon(self):
        # return QIcon(os.path.dirname(__file__) + os.sep+"icons"+os.sep+"img_neighboranalysis.png")

    def initAlgorithm(self, config=None):
        super().initAlgorithm(addFuncParam=False)
    
    def processAlgorithm(self,parameters,context,feedback):
        self.parseParams(parameters,context,feedback)
        self.prepareWindow(feedback)
        # Label input
        labelled_path = self.mkTmpPath("labelled.tif")
        label_params = { LabelPatches.INPUT : self.input,
            LabelPatches.OUTPUT : labelled_path }
        processing.run("BioDispersal:" + LabelPatches.ALG_NAME,
            label_params,context=context,feedback=feedback)
        # Processing on labelled array
        classes, array = qgsUtils.getRasterValsAndArray(str(labelled_path))
        # feedback.pushDebugInfo("classes = " + str(classes))
        # self.nb_vals = len(classes)
        # feedback.pushDebugInfo("labelled array  = " + str(array))
        feedback.pushDebugInfo("labelled array shape = " + str(array.shape))
        res_arr = ndimage.generic_filter(array,
            self.filter_func,footprint=self.footprint,
            mode="constant",cval=0,output=np.float32)
        # Output
        qgsUtils.exportRaster(res_arr,self.input_path,self.output,
            nodata=0,type=gdal.GDT_UInt32)
        # qgsUtils.exportRaster(result,self.input_path,output,
            # nodata=self.out_nodata,type=gdal.GDT_UInt16)
        return { self.OUTPUT_FILE : self.output }

    def filter_func(self,array):
        # self.feedback.pushDebugInfo("array = " + str(array))
        cell_val = array[self.val_idx_footprint]    
        # self.feedback.pushDebugInfo("cell_val = " + str(cell_val))
        res = np.count_nonzero(array[array == cell_val])
        # self.feedback.pushDebugInfo("res = " + str(res))
        return res



class AreaDistrib(SlidingWindowCircle):

    ALG_NAME = 'areaWindowDistrib'
    
    def initAlgorithm(self, config=None):
        super().initAlgorithm(classesParam=True,quantParam=True)
        
    def displayName(self):
        return self.tr("Area distrib")
        
    def shortHelpString(self):
        return self.tr("Area distrib (sliding window distribution)")
        
    # def icon(self):
        # return QIcon(os.path.dirname(__file__) + os.sep+"icons"+os.sep+"img_neighboranalysis.png")

    def processAlgorithm(self,parameters,context,feedback):
        self.parseParams(parameters,context,feedback)
        self.prepareWindow(feedback)
        classes, array, input_nodata = qgsUtils.getRasterValsArrayND(str(self.input_path))
        classes = self.prepareClasses(classes,feedback,firstToEnd=False)
        feedback.pushDebugInfo("classes = " + str(classes))
        self.nb_vals = len(classes)
        feedback.pushDebugInfo("array shape = " + str(array.shape))
        acc_q = 0
        area_arr = ndimage.generic_filter(array,
            self.add_func,footprint=self.footprint,
            mode="constant",cval=0,output=np.float32)
        for cpt, c in enumerate(classes,start=1):
            feedback.pushDebugInfo("class = " + str(c))
            feedback.pushDebugInfo("cpt = " + str(cpt))
            q = np.quantile(area_arr[array==c],1)
            area_arr[array==c] += acc_q
            feedback.pushDebugInfo("q = " + str(q))
            acc_q += q
            feedback.pushDebugInfo("acc_q = " + str(acc_q))
            # if self.DEBUG:
                # feedback.pushDebugInfo("area_arr = " + str(area_arr))
                # feedback.pushDebugInfo("area_arr.dtype = " + str(area_arr.dtype))
                # area_c_path = QgsProcessingUtils.generateTempFilename("area_" + str(c) + ".tif")
                # feedback.pushDebugInfo("area_c_path = " + str(area_c_path))
                # qgsUtils.exportRaster(area_arr,self.input_path,area_c_path,
                    # nodata=-1,type=gdal.GDT_Int32)
        # Output
        area_arr[array==input_nodata] = self.out_nodata
        self.pushDebug("area_arr = " + str(area_arr))
        qgsUtils.exportRaster(area_arr,self.input_path,self.output,
            nodata=-1,type=gdal.GDT_Float32)
        # qgsUtils.exportRaster(result,self.input_path,output,
            # nodata=self.out_nodata,type=gdal.GDT_UInt16)
        return { self.OUTPUT_FILE : self.output }

    def filter_func(self,array):
        cell_val = array[self.val_idx_footprint]
        # self.feedback.pushDebugInfo("array = " + str(array))
        res = np.count_nonzero(array[array == cell_val])
        # self.feedback.pushDebugInfo("res = " + str(res))
        return res
                


class MedianDistanceDistrib(IndexAlgorithm,MedianDistance):

    ALG_NAME = 'medianDistanceDistrib'
    
    def initAlgorithm(self, report_opt=True):
        SlidingWindowCircle.initAlgorithm(self,classesParam=True,
            quantParam=True,finalFuncParam=True)
    
    def displayName(self):
        return self.tr("Distance index")
        
    def shortHelpString(self):
        return self.tr("Computes median distance index. Index is obtained by redistributing median distances of each class value.")
    
    def filter_func(self,array):
        # self.pushDebug("array = " + str(array))
        # self.pushDebug("cell_val = " + str(self.currVal))
        dist_val = self.dist_array_flatten[array==self.currVal]
        # self.pushDebug("dist_val = " + str(dist_val))
        val_median = np.nanmedian(dist_val)
        # res = self.size if math.isnan(val_median) else self.size - val_median
        # return res
        return self.size - val_median
        
    def prepareArray(self,context,feedback):
        median_path = self.mkTmpPath("median.tif")
        median_params = { MedianDistance.INPUT : self.input,
            MedianDistance.WINDOW_SIZE : self.size,
            MedianDistance.OUTPUT : median_path }
        processing.run("BioDispersal:" + MedianDistance.ALG_NAME,
            median_params,context=context,feedback=feedback)
        median_classes, median_arr = qgsUtils.getRasterValsAndArray(median_path)
        return median_arr
                
    # def processDistrib(self,array,classes,feedback,classArray=None,neutralElem=math.nan):
        # return SlidingWindowCircle.processDistrib(self,array,
            # classes,feedback,classArray=classArray,neutralElem=neutralElem)
        
    # def processAlgorithm(self,parameters,context,feedback):
        # return SlidingWindowCircle.processAlgorithm(self,parameters,context,feedback)

    def processAlgorithm(self,parameters,context,feedback):
        self.parseParams(parameters,context,feedback)
        self.prepareWindow(feedback)
        classes, array, input_nodata = qgsUtils.getRasterValsArrayND(str(self.input_path))
        classes = self.prepareClasses(classes,feedback,firstToEnd=True)
        feedback.pushDebugInfo("classes = " + str(classes))
        self.nb_vals = len(classes)
        feedback.pushDebugInfo("array shape = " + str(array.shape))
        acc_arr = np.zeros(array.shape)
        acc_quantile = 0
        for cpt, c in enumerate(classes,start=1):
            feedback.pushDebugInfo("class = " + str(c))
            feedback.pushDebugInfo("cpt = " + str(cpt))
            # tmp_arr = np.copy(array)
            # tmp_arr[array != c] = -1
            self.currVal = c
            self.classParam = c
            median_arr = self.computeMedian(array)
            self.pushDebug("median_arr = " + str(median_arr))
            feedback.pushDebugInfo("median_arr.dtype = " + str(median_arr.dtype))
            self.debugRaster(feedback,median_arr,self.input_path,"median" + str(c),
                nodata=-1,type=gdal.GDT_Float32)
            median_arr[array==input_nodata] = math.nan
            quantile = np.nanquantile(median_arr,q=self.quantile)
            feedback.pushDebugInfo("quantile = " + str(quantile))
            # median_arr[array==input_nodata] = 0
            # median_arr[np.isnan(median_arr)] = self.size
            acc_arr = np.add(median_arr,acc_arr)
            median_arr[np.isnan(median_arr)] = 0
            self.pushDebug("median_arr nonan = " + str(median_arr))
            if cpt > 1:
                median_arr = np.add(median_arr,acc_quantile)
            if cpt == self.nb_vals:
                acc_arr = acc_arr / median_arr
                # acc_arr = median_arr / acc_arr
            else:
                # acc_arr = np.add(acc_arr,median_arr)
                acc_quantile += quantile
                feedback.pushDebugInfo("acc_quantile = " + str(acc_quantile))
            self.pushDebug("acc_arr = " + str(acc_arr))
        acc_arr[array==input_nodata] = self.out_nodata
        self.pushDebug("acc_arr = " + str(acc_arr))
        qgsUtils.exportRaster(acc_arr,self.input_path,self.output,
            nodata=self.out_nodata,type=gdal.GDT_Float32)
        return { self.OUTPUT_FILE : self.output }

      
class MedianDistanceDistrib2(MedianDistanceDistrib):
    
    def initAlgorithm(self, report_opt=True):
        super().initAlgorithm(self)
    
    def displayName(self):
        return self.tr("Distance index (2)")
        
    def shortHelpString(self):
        return self.tr("Computes median distance index. Index is obtained by redistributing median distances of each class value.")
    
    def filter_func(self,array):
        dist_val = self.dist_array_flatten[array==self.currVal]
        val_median = np.nanmedian(dist_val)
        return self.size - val_median
        
    def prepareArray(self,context,feedback):
        median_path = self.mkTmpPath("median.tif")
        median_params = { QuantileDistance.INPUT : self.input,
            QuantileDistance.WINDOW_SIZE : self.size,
            QuantileDistance.OUTPUT : median_path }
        processing.run("BioDispersal:" + QuantileDistance.ALG_NAME,
            median_params,context=context,feedback=feedback)
        median_classes, median_arr = qgsUtils.getRasterValsAndArray(median_path)
        return median_arr
                
    def processAlgorithm(self,parameters,context,feedback):
        self.parseParams(parameters,context,feedback)
        self.prepareWindow(feedback)
        classes, array, input_nodata = qgsUtils.getRasterValsArrayND(str(self.input_path))
        classes = self.prepareClasses(classes,feedback,firstToEnd=True)
        feedback.pushDebugInfo("classes = " + str(classes))
        self.nb_vals = len(classes)
        feedback.pushDebugInfo("array shape = " + str(array.shape))
        acc_arr = np.zeros(array.shape)
        acc_quantile = 0
        for cpt, c in enumerate(classes,start=1):
            feedback.pushDebugInfo("class = " + str(c))
            feedback.pushDebugInfo("cpt = " + str(cpt))
            # tmp_arr = np.copy(array)
            # tmp_arr[array != c] = -1
            self.currVal = c
            self.classParam = c
            median_arr = self.computeMedian(array)
            self.pushDebug("median_arr = " + str(median_arr))
            feedback.pushDebugInfo("median_arr.dtype = " + str(median_arr.dtype))
            self.debugRaster(feedback,median_arr,self.input_path,"median" + str(c),
                nodata=-1,type=gdal.GDT_Float32)
            median_arr[array==input_nodata] = math.nan
            quantile = np.nanquantile(median_arr,q=self.quantile)
            feedback.pushDebugInfo("quantile = " + str(quantile))
            # median_arr[array==input_nodata] = 0
            # median_arr[np.isnan(median_arr)] = self.size
            acc_arr = np.add(median_arr,acc_arr)
            median_arr[np.isnan(median_arr)] = 0
            self.pushDebug("median_arr nonan = " + str(median_arr))
            if cpt > 1:
                median_arr = np.add(median_arr,acc_quantile)
            if cpt == self.nb_vals:
                acc_arr = acc_arr / median_arr
                # acc_arr = median_arr / acc_arr
            else:
                # acc_arr = np.add(acc_arr,median_arr)
                acc_quantile += quantile
                feedback.pushDebugInfo("acc_quantile = " + str(acc_quantile))
            self.pushDebug("acc_arr = " + str(acc_arr))
        acc_arr[array==input_nodata] = self.out_nodata
        self.pushDebug("acc_arr = " + str(acc_arr))
        qgsUtils.exportRaster(acc_arr,self.input_path,self.output,
            nodata=self.out_nodata,type=gdal.GDT_Float32)
        return { self.OUTPUT_FILE : self.output }

class PatchSizeWindowRedistrib(IndexAlgorithm,SlidingWindowCircle):
    
    ALG_NAME = 'patchSizeWindowRedistrib'
    INDEX = 'INDEX'
    
    def initAlgorithm(self, config=None):
        super().initAlgorithm(classesParam=True,quantParam=True,
            finalFuncParam=True)
        
    def displayName(self):
        return self.tr("Surface index")
        
    def shortHelpString(self):
        return self.tr("Redistributed patch size inside slinding window")
    
    # def initAlgorithm(self, classesParam=True, quant=False,
            # funcs=True, config=None, report_opt=True):
        # super().initAlgorithm(finalFuncParam=True)
        
    def addAdvancedParams(self):
        self.index_vals = [self.tr('Patch size'), self.tr('Number of contacts')]
        indexParam = QgsProcessingParameterEnum(
            self.INDEX,
            description = self.tr('Index'),
            options=self.index_vals,
            defaultValue=0)
        # self.addAdvancedParam(indexParam)
        super().addAdvancedParams()
        
    def parseParams(self,parameters,context,feedback):
        super().parseParams(parameters,context,feedback)
        # self.indexMode = self.parameterAsEnum(parameters,self.INDEX,context)
        self.indexMode = 0
        
    def prepareArray(self,context,feedback):
        if self.indexMode == 0:
            return self.preparePatchSize(context,feedback)
        elif self.indexMode == 1:
            return self.prepareNbContacts(context,feedback)
        else:
            assert(False)
        
    def preparePatchSize(self,context,feedback):
        size_path = self.mkTmpPath("patchSize.tif")
        size_params = { PatchAreaWindow.INPUT : self.input,
            PatchAreaWindow.WINDOW_SIZE : self.size,
            PatchAreaWindow.OUTPUT : size_path }
        processing.run("BioDispersal:" + PatchAreaWindow.ALG_NAME,
            size_params,context=context,feedback=feedback)
        size_classes, size_arr = qgsUtils.getRasterValsAndArray(size_path)
        return size_arr
        
    def prepareNbContacts(self,context,feedback):
        ncount_struct = ndimage.generate_binary_structure(2,1)
        nb_neighbours_arr = ndimage.generic_filter(self.array,
            self.count_neighbours_4,footprint=ncount_struct,
            mode="constant",cval=0)
        feedback.pushDebugInfo("nb_neighbours_arr shape = " + str(nb_neighbours_arr.shape))
        if self.DEBUG:
            self.feedback.pushDebugInfo("array = " + str(self.array))
            feedback.pushDebugInfo("nb_neighbours_arr = " + str(nb_neighbours_arr))
        res_arr = ndimage.generic_filter(nb_neighbours_arr,
            np.sum,footprint=self.footprint,
            mode="constant",cval=0)
        return res_arr
            
    def count_neighbours_4(self,array):
        cell_val = array[2]
        return np.count_nonzero(array == cell_val) - 1
        

class SurfaceIndex2(IndexAlgorithm,SlidingWindowCircle):
    
    ALG_NAME = 'surfaceIndex2'
    INDEX = 'INDEX'
    
    def initAlgorithm(self, config=None):
        super().initAlgorithm(classesParam=True,quantParam=True,
            addFuncParam=True,finalFuncParam=True)
        
    def displayName(self):
        return self.tr("Surface index 2")
        
    def shortHelpString(self):
        return self.tr("Surface index 2 (sliding window distribution)")
    
    # def initAlgorithm(self, classesParam=True, quant=False,
            # funcs=True, config=None, report_opt=True):
        # super().initAlgorithm(finalFuncParam=True)
        
    def addAdvancedParams(self):
        self.index_vals = [self.tr('Patch size'), self.tr('Number of contacts')]
        indexParam = QgsProcessingParameterEnum(
            self.INDEX,
            description = self.tr('Index'),
            options=self.index_vals,
            defaultValue=0)
        # self.addAdvancedParam(indexParam)
        super().addAdvancedParams()
        
    def parseParams(self,parameters,context,feedback):
        super().parseParams(parameters,context,feedback)
        # self.indexMode = self.parameterAsEnum(parameters,self.INDEX,context)
        self.indexMode = 0
        
    def prepareArray(self,context,feedback):
        return self.preparePatchSize(context,feedback)
        
    def preparePatchSize(self,context,feedback):
        patchSize_path = self.mkTmpPath("patchSize.tif")
        patchSize_params = { PatchAreaWindow.INPUT : self.input,
            PatchAreaWindow.WINDOW_SIZE : self.size,
            PatchAreaWindow.OUTPUT : patchSize_path }
        processing.run("BioDispersal:" + PatchAreaWindow.ALG_NAME,
            patchSize_params,context=context,feedback=feedback)
        patchSize_classes, patchSize_arr = qgsUtils.getRasterValsAndArray(patchSize_path)
        return patchSize_arr
        
    def prepareNbContacts(self,context,feedback):
        ncount_struct = ndimage.generate_binary_structure(2,1)
        nb_neighbours_arr = ndimage.generic_filter(self.array,
            self.count_neighbours_4,footprint=ncount_struct,
            mode="constant",cval=0)
        feedback.pushDebugInfo("nb_neighbours_arr shape = " + str(nb_neighbours_arr.shape))
        if self.DEBUG:
            self.feedback.pushDebugInfo("array = " + str(self.array))
            feedback.pushDebugInfo("nb_neighbours_arr = " + str(nb_neighbours_arr))
        res_arr = ndimage.generic_filter(nb_neighbours_arr,
            np.sum,footprint=self.footprint,
            mode="constant",cval=0)
        return res_arr
            
    def count_neighbours_4(self,array):
        cell_val = array[2]
        return np.count_nonzero(array == cell_val) - 1
        
    def filter_func2(self,array):
        dist_arr = self.dist_rate_arr_flatten
        # self.feedback.pushDebugInfo("dist_arr.shape " + str(dist_arr.shape))
        # self.feedback.pushDebugInfo("array.shape " + str(array.shape))
        res = np.sum(dist_arr * array)
        return res        
        
    def processAlgorithm(self,parameters,context,feedback):
        self.parseParams(parameters,context,feedback)
        self.prepareWindow(feedback)
        # Retrieve classes and array
        classes, self.array, self.inNodata = qgsUtils.getRasterValsArrayND(
            str(self.input_path))
        self.classes = self.prepareClasses(classes,feedback)
        # Compute patch size
        self.preparedArr = self.prepareArray(context,feedback).astype(np.float32)
        # Redistrib quantile
        self.processDistrib(feedback)
        # Agregation
        res_arr = ndimage.generic_filter(self.preparedArr,
            self.filter_func2,footprint=self.footprint,
            mode="constant",cval=0)
        res_arr = self.processFinal(res_arr)
        return self.processOutput(res_arr,feedback)


class ConnexityIndex(IndexAlgorithm,SlidingWindowCircle):
    
    ALG_NAME = 'connexityIndex'
    INDEX = 'INDEX'
    
    def initAlgorithm(self, config=None):
        super().initAlgorithm(classesParam=True,quantParam=True,finalFuncParam=True)
        
    def displayName(self):
        return self.tr("Connexity index")
        
    def shortHelpString(self):
        return self.tr("Surface index (sliding window distribution)")
    
    # def initAlgorithm(self, classesParam=True, quant=False,
            # funcs=True, config=None, report_opt=True):
        # super().initAlgorithm(finalFuncParam=True)
                
    def filter_func(self,array):
        dist_arr = self.dist_rate_arr_flatten[array==self.currVal]
        # dist_arr *= self.currQuant
        if dist_arr.size == 0:
            res = math.nan
        else:
            res = np.nansum(dist_arr) * self.currQuant
            # res = np.nansum(dist_arr) + self.currQuant
        # res += self.currQuant
        return res
        
    def processAlgorithm(self,parameters,context,feedback):
        self.parseParams(parameters,context,feedback)
        self.prepareWindow(feedback)
        # Retrieve classes and array
        classes, self.array, self.inNodata = qgsUtils.getRasterValsArrayND(
            str(self.input_path))
        self.classes = self.prepareClasses(classes,feedback)
        self.currQuant = 1
        tmp_arr = self.array.astype(np.float32)
        curr_arr = np.zeros(self.array.shape)
        for c in self.classes:
            self.currVal = c
            # tmp_arr[self.array == c] += self.currQuant
            arr_c = ndimage.generic_filter(tmp_arr,
                self.filter_func,footprint=self.footprint,
                mode="constant",cval=math.nan)
            self.currQuant = np.nanquantile(arr_c,self.quantile)
            arr_c[np.isnan(arr_c)] = 0
            self.debugRaster(feedback,arr_c,self.input_path,"connex" + str(c),
                nodata=-1,type=gdal.GDT_Float32)
            curr_arr += arr_c
            # self.currQuant = np.nanquantile(curr_arr,self.quantile)
            self.pushDebug("currQuant = " + str(self.currQuant))
        # self.preparedArr = curr_arr
        # self.processDistrib(feedback)
        # res_arr = self.processFinal(self.preparedArr)
        return self.processOutput(curr_arr,feedback)
        
class ConnectivityIndexSimplified(IndexAlgorithm,SlidingWindowCircle):
    
    ALG_NAME = 'connexityIndexSimplified'
    INDEX = 'INDEX'
    
    def initAlgorithm(self, config=None):
        super().initAlgorithm(classesParam=True,#redistribParams=True,
            distModeCoeffParam=True,finalFuncParam=True)
        
    def displayName(self):
        return self.tr("Connectivity index (simplified)")
        
    def shortHelpString(self):
        return self.tr("Connectivity index simplified based on favorability.")
                
    def filter_func(self,array):
        dist_arr = self.dist_arr[array==self.currVal]
        dist_arr += self.currQuant
        if dist_arr.size == 0:
            res = math.nan
        else:
            res = np.nansum(dist_arr)
        return res       
        
    def filter_func2(self,array):
        dist_arr = self.dist_arr[array==self.currVal]
        # dist_arr += self.currQuant
        if dist_arr.size == 0:
            res = math.nan
        else:
            res = np.nansum(dist_arr) * self.currQuant
        return res
        
    def processAlgorithm(self,parameters,context,feedback):
        self.parseParams(parameters,context,feedback)
        self.prepareWindow(feedback)
        # Retrieve classes and array
        classes, self.array, self.inNodata = qgsUtils.getRasterValsArrayND(
            str(self.input_path))
        self.classes = self.prepareClasses(classes,feedback)
        nb_classes = len(self.classes)
        self.currQuant = 0
        tmp_arr = self.array.astype(np.float32)
        curr_arr = np.zeros(self.array.shape)
        self.redistribVal = self.size
        for c in self.classes:
            self.currVal = c
            # tmp_arr[self.array == c] += self.currQuant
            arr_c = ndimage.generic_filter(tmp_arr,
                self.filter_func,footprint=self.footprint,
                mode="constant",cval=math.nan)
            self.currQuant += self.redistribVal
            arr_c[np.isnan(arr_c)] = 0
            self.debugRaster(feedback,arr_c,self.input_path,"connex" + str(c),
                nodata=0,type=gdal.GDT_Float32)
            curr_arr += arr_c
            self.pushDebug("currQuant = " + str(self.currQuant))
        minVal = np.nansum(self.dist_arr)
        maxVal = np.nansum(self.dist_arr + ((nb_classes-1) * self.redistribVal))
        curr_arr = self.processFinal(curr_arr)
        return self.processOutput(curr_arr,feedback)
        
        
        
class ConnectivityIndexSimplified2(ConnectivityIndexSimplified):
    
    ALG_NAME = 'connexityIndexSimplified2'
    INDEX = 'INDEX'
        
    def displayName(self):
        return self.tr("Connectivity index (simplified) 2")
        
    def shortHelpString(self):
        return self.tr("Connectivity index simplified based on favorability.")
                
    def filter_func(self,array):
        dist_arr = self.dist_arr[array==self.currVal]
        dist_arr += self.currQuant
        if dist_arr.size == 0:
            res = math.nan
        else:
            res = np.nansum(dist_arr)
        return res
        
    def filter_func2(self,array):
        dist_arr = self.dist_arr[array==self.currVal]
        # dist_arr += self.currQuant
        if dist_arr.size == 0:
            res = math.nan
        else:
            res = np.nansum(dist_arr) * self.currQuant
        return res
        
    def processAlgorithm(self,parameters,context,feedback):
        self.parseParams(parameters,context,feedback)
        self.prepareWindow(feedback)
        # Retrieve classes and array
        classes, self.array, self.inNodata = qgsUtils.getRasterValsArrayND(
            str(self.input_path))
        self.classes = self.prepareClasses(classes,feedback)
        self.currQuant = 0
        tmp_arr = self.array.astype(np.float32)
        curr_arr = np.zeros(self.array.shape)
        for c in self.classes:
            self.currVal = c
            # tmp_arr[self.array == c] += self.currQuant
            arr_c = ndimage.generic_filter(tmp_arr,
                self.filter_func2,footprint=self.footprint,
                mode="constant",cval=math.nan)
            self.currQuant += self.redistribVal
            arr_c[np.isnan(arr_c)] = 0
            self.debugRaster(feedback,arr_c,self.input_path,"connex" + str(c),
                nodata=0,type=gdal.GDT_Float32)
            curr_arr += arr_c
            self.pushDebug("currQuant = " + str(self.currQuant))
        curr_arr = self.processFinal(curr_arr)
        return self.processOutput(curr_arr,feedback)
        
        
class IsolationIndex(IndexAlgorithm,SlidingWindowCircle):
    
    ALG_NAME = 'isolationIndex'
    
    DIST_MODE = 'DIST_MODE'
    
    def initAlgorithm(self, config=None):
        super().initAlgorithm(classesParam=True,quantParam=True,
            distModeCoeffParam=True,finalFuncParam=True)
        
    def parseParams(self,parameters,context,feedback):
        super().parseParams(parameters,context,feedback)
        self.dist_mode = self.parameterAsEnum(parameters,self.DIST_MODE,context)
        
    def displayName(self):
        return self.tr("Isolation index")
        
    def shortHelpString(self):
        return self.tr("Isolation index (habitat class)")
                
    def filter_func(self,array):
        dist_arr = self.dist_arr_exp[array==self.currVal]
        if dist_arr.size == 0:
            res = math.nan
        else:
            res = np.nansum(dist_arr)
        return res
        
    def prepare_patchWinSq(self,array):
        vals, counts = np.unique(array[array!=self.ignore], return_counts=True)
        # counts *= self.currQuant
        sq_arr = np.power(counts,2)
        sq_arr *= int(self.currQuant)
        # if counts.size > 0:
            # for c in counts:
                # self.distances.append(c)
        # counts += self.currQuant
        # sq_arr = np.power(counts,2)
        return (vals, sq_arr)
        
    def filter_func_patchWinSq_distMinExp(self,array):
        vals, sq_arr = self.prepare_patchWinSq(array)
        res = 0
        for v, count in zip(vals, sq_arr):
            min = np.amin(self.dist_array_flatten[array==v]) + 1
            res += math.exp(-min)*count
        return res
        
    def filter_func_patchWinSq_distMinRate(self,array):
        vals, sq_arr = self.prepare_patchWinSq(array)
        res = 0
        for v, count in zip(vals, sq_arr):
            min = np.amin(self.dist_array_flatten[array==v])
            res += ((self.size - min) / self.size) * count
        return res
        
    def processAlgorithm(self,parameters,context,feedback):
        self.parseParams(parameters,context,feedback)
        self.prepareWindow(feedback)
        # Retrieve classes and array
        classes, self.array, self.inNodata = qgsUtils.getRasterValsArrayND(
            str(self.input_path))
        self.classes = self.prepareClasses(classes,feedback)
        # self.classes.reverse()
        # lastClass = self.classes[-1]
        # Label
        struct = scipy.ndimage.generate_binary_structure(2,2)
        labeled_array, nb_patches = scipy.ndimage.label(self.array,struct)
        feedback.pushDebugInfo("labeled_array type = " + str(labeled_array.dtype))
        # Filter
        self.ignore = 0
        acc_arr = np.zeros(labeled_array.shape)
        self.currQuant = 1.0
        # for c in reversed(self.classes):
        for c in self.classes:
            feedback.pushDebugInfo("Current class = " + str(c))
            tmp_arr = np.copy(labeled_array)
            tmp_arr[self.array!=c] = self.ignore
            feedback.pushDebugInfo("labeled_array type = " + str(labeled_array.dtype))
            self.distances = []
            if self.dist_mode == 0:
                arr_c = ndimage.generic_filter(tmp_arr,
                    self.filter_func_patchWinSq_distMinRate,footprint=self.footprint,
                    mode="constant",cval=0,output=np.float32)
            elif self.dist_mode:
                arr_c = ndimage.generic_filter(tmp_arr,
                    self.filter_func_patchWinSq_distMinExp,footprint=self.footprint,
                    mode="constant",cval=0,output=np.float32)
            else:
                assert(False)
            self.debugRaster(feedback,arr_c,self.input_path,"arr" + str(c),
                nodata=self.ignore,type=gdal.GDT_Float32)
            arr_c[self.array==self.input_nodata] = math.nan
            acc_arr += arr_c
            arr_c[arr_c==0] = math.nan
            quant = np.nanquantile(arr_c,q=self.quantile)
            # quant = 1
            feedback.pushDebugInfo("quant = " + str(quant))
            # arr_c[arr_c != 0] += self.currQuant
            self.debugRaster(feedback,acc_arr,self.input_path,"acc_arr" + str(c),
                nodata=-1,type=gdal.GDT_Float32)
            # feedback.pushDebugInfo("distances = " + str(self.distances))
            # quant = np.quantile(self.distances,q=self.quantile)
            # quant = np.nanquantile(self.distances,q=1)
            # feedback.pushDebugInfo("quant = " + str(quant))
            if quant > 0:
                # self.currQuant += math.log(quant)
                # self.currQuant += int(quant)
                self.currQuant += quant
            feedback.pushDebugInfo("currQuant = " + str(self.currQuant))
        acc_arr = self.processFinal(acc_arr)
        return self.processOutput(acc_arr,feedback)

class IsolationIndex2(IndexAlgorithm,SlidingWindowCircle):
    
    ALG_NAME = 'isolationIndex2'
    
    def initAlgorithm(self, config=None):
        super().initAlgorithm(classesParam=True,quantParam=True,finalFuncParam=True)
        
    def displayName(self):
        return self.tr("Isolation index 2")
        
    def shortHelpString(self):
        return self.tr("Isolation index (habitat class)")
    
    # def initAlgorithm(self, classesParam=True, quant=False,
            # funcs=True, config=None, report_opt=True):
        # super().initAlgorithm(finalFuncParam=True)
                
    def filter_func(self,array):
        dist_arr = self.dist_arr_exp[array==self.currVal]
        if dist_arr.size == 0:
            res = math.nan
        else:
            res = np.nansum(dist_arr)
        return res
        
    def filter_func2(self,array):
        vals, counts = np.unique(array[array!=self.ignore], return_counts=True)
        counts = counts.astype(float) + self.currQuant
        sq_arr = np.power(counts,2)
        res = 0
        for v, count in zip(vals, counts):
            # min = np.amin(self.dist_array_flatten[array==v]) + 1
            med = np.nanquantile(self.dist_array_flatten[array==v],0.5)
            res += math.exp(-med)*count
        return res
        # nb_vals = np.count_nonzero(array[array == self.currVal])
        # dist_arr = self.dist_arr_exp[array==self.currVal]
        # if dist_arr.size == 0:
            # res = math.nan
        # else:
            # res = np.nansum(dist_arr)
        # return res
        
    def processAlgorithm(self,parameters,context,feedback):
        self.parseParams(parameters,context,feedback)
        self.prepareWindow(feedback)
        # Retrieve classes and array
        classes, self.array, self.inNodata = qgsUtils.getRasterValsArrayND(
            str(self.input_path))
        self.classes = self.prepareClasses(classes,feedback)
        # self.classes.reverse()
        # lastClass = self.classes[-1]
        # Label
        struct = scipy.ndimage.generate_binary_structure(2,2)
        labeled_array, nb_patches = scipy.ndimage.label(self.array,struct)
        feedback.pushDebugInfo("labeled_array type = " + str(labeled_array.dtype))
        # Filter
        self.ignore = -1
        acc_arr = np.zeros(labeled_array.shape)
        self.currQuant = 0
        quantStep = self.quantile * self.size * self.size * math.pi
        feedback.pushDebugInfo("quantStep = " + str(quantStep))
        for c in self.classes:
            feedback.pushDebugInfo("Current class = " + str(c))
            tmp_arr = np.copy(labeled_array)
            tmp_arr[self.array!=c] = self.ignore
            feedback.pushDebugInfo("labeled_array type = " + str(labeled_array.dtype))
            self.distances = []
            arr_c = ndimage.generic_filter(tmp_arr,
                self.filter_func2,footprint=self.footprint,
                mode="constant",cval=0,output=np.float32)
            self.debugRaster(feedback,arr_c,self.input_path,"arr" + str(c),
                nodata=-1,type=gdal.GDT_Float32)
            acc_arr += arr_c
            self.currQuant += quantStep
        return self.processOutput(acc_arr,feedback)

class IsolationIndex3(IndexAlgorithm,SlidingWindowCircle):
    
    ALG_NAME = 'isolationIndex3'
    
    def initAlgorithm(self, config=None):
        super().initAlgorithm(classesParam=True,quantParam=True,
            addFuncParam=True,finalFuncParam=True)
        
    def displayName(self):
        return self.tr("Isolation index 2")
        
    def shortHelpString(self):
        return self.tr("Isolation index (habitat class)")
    
    # def initAlgorithm(self, classesParam=True, quant=False,
            # funcs=True, config=None, report_opt=True):
        # super().initAlgorithm(finalFuncParam=True)
                
    def filter_func(self,array):
        dist_arr = self.dist_arr_exp[array==self.currVal]
        if dist_arr.size == 0:
            res = math.nan
        else:
            res = np.nansum(dist_arr)
        return res
        
    def filter_func2(self,array):
        vals, counts = np.unique(array[array!=self.ignore], return_counts=True)
        counts = counts.astype(float) + self.currQuant
        sq_arr = np.power(counts,2)
        res = 0
        for v, count in zip(vals, counts):
            # min = np.amin(self.dist_array_flatten[array==v]) + 1
            med = np.nanquantile(self.dist_array_flatten[array==v],0.5)
            res += math.exp(-med)*count
        return res
        # nb_vals = np.count_nonzero(array[array == self.currVal])
        # dist_arr = self.dist_arr_exp[array==self.currVal]
        # if dist_arr.size == 0:
            # res = math.nan
        # else:
            # res = np.nansum(dist_arr)
        # return res
        
    def filter_func3(self,array):
        array *= self.dist_rate_arr_flatten
        return np.nansum (array)
        
    def prepare_patchWinSq(self,array):
        vals, counts = np.unique(array[array!=self.ignore], return_counts=True)
        # counts *= self.currQuant
        sq_arr = np.power(counts,2)
        # sq_arr *= int(self.currQuant)
        # if counts.size > 0:
            # for c in counts:
                # self.distances.append(c)
        # counts += self.currQuant
        # sq_arr = np.power(counts,2)
        return (vals, sq_arr)
        
    def filter_func_patchWinSq_distMinExp(self,array):
        vals, sq_arr = self.prepare_patchWinSq(array)
        res = 0
        for v, count in zip(vals, sq_arr):
            min = np.amin(self.dist_array_flatten[array==v]) + 1
            res += math.exp(-min)*count
        return res
        
    def filter_func_patchWinSq_distMinRate(self,array):
        vals, sq_arr = self.prepare_patchWinSq(array)
        res = 0
        for v, count in zip(vals, sq_arr):
            min = np.amin(self.dist_array_flatten[array==v])
            res += ((self.size - min) / self.size) * count
        return res
        
    def preparePatchSize(self,context,feedback):
        size_path = self.mkTmpPath("patchSize.tif")
        size_params = { PatchAreaWindow.INPUT : self.input,
            PatchAreaWindow.WINDOW_SIZE : self.size,
            PatchAreaWindow.OUTPUT : size_path }
        processing.run("BioDispersal:" + PatchAreaWindow.ALG_NAME,
            size_params,context=context,feedback=feedback)
        size_classes, size_arr = qgsUtils.getRasterValsAndArray(size_path)
        return size_arr
        
    def processAlgorithm(self,parameters,context,feedback):
        self.parseParams(parameters,context,feedback)
        self.prepareWindow(feedback)
        # Retrieve classes and array
        classes, self.array, self.inNodata = qgsUtils.getRasterValsArrayND(
            str(self.input_path))
        self.classes = self.prepareClasses(classes,feedback)
        # self.classes.reverse()
        # lastClass = self.classes[-1]
        acc_arr = self.preparePatchSize(context,feedback).astype(np.float32)
        size_arr = np.copy(acc_arr)
        self.debugRaster(feedback,acc_arr,self.input_path,"size",
            nodata=-1,type=gdal.GDT_Float32)
        self.processDistrib(feedback,arr=acc_arr)
        self.debugRaster(feedback,acc_arr,self.input_path,"distrib1",
            nodata=-1,type=gdal.GDT_Float32)
        size_arr[size_arr==0] = math.nan
        # tmp_path = self.mkTmpPath("divide.tif")
        # qgsTreatments.applyRasterCalcAB()
        # new_arr = np.floor_divide(distrib_arr,size_arr)
        acc_arr /= size_arr
        # distrib2_path = 
        self.debugRaster(feedback,acc_arr,self.input_path,"distrib2",
            nodata=-1,type=gdal.GDT_Float32)
        self.ignore = self.inNodata
        res_arr = ndimage.generic_filter(acc_arr,
            self.filter_func3,footprint=self.footprint,
            mode="constant",cval=0,output=np.float32)
        res_arr = self.processFinal(res_arr)
        # res_arr = acc_arr
        return self.processOutput(res_arr,feedback)

class ConnectivityIndex(IndexAlgorithm,SlidingWindowCircle):
    
    ALG_NAME = 'connectivityIndex'
    
    COEFF_MODE = 'COEFF_MODE'
    EXPONENT = 'EXPONENT'
          
    def displayName(self):
        return self.tr("Connectivity index")
        
    def shortHelpString(self):
        msg = "Connectivity index inspired from Hanski incidence function model."
        msg += ""
        return self.tr(msg)
    
    def initAlgorithm(self, config=None):
        super().initAlgorithm(classParam=True,distModeParam=True,
            distModeCoeffParam=True,finalFuncParam=True)
        
    def addAdvancedParams(self):
        exponentParam = QgsProcessingParameterNumber(
            self.EXPONENT,
            description = self.tr('Patch size exponent'),
            type=QgsProcessingParameterNumber.Integer,
            defaultValue=2)
        self.addAdvancedParam(exponentParam)
        super().addAdvancedParams()
        
    def parseParams(self,parameters,context,feedback):
        super().parseParams(parameters,context,feedback)
        self.exponent = self.parameterAsInt(parameters,self.EXPONENT,context)
    
    def prepare_patchWinSq(self,array):
        vals, counts = np.unique(array[array!=self.ignore], return_counts=True)
        sq_arr = np.power(counts,self.exponent)
        return (vals, sq_arr)
      
    def filter_func(self,array):
        vals, counts = np.unique(array[array!=self.ignore], return_counts=True)
        counts = counts.astype(float)
        sq_arr = np.power(counts,self.exponent)
        res = 0
        for v, count in zip(vals, counts):
            dist = self.distFunc(array,v)
            res += self.coeffFunc(dist)*count
        return res
        
    # def filter_func2(self,array):
        # vals, counts = np.unique(array[array!=self.ignore], return_counts=True)
        # counts = counts.astype(float)
        # counts = np.power(counts,2)
        # res = 0
        # for v, count in zip(vals, counts):
            # dist = self.distFunc(array,v)
            # res += self.expFunc(dist)*count
        # return res
        
    def processAlgorithm(self,parameters,context,feedback):
        self.parseParams(parameters,context,feedback)
        self.prepareWindow(feedback)
        # self.currVal = self.classParam
        # Retrieve classes and array
        classes, self.array, self.inNodata = qgsUtils.getRasterValsArrayND(
            str(self.input_path))
        # Label
        tmp_arr = np.zeros(self.array.shape)
        tmp_arr[self.array==self.classParam] = 1
        tmp_arr[self.array!=self.classParam] = 0
        struct = ndimage.generate_binary_structure(2,1)
        labeled_array, nb_patches = ndimage.label(tmp_arr,struct)
        feedback.pushDebugInfo("label ok")
        self.ignore = 0
        self.debugRaster(feedback,labeled_array,self.input_path,"labeled",
            nodata=0,type=gdal.GDT_Float32)
        res_arr = ndimage.generic_filter(labeled_array,
            self.filter_func,footprint=self.footprint,
            mode="constant",cval=0,output=np.float32)
        res_arr[self.array==self.inNodata] = self.out_nodata
        minVal = np.sum(self.dist_arr)
        maxVal = self.coeffFunc(0) * pow(self.nbPixDist,self.exponent)
        res_arr = self.processFinal(res_arr)
        res_arr[res_arr==0] = self.out_nodata
        return self.processOutput(res_arr,feedback)

    # def postProcessAlgorithm(self, context, feedback):
        # out_layer = self.out_layer#qgsUtils.loadRasterLayer(output)
        # color_ramp = styles.mkColorRamp('Plasma')
        # shader = styles.mkRasterShader(out_layer,color_ramp)
        # styles.setSBPCRasterRenderer(out_layer,shader)
        # out_layer.triggerRepaint()
        # return { self.OUTPUT : self.out_layer }

class ConnectivityIndexRedistrib(ConnectivityIndex):
    
    ALG_NAME = 'connectivityIndexRedistrib'
    def displayName(self):
        return self.tr("Connectivity index (redistrib)")
        
    def initAlgorithm(self, config=None):
        SlidingWindowCircle.initAlgorithm(self,classesParam=True,quantParam=True,finalFuncParam=True)
     
    def filter_func(self,array):
        vals, counts = np.unique(array[array!=self.ignore], return_counts=True)
        counts = counts.astype(float)
        if self.patchSizeMode:
            counts = [ self.patchSize[v] for v in vals ]
        counts = np.power(counts,self.exponent)
        res = 0
        for v, count in zip(vals, counts):
            dist = self.distFunc(array,v)
            v_fav = self.patch_size[v]
            # v_size = self.patch_size[v]
            fav_quant = self.fav_quant[v_fav]
            res += self.coeffFunc(dist)*(count*fav_quant)
        return res
     
    # def filter_func2(self,array):
        # vals, counts = np.unique(array[array!=self.ignore], return_counts=True)
        # counts = counts.astype(float)
        # sq_arr = np.power(counts,2)
        # res = 0
        # for v, count in zip(vals, counts):
            # v_fav = self.patch_size[v]
            # fav_quant = self.fav_quant[v_fav]
            # dist = self.distFunc(array,v + fav_quant)
            # res += self.expFunc(dist)*count
        # return res
     
    def processAlgorithm(self,parameters,context,feedback):
        self.parseParams(parameters,context,feedback)
        self.prepareWindow(feedback)
        # self.currVal = self.classParam
        # Retrieve classes and array
        classes, self.array, self.inNodata = qgsUtils.getRasterValsArrayND(
            str(self.input_path))
        self.classes = self.prepareClasses(classes,feedback)
        self.patchSizeMode = True
        # self.classes.reverse()
        # Label
        struct = scipy.ndimage.generate_binary_structure(2,1)
        class_array = np.copy(self.array)
        prev_nb_patches = 0
        currQuant = 1.0
        self.patch_fav = {}
        self.patch_size = {}
        self.fav_quant = {}
        labeled_array = np.zeros(self.array.shape)
        for count, c in enumerate(self.classes,start=1):
            class_array[self.array==c] = 1
            class_array[self.array!=c] = 0
            lbl_arr_c, nb_patches = ndimage.label(class_array,struct)
            lbl_arr_c[self.array==c] += prev_nb_patches
            tmp_path = self.mkTmpPath("labeled_" + str(c) + ".tif")
            labeled_array = np.add(labeled_array,lbl_arr_c)
            labels, lbl_counts = np.unique(lbl_arr_c, return_counts=True)
            for lbl in labels:
                self.patch_fav[lbl] = c
                self.patch_size[lbl] = lbl_counts
            prev_nb_patches += nb_patches
            # q = np.quantile(lbl_counts,self.quantile)
            self.fav_quant[c] = currQuant
            lastQuant = currQuant
            # self.fav_quant[c] = np.power(currQuant,self.exponent)
            currQuant += self.quantile
        # self.fav_quant = { k : v / lastQuant for k, v in self.fav_quant.items() }
        feedback.pushDebugInfo("self.patch_fav = " + str(self.patch_fav))
        feedback.pushDebugInfo("self.fav_quant = " + str(self.fav_quant))
        feedback.pushDebugInfo("label ok")
        self.debugRaster(feedback,labeled_array,self.input_path,"labeled",
            nodata=0,type=gdal.GDT_Float32)
        # Process filter
        self.ignore = 0
        res_arr = ndimage.generic_filter(labeled_array,
            self.filter_func,footprint=self.footprint,
            mode="constant",cval=0,output=np.float32)
        res_arr[self.array==self.inNodata] = self.out_nodata
        res_arr[res_arr==0] = self.out_nodata
        res_arr = self.processFinal(res_arr)
        return self.processOutput(res_arr,feedback)
        

class NbContactDistrib(SlidingWindowCircle):

    ALG_NAME = 'NbContactDistrib'
    
    ADD_FUNC = 'ADD_FUNC'
    ADD_FUNC_NAMES = ['sum','nansum','nanmean']
    add_funcs = [np.sum,np.nansum,np.nanmean]
    
    def initAlgorithm(self, report_opt=True):
        SlidingWindowCircle.initAlgorithm(self,classesParam=True)
        self.addParameter(
            QgsProcessingParameterEnum(
                self.ADD_FUNC,
                description = self.tr('Filter function'),
                options=self.ADD_FUNC_NAMES,
                defaultValue=0))
        
    def displayName(self):
        return self.tr("Number of contacts (Distrib)")
        
    def shortHelpString(self):
        return self.tr("Computes connexity index based on favoarbility classes and the number of contacts (adjacent pixels of same value) inside specified sliding window")
        
    def processAlgorithm(self,parameters,context,feedback):
        self.parseParams(parameters,context,feedback)
        func_mode = self.parameterAsEnum(parameters,self.ADD_FUNC,context)
        feedback.pushDebugInfo("func_mode = " + str(func_mode))
        filter_func = self.add_funcs[func_mode]
        # neutralElem = math.nan if func_mode == 2 else 0
        self.prepareWindow(feedback)
        # Retrieve classes and array
        classes, array, input_nodata = qgsUtils.getRasterValsArrayND(str(self.input_path))
        ncount_struct = ndimage.generate_binary_structure(2,1)
        classes = self.prepareClasses(classes,feedback)
        nb_neighbours_arr = ndimage.generic_filter(array,
            self.count_neighbours_4,footprint=ncount_struct,
            mode="constant",cval=self.nodata)
        feedback.pushDebugInfo("nb_neighbours_arr shape = " + str(nb_neighbours_arr.shape))
        if self.DEBUG:
            self.feedback.pushDebugInfo("array = " + str(array))
            feedback.pushDebugInfo("nb_neighbours_arr = " + str(nb_neighbours_arr))
        # Process distrb
        acc_arr = np.zeros(array.shape)
        curr_q3 = 0
        nb_vals = len(classes)
        feedback.pushDebugInfo("nb_vals = " + str(nb_vals))
        neutralElem = 0
        feedback.pushDebugInfo("neutralElem = " + str(neutralElem))
        for cpt, c in enumerate(classes,start=1):
            feedback.pushDebugInfo("class = " + str(c))
            feedback.pushDebugInfo("cpt = " + str(cpt))
            tmp_arr = nb_neighbours_arr.astype(np.float32)
            tmp_arr[array != c] = neutralElem
            tmp_arr[array==input_nodata] = math.nan
            feedback.pushDebugInfo("tmp_arr.dtype = " + str(tmp_arr.dtype))
            if self.DEBUG:
                feedback.pushDebugInfo("tmp_arr = " + str(tmp_arr))
                tmp_path = QgsProcessingUtils.generateTempFilename("tmp_" + str(c) + ".tif")
                feedback.pushDebugInfo("tmp_path = " + str(tmp_path))
                qgsUtils.exportRaster(tmp_arr,self.input_path,tmp_path,
                    nodata=0,type=gdal.GDT_Float32)
            if func_mode == 0:
                assert(False)
                computed_arr = tmp_arr.astype(np.float32)
                # computed_arr = ndimage.generic_filter(tmp_arr,
                    # filter_func,footprint=self.footprint,
                    # mode="constant",cval=math.nan,output=np.float32)
            else:
                computed_arr = ndimage.generic_filter(tmp_arr,
                    filter_func,footprint=self.footprint,
                    mode="constant",cval=math.nan,output=np.float32)
            # computed_arr = ndimage.generic_filter(tmp_arr,
                # self.add_func,footprint=self.footprint,
                # mode='nearest',output=np.float32)
            if self.DEBUG:
                feedback.pushDebugInfo("computed_arr = " + str(computed_arr))
                feedback.pushDebugInfo("computed_arr.dtype = " + str(computed_arr.dtype))
                computed_c_path = QgsProcessingUtils.generateTempFilename(
                    "computed_" + str(c) + ".tif")
                feedback.pushDebugInfo("computed_c_path = " + str(computed_c_path))
                qgsUtils.exportRaster(computed_arr,self.input_path,computed_c_path,
                    nodata=0,type=gdal.GDT_Float32)
            if cpt > 1:
                computed_arr = np.add(computed_arr,curr_q3)
            if cpt == nb_vals:
                #et donc si computed = 0 ???
                # Comment 0 possible avec curr_q3 ?
                acc_arr /= computed_arr
            else:
                computed_arr[array==input_nodata] = math.nan
                # computed_arr[array==input_nodata] = neutralElem
                curr_q3 = np.nanquantile(computed_arr,q=0.75)
                feedback.pushDebugInfo("curr_q3 = " + str(curr_q3))
                computed_arr[array==input_nodata] = neutralElem
                acc_arr += computed_arr
            if self.DEBUG:
                acc_path = QgsProcessingUtils.generateTempFilename("acc_" + str(c) + ".tif")
                feedback.pushDebugInfo("acc_path = " + str(acc_path))
                qgsUtils.exportRaster(acc_arr,self.input_path,acc_path,
                    nodata=self.out_nodata,type=gdal.GDT_Float32)
                feedback.pushDebugInfo("acc_arr = " + str(acc_arr))
        # Output
        feedback.pushDebugInfo("out_nodata = " + str(self.out_nodata))
        acc_arr[array==input_nodata] = self.out_nodata
        feedback.pushDebugInfo("acc_arr = " + str(acc_arr))
        qgsUtils.exportRaster(acc_arr,self.input_path,self.output,
            nodata=self.out_nodata,type=gdal.GDT_Float32)
        return { self.OUTPUT_FILE : self.output }
    
    def filter_func_sum(self,array):
        # if self.DEBUG:
            # self.feedback.pushDebugInfo("arrayFilt = " + str(array))
        return np.nansum(array)
    def filter_func_mean(self,array):
        # if self.DEBUG:
            # self.feedback.pushDebugInfo("arrayFilt = " + str(array))
        return np.nanmean(array)
                
    def count_neighbours_4(self,array):
        cell_val = array[2]
        return np.count_nonzero(array == cell_val) - 1

 
class PatchSizeDistrib(SlidingWindowCircle):

    ALG_NAME = 'PatchSizeDistrib'
    
    def initAlgorithm(self, report_opt=True):
        SlidingWindowCircle.initAlgorithm(self,classesParam=True)
        
    def displayName(self):
        return self.tr("Patch size (Distrib)")
        
    def shortHelpString(self):
        return self.tr("Computes connexity index based on favoarbility classes and patch median inside specified sliding window")
        
    def prepareArray(self,context,feedback):
        median_path = self.mkTmpPath("median.tif")
        median_params = { PatchAreaWindow.INPUT : self.input,
            PatchAreaWindow.WINDOW_SIZE : self.size,
            PatchAreaWindow.OUTPUT : median_path }
        processing.run("BioDispersal:" + PatchAreaWindow.ALG_NAME,
            median_params,context=context,feedback=feedback)
        median_classes, median_arr = qgsUtils.getRasterValsAndArray(median_path)
        return median_arr
        
    def processAlgorithmHidden(self,parameters,context,feedback):
        self.parseParams(parameters,context,feedback)
        # neutralElem = math.nan if func_mode == 2 else 0
        self.prepareWindow(feedback)
        self.quantile = 1
        # Retrieve classes and array
        classes, array, input_nodata = qgsUtils.getRasterValsArrayND(str(self.input_path))
        ncount_struct = ndimage.generate_binary_structure(2,1)
        classes = self.prepareClasses(classes,feedback,firstToEnd=False)
        # PatchAreaWindow
        median_path = self.mkTmpPath("median.tif")
        median_params = { PatchAreaWindow.INPUT : self.input,
            PatchAreaWindow.WINDOW_SIZE : self.size,
            PatchAreaWindow.OUTPUT : median_path }
        processing.run("BioDispersal:" + PatchAreaWindow.ALG_NAME,
            median_params,context=context,feedback=feedback)
        median_classes, median_arr = qgsUtils.getRasterValsAndArray(median_path)
        median_arr = median_arr.astype(np.float32)
        median_arr[array==input_nodata] = math.nan
        self.debugRaster(feedback,median_arr,self.input_path,"median1",
            nodata=-1,type=gdal.GDT_Float32)
        quants = {}
        for c in classes:
            q = np.nanquantile(median_arr[array==c],q=quantile)
            quants[c] = q
        feedback.pushDebugInfo("quants = " + str(quants))
        median_arr[array==input_nodata] = 0
        acc_q = 0
        for c in classes:
            acc_q += quants[c]
            feedback.pushDebugInfo("acc_q = " + str(acc_q))
            median_arr[array==c] += acc_q
        self.debugRaster(feedback,median_arr,self.input_path,"median2",
            nodata=-1,type=gdal.GDT_Float32)
        # TODO
        median_arr[array==input_nodata] = self.filter_neutral
        res_arr = ndimage.generic_filter(median_arr,
            self.add_func,footprint=self.footprint,
            mode="constant",cval=self.filter_neutral)
        # Output
        feedback.pushDebugInfo("out_nodata = " + str(self.out_nodata))
        res_arr[array==input_nodata] = self.out_nodata
        qgsUtils.exportRaster(res_arr,self.input_path,self.output,
            nodata=self.out_nodata,type=gdal.GDT_Float32)
        return { self.OUTPUT_FILE : self.output }
    
    def count_neighbours_4(self,array):
        cell_val = array[2]
        return np.count_nonzero(array == cell_val) - 1
 
class NbContactMedianDistrib(NbContactDistrib):

    ALG_NAME = 'NbContactMedianDistrib'
        
    def displayName(self):
        return self.tr("Number of contacts x Median distance (distrib)")
        
    def shortHelpString(self):
        return self.tr("Computes connexity index")    
        
    def filter_median(self,array):
        # self.pushDebug("array = " + str(array))
        # self.pushDebug("cell_val = " + str(self.currVal))
        dist_val = self.dist_array_flatten[array==self.currVal]
        # self.pushDebug("dist_val = " + str(dist_val))
        val_median = np.nanmedian(dist_val)
        # res = self.size if math.isnan(val_median) else self.size - val_median
        # return res
        return val_median
        
    def filter_nbContact_distance(self,array):
        div_arr = (array[array != self.neutralElem] * 3) / self.dist_array_flatten[array != self.neutralElem]
        # self.pushDebug(str(div_arr))
        return self.add_func(div_arr)

    def processAlgorithm(self,parameters,context,feedback):
        self.parseParams(parameters,context,feedback)
        func_mode = self.parameterAsEnum(parameters,self.ADD_FUNC,context)
        self.add_func = self.add_funcs[func_mode]
        # neutralElem = math.nan if func_mode == 2 else 0
        self.prepareWindow(feedback)
        # Retrieve classes and array
        classes, array, input_nodata = qgsUtils.getRasterValsArrayND(str(self.input_path))
        ncount_struct = ndimage.generate_binary_structure(2,1)
        classes = self.prepareClasses(classes,feedback)
        nb_neighbours_arr = ndimage.generic_filter(array,
            self.count_neighbours_4,footprint=ncount_struct,
            mode="constant",cval=self.nodata)
        feedback.pushDebugInfo("nb_neighbours_arr shape = " + str(nb_neighbours_arr.shape))
        if self.DEBUG:
            self.feedback.pushDebugInfo("array = " + str(array))
            feedback.pushDebugInfo("nb_neighbours_arr = " + str(nb_neighbours_arr))
        # Process distrb
        acc_arr = np.zeros(array.shape)
        curr_q3 = 0
        nb_vals = len(classes)
        feedback.pushDebugInfo("nb_vals = " + str(nb_vals))
        neutralElem = 0
        self.neutralElem = neutralElem
        feedback.pushDebugInfo("neutralElem = " + str(neutralElem))
        for cpt, c in enumerate(classes,start=1):
            feedback.pushDebugInfo("class = " + str(c))
            feedback.pushDebugInfo("cpt = " + str(cpt))
            self.currVal = c
            tmp_arr = nb_neighbours_arr.astype(np.float)
            tmp_arr[array != c] = neutralElem
            tmp_arr[array==input_nodata] = math.nan
            feedback.pushDebugInfo("tmp_arr.dtype = " + str(tmp_arr.dtype))
            if self.DEBUG:
                feedback.pushDebugInfo("tmp_arr = " + str(tmp_arr))
                tmp_path = QgsProcessingUtils.generateTempFilename("tmp_" + str(c) + ".tif")
                feedback.pushDebugInfo("tmp_path = " + str(tmp_path))
                qgsUtils.exportRaster(tmp_arr,self.input_path,tmp_path,
                    nodata=self.out_nodata,type=gdal.GDT_Float32)
            computed_arr = ndimage.generic_filter(tmp_arr,
                self.filter_nbContact_distance,footprint=self.footprint,
                mode="constant",cval=math.nan,output=np.float32)
            # median_arr = ndimage.generic_filter(array,
                # self.filter_median,footprint=self.footprint,
                # mode="constant",cval=-1,output=np.float32)
            # median_arr[np.isnan(median_arr)] = 0
            # computed_arr = computed_arr * median_arr
            # computed_arr = ndimage.generic_filter(tmp_arr,
                # self.add_func,footprint=self.footprint,
                # mode='nearest',output=np.float32)
            if self.DEBUG:
                feedback.pushDebugInfo("computed_arr = " + str(computed_arr))
                feedback.pushDebugInfo("computed_arr.dtype = " + str(computed_arr.dtype))
                computed_c_path = QgsProcessingUtils.generateTempFilename(
                    "computed_" + str(c) + ".tif")
                feedback.pushDebugInfo("computed_c_path = " + str(computed_c_path))
                qgsUtils.exportRaster(computed_arr,self.input_path,computed_c_path,
                    nodata=self.out_nodata,type=gdal.GDT_Float32)
            if cpt > 1:
                computed_arr = np.add(computed_arr,curr_q3)
            if cpt == nb_vals:
                #et donc si computed = 0 ???
                # Comment 0 possible avec curr_q3 ?
                acc_arr /= computed_arr
            else:
                computed_arr[array==input_nodata] = math.nan
                # computed_arr[array==input_nodata] = neutralElem
                curr_q3 = np.nanquantile(computed_arr,q=0.75)
                feedback.pushDebugInfo("curr_q3 = " + str(curr_q3))
                computed_arr[array==input_nodata] = neutralElem
                acc_arr += computed_arr
            if self.DEBUG:
                acc_path = QgsProcessingUtils.generateTempFilename("acc_" + str(c) + ".tif")
                feedback.pushDebugInfo("acc_path = " + str(acc_path))
                qgsUtils.exportRaster(acc_arr,self.input_path,acc_path,
                    nodata=self.out_nodata,type=gdal.GDT_Float32)
                feedback.pushDebugInfo("acc_arr = " + str(acc_arr))
        # Output
        feedback.pushDebugInfo("out_nodata = " + str(self.out_nodata))
        acc_arr[array==input_nodata] = self.out_nodata
        feedback.pushDebugInfo("acc_arr = " + str(acc_arr))
        qgsUtils.exportRaster(acc_arr,self.input_path,self.output,
            nodata=self.out_nodata,type=gdal.GDT_Float32)
        return { self.OUTPUT_FILE : self.output }
  
  
class RelativeSurface(QualifAlgorithm):

    ALG_NAME = 'RelativeSurface'
    
    LAYER_A = 'LAYER_A'
    LAYER_B = 'LAYER_B'
    
    def displayName(self):
        return self.tr("Relative surface")
        
    def shortHelpString(self):
        return self.tr("Relative surface (percentage of B surface in each patch of layer A)")
    
    def initAlgorithm(self, config=None):
        self.addParameter(
            QgsProcessingParameterFeatureSource(
                self.LAYER_A,
                description=self.tr('Layer A (main layer)')))
        self.addParameter(
            QgsProcessingParameterFeatureSource(
                self.LAYER_B,
                description=self.tr('Layer B (relative surface layer)')))
        self.addParameter(
            QgsProcessingParameterFeatureSink(
                self.OUTPUT,
                self.tr("Output layer")))
        # self.addParameter(
            # QgsProcessingParameterVectorDestination(
                # self.OUTPUT,
                # self.tr("Output layer")))
                
    def computeArea(self,f):
        return f.geometry().area()
    def computeRelSurf(self,f):
        return f[self.sumField] / f.geometry().area()
        
    def processAlgorithm(self,parameters,context,feedback):
        # Parameters
        layerA = self.parameterAsVectorLayer(parameters,self.LAYER_A,context)
        if layerA is None:
            raise QgsProcessingException(self.invalidSourceError(parameters, self.LAYER_A))
        layerB = self.parameterAsVectorLayer(parameters,self.LAYER_B,context)
        if layerB is None:
            raise QgsProcessingException(self.invalidSourceError(parameters, self.LAYER_B))
        outFields = QgsFields(layerA.fields())
        areaFieldName = "area"
        relSurfFieldName = "relSurface"
        areaField = QgsField(areaFieldName, QVariant.Double)
        relSurfField = QgsField(relSurfFieldName, QVariant.Double)
        outFields.append(areaField)
        outFields.append(relSurfField)
        (sink, dest_id) = self.parameterAsSink(
            parameters,
            self.OUTPUT,
            context,
            outFields,
            layerA.wkbType(),
            layerA.sourceCrs()
        )
        nb_feats = layerA.featureCount()
        if nb_feats == 0:
            raise QgsProcessingException("No feature in layerA layer")
        progress_step = 100.0 / nb_feats
        curr_step = 0
        mf = QgsProcessingMultiStepFeedback(nb_feats,feedback)
        for cpt, f in enumerate(layerA.getFeatures(),start=1):
            f_geom = f.geometry()
            f_area = f_geom.area()
            area = 0
            for b_feat in layerB.getFeatures():
                b_geom = b_feat.geometry()
                intersection = f_geom.intersection(b_geom)
                area += intersection.area()
            # f_id = f.id()
            # layerA.selectByIds([f_id])
            # suffix = "_" + str(f_id) + ".gpkg"
            # selection = QgsProcessingUtils.generateTempFilename(
                # "selection" + suffix)
            # qgsTreatments.saveSelectedAttributes(joined_layer,
                # layerA,context=context,feedback=mf)
            # clipped_path = QgsProcessingUtils.generateTempFilename(
                # "clipped" + suffix)
            # qgsTreatments.applyVectorClip(layerB,selection,
                # clipped_path,context=context,feedback=mf)
            # clipped_layer = qgsUtils.loadVectorLayer(clipped)
            outF = QgsFeature(outFields)
            outF.setGeometry(f.geometry())
            for field in f.fields().names():
                outF[field] = f[field]
            outF[areaFieldName] = area
            outF[relSurfFieldName] = area / f_area
            sink.addFeature(outF)
            mf.setCurrentStep(cpt)
        return { self.OUTPUT : dest_id } 
        
    def processAlgorithmOld(self,parameters,context,feedback):
        # Parameters
        layerA = self.parameterAsVectorLayer(parameters,self.LAYER_A,context)
        if layerA is None:
            raise QgsProcessingException(self.invalidSourceError(parameters, self.LAYER_A))
        layerB = self.parameterAsVectorLayer(parameters,self.LAYER_B,context)
        if layerB is None:
            raise QgsProcessingException(self.invalidSourceError(parameters, self.LAYER_B))
        output = self.parameterAsOutputLayer(parameters,self.OUTPUT,context)
        # Processing : todo clip
        clippedPath = QgsProcessingUtils.generateTempFilename('clipped.gpkg')
        qgsTreatments.applyVectorClip(layerA,layerB,clippedPath,
            context=context,feedback=feedback)
        qgsUtils.loadVectorLayer(clippedPath,loadProject=True)
        # Computes new area
        areaField = 'area'
        areaPath = QgsProcessingUtils.generateTempFilename('area.gpkg')
        qgsTreatments.fieldCalculator(clippedPath,areaField,'$area',areaPath,
            context=context,feedback=feedback)
        # Join by loc summary
        joinedPath = QgsProcessingUtils.generateTempFilename('joined.gpkg')
        qgsTreatments.joinByLocSummary(layerA,areaPath,joinedPath,
            fieldnames=[areaField],summaries=[5],predicates=[1],discard=False,
            context=context,feedback=feedback)
        # Computes relative surface
        sumField = areaField + '_sum'
        formula = 'if ( "' + sumField + '" > 0, "' + sumField + '" / $area, 0)'
        qgsTreatments.fieldCalculator(joinedPath,'relSurface',formula,output,
            context=context,feedback=feedback)
        return { self.OUTPUT : output }
        
    
