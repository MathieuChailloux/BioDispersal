# -*- coding: utf-8 -*-
"""
/***************************************************************************
 BioDispersal
                                 A QGIS plugin
 Computes ecological continuities based on environments permeability
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2018-04-12
        git sha              : $Format:%H$
        copyright            : (C) 2018 by IRSTEA
        email                : mathieu.chailloux@irstea.fr
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os
import stat
import math
import xml.etree.ElementTree as ET
from pathlib import Path
from abc import ABC, abstractmethod

try:
    import scipy
    from scipy import ndimage
    import_scipy_ok = True
except ImportError:
    import_scipy_ok = False
try:
    import numpy as np
    import_numpy_ok = True
except ImportError:
    import_numpy_ok = False
try:
    from osgeo import gdal
except ImportError:
    import gdal
    
from PyQt5.QtCore import QCoreApplication, QVariant
from PyQt5.QtGui import QIcon
from qgis.core import (Qgis,
                       QgsProject,
                       QgsFields,
                       QgsField,
                       QgsFeature,
                       QgsProcessing,
                       QgsProcessingUtils,
                       QgsProcessingAlgorithm,
                       QgsProcessingException,
                       QgsProcessingProvider,
                       QgsProcessingMultiStepFeedback,
                       QgsProcessingParameterFeatureSource,
                       QgsProcessingParameterMultipleLayers,
                       QgsProcessingParameterExtent,
                       QgsProcessingParameterNumber,
                       QgsProcessingParameterMatrix,
                       QgsProcessingParameterFeatureSink,
                       QgsProcessingParameterExpression,
                       QgsProcessingParameterString,
                       QgsProcessingParameterField,
                       QgsProcessingParameterRange,
                       QgsProcessingParameterVectorDestination,
                       QgsProcessingParameterRasterDestination,
                       QgsProcessingParameterFileDestination,
                       QgsProcessingParameterFolderDestination,
                       QgsProcessingParameterRasterLayer,
                       QgsProcessingParameterMapLayer,
                       QgsProcessingParameterEnum,
                       QgsProcessingParameterBoolean,
                       QgsProcessingParameterFile,
                       QgsFeatureSink)

import processing
from processing.algs.gdal.rasterize import rasterize

from ..qgis_lib_mc import utils, qgsUtils, qgsTreatments, feedbacks, styles
from ..BioDispersal_model import BioDispersalModel

MEMORY_LAYER_NAME = qgsTreatments.MEMORY_LAYER_NAME

class BioDispersalAlgorithmsProvider(QgsProcessingProvider):

    NAME = "BioDispersal"

    def __init__(self):
        self.alglist = [SelectVExprAlg(),
                        SelectVFieldAlg(),
                        WeightingBasics(),
                        WeightingByIntervals(),
                        WeightingByDistance(),
                        RasterSelectionByValue(),
                        ExtractPatchesR(),
                        # BioDispersalAlgorithm(),
                        RasterizeFixAllTouch(),
                        ExportToGraphab(),
                        ExportPatchesToCircuitscape(),
                        ExportFrictionToCircuitscape(),
                        RandomStartPointsCircuitscape(),
                        AggregateCirctuitscapeCurrentMaps(),
                        AggregateCirctuitscapeResults(),
                        ChangeNoDataVal(),
                        DistanceToBorderRaster(),
                        LabelPatches(),
                        PatchSizeRaster(),
                        PatchAreaWindow(),
                        AreaDistrib(),
                        MedianDistance(),
                        MedianDistanceDistrib(),
                        NbContactDistrib(),
                        # MedianDistanceDistrib2(),
                        NbContactMedianDistrib(),
                        NeighboursCount(),
                        RelativeSurface()]
        for a in self.alglist:
            a.initAlgorithm()
        super().__init__()
        
    def unload(self):
        pass
        
    def id(self):
        return self.NAME
        
    def name(self):
        return self.NAME
        
    def longName(self):
        return self.name()
        
    def icon(self):
        icon_path = os.path.join(os.path.dirname(__file__), "..", "icons", "cerf.png")
        return QIcon(icon_path)

    def loadAlgorithms(self):
        for a in self.alglist:
            self.addAlgorithm(a)
            
    def supportedOutputRasterLayerExtensions(self):
        return ['tif','asc']

#class BaseAlgorithm(QgsProcessingAlgorithm):
#    def tr(self, string):
#        return QCoreApplication.translate(self.__class__.__name__, string)
class StepAlgorithm(qgsUtils.BaseProcessingAlgorithm):
    def group(self):
        return self.tr("Steps")
    def groupId(self):
        return 'steps'
SelectionAlgorithm = StepAlgorithm
WeightingBaseAlgorithm = StepAlgorithm
class GraphabAlgorithm(qgsUtils.BaseProcessingAlgorithm):
    def group(self):
        return self.tr("Graphab")
    def groupId(self):
        return 'graphab'
class CircuitscapeAlgorithm(qgsUtils.BaseProcessingAlgorithm):
    def group(self):
        return self.tr("Circuitscape")
    def groupId(self):
        return 'circuitscape'
class AuxAlgorithm(qgsUtils.BaseProcessingAlgorithm):
    def group(self):
        return self.tr("Other algorithms")
    def groupId(self):
        return 'misc'
class IsolationAlgorithm(qgsUtils.BaseProcessingAlgorithm):
    def group(self):
        return self.tr("Patch indices")
    def groupId(self):
        return 'isolation'
class QualifAlgorithm(qgsUtils.BaseProcessingAlgorithm):
    def group(self):
        return self.tr("Habitat qualification")
    def groupId(self):
        return 'qualif'
               
class BioDispersalAlgorithm(AuxAlgorithm):

    ALG_NAME = 'BioDispersalAlgorithm'
    
    # Algorithm parameters
    INPUT_CONFIG = "INPUT"
    LOG_FILE = "LOG"
        
    def displayName(self):
        return self.tr("Run BioDispersal from configuration file")
        
    def shortHelpString(self):
        return self.tr("Executes complete process from XML configuration file")

    def initAlgorithm(self,config=None):
        self.addParameter(
            QgsProcessingParameterFile(
                self.INPUT_CONFIG,
                description=self.tr("Input configuration file")))
        self.addParameter(
            QgsProcessingParameterFileDestination(
                self.LOG_FILE,
                description=self.tr("Log file")))
                
    def processAlgorithm(self,parameters,context,feedback):
        feedback.pushInfo("begin")
        utils.print_func = feedback.pushInfo
        # Parameters
        log_file = self.parameterAsFile(parameters,self.LOG_FILE,context)
        feedback.pushDebugInfo("log file = " + str(log_file))
        if utils.fileExists(log_file):
            os.remove(log_file)
        with open(log_file,"w+") as f:
            f.write("BioDispersal from configuration file " + str(log_file) + "\n")
            #raise QgsProcessingException("Log file " + str(log_file) + " already exists")
        log_feedback = feedbacks.FileFeedback(log_file)
        log_feedback.pushInfo("File feedback initialized")
        config_file = self.parameterAsFile(parameters,self.INPUT_CONFIG,context)
        config_tree = ET.parse(config_file)
        config_root = config_tree.getroot()
        bdModel = BioDispersalModel(context,log_feedback)
        log_feedback.pushInfo("from log")
        bdModel.feedback.pushInfo("from model")
        bdModel.fromXMLRoot(config_root)
        bdModel.runModel()
        outputs = [bdModel.getOrigPath(item.dict["out_layer"]) for item in bdModel.costModel.items]
        #qgsUtils.loadVectorLayer(res,loadProject=True)
        return {self.OUTPUT: outputs}
               
class SelectVExprAlg(SelectionAlgorithm):

    ALG_NAME = 'selectvexpr'
    
    EXPR = 'EXPR'
    CLASS = 'CLASS'
    CODE = 'CODE'
        
    def displayName(self):
        return self.tr('Selection (by expression)')
        
    def shortHelpString(self):
        return self.tr('Code layer creation from input layer and expression')

    def initAlgorithm(self, config=None):
        self.addParameter(
            QgsProcessingParameterFeatureSource(
                self.INPUT,
                description=self.tr('Input layer')))
        self.addParameter(
            QgsProcessingParameterExpression (
                self.EXPR,
                description=self.tr('Expression'),
                defaultValue="",
                parentLayerParameterName=self.INPUT,
                optional=True))
        self.addParameter(
            QgsProcessingParameterString (
                self.CLASS,
                description=self.tr('Class')))
        self.addParameter(
            QgsProcessingParameterNumber (
                self.CODE,
                description=self.tr('Code'),
                type=QgsProcessingParameterNumber.Integer))
        self.addParameter(
            QgsProcessingParameterFeatureSink(
                self.OUTPUT,
                self.tr("Output layer")))
                
    def processAlgorithm(self,parameters,context,feedback):
        input = self.parameterAsVectorLayer(parameters,self.INPUT,context)
        feedback.pushDebugInfo("input = " + str(input))
        if input is None:
            raise QgsProcessingException(self.invalidSourceError(parameters, self.INPUT))
        qgsUtils.normalizeEncoding(input)
        expr = self.parameterAsExpression(parameters,self.EXPR,context)
        class_name = self.parameterAsString(parameters,self.CLASS,context)
        code = self.parameterAsInt(parameters,self.CODE,context)
        out_fields = QgsFields()
        orig_field = QgsField("Origin", QVariant.String)
        class_field = QgsField("Class", QVariant.String)
        code_field = QgsField("Code", QVariant.Int)
        out_fields.append(orig_field)
        out_fields.append(class_field)
        out_fields.append(code_field)
        (sink, dest_id) = self.parameterAsSink(
            parameters,
            self.OUTPUT,
            context,
            out_fields,
            input.wkbType(),
            input.sourceCrs()
        )
        if sink is None:
            raise QgsProcessingException(self.invalidSinkError(parameters, self.OUTPUT))
            
        if expr is None or expr == "":
            nb_feats = input.featureCount()
            feats = input.getFeatures()
        else:
            qgsTreatments.selectByExpression(input,expr,feedback=feedback)
            nb_feats = input.selectedFeatureCount()
            feats = input.getSelectedFeatures()
            
        if nb_feats == 0:
            raise QgsProcessingException("No feature selected")
        progress_step = 100.0 / nb_feats
        curr_step = 0
        for f in feats:
            new_f = QgsFeature(out_fields)
            new_f["Origin"] = input.sourceName()
            new_f["Class"] = class_name
            new_f["Code"] = code
            new_f.setGeometry(f.geometry())
            sink.addFeature(new_f,QgsFeatureSink.FastInsert)
            curr_step += 1
            feedback.setProgress(int(curr_step * progress_step))
            
        res = { self.OUTPUT : dest_id }
        return res

        
class SelectVFieldAlg(SelectionAlgorithm):

    ALG_NAME = 'selectvfield'
    
    FIELD = 'FIELD'
    GROUP = 'GROUP'
    ASSOC = 'ASSOC'
    
    HEADER_FIELD_VAL = 'Field value'
    HEADER_INT_VAL = 'New integer value'
        
    def displayName(self):
        return self.tr('Selection (by field value)')
        
    def shortHelpString(self):
        return self.tr('Code layer creation from input layer and field values')

    def initAlgorithm(self, config=None):
        self.addParameter(
            QgsProcessingParameterFeatureSource(
                self.INPUT,
                description=self.tr('Input layer')))
        self.addParameter(
            QgsProcessingParameterField(
                self.FIELD,
                description=self.tr('Field'),
                defaultValue=None,
                parentLayerParameterName=self.INPUT))
        self.addParameter(
            QgsProcessingParameterString (
                self.GROUP,
                description=self.tr('Group')))
        self.addParameter(
            QgsProcessingParameterMatrix (
                self.ASSOC,
                description=self.tr('Value / code association'),
                numberRows=1,
                hasFixedNumberRows=False,
                headers=[self.HEADER_FIELD_VAL,self.HEADER_INT_VAL]))
        self.addParameter(
            QgsProcessingParameterFeatureSink(
                self.OUTPUT,
                self.tr("Output layer")))
                
    def processAlgorithm(self,parameters,context,feedback):
        input = self.parameterAsVectorLayer(parameters,self.INPUT,context)
        feedback.pushDebugInfo("input = " + str(input))
        if input is None:
            raise QgsProcessingException(self.invalidSourceError(parameters, self.INPUT))
        qgsUtils.normalizeEncoding(input)
        fieldname = self.parameterAsString(parameters,self.FIELD,context)
        if not fieldname:
            raise QgsProcessingException("No field given")
        grp_name = self.parameterAsString(parameters,self.GROUP,context)
        assoc = self.parameterAsMatrix(parameters,self.ASSOC,context)
        out_fields = QgsFields()
        orig_field = QgsField("Origin", QVariant.String)
        class_field = QgsField("Class", QVariant.String)
        code_field = QgsField("Code", QVariant.Int)
        out_fields.append(orig_field)
        out_fields.append(class_field)
        out_fields.append(code_field)
        (sink, dest_id) = self.parameterAsSink(
            parameters,
            self.OUTPUT,
            context,
            out_fields,
            input.wkbType(),
            input.sourceCrs()
        )
        if sink is None:
            raise QgsProcessingException(self.invalidSinkError(parameters, self.OUTPUT))
        i = iter(assoc)
        assoc_table = dict(zip(i,i))
        feedback.pushDebugInfo("assoc_table : " + str(assoc_table))
        nb_feats = input.featureCount()
        if nb_feats == 0:
            raise QgsProcessingException("No feature in input layer")
        progress_step = 100.0 / nb_feats
        curr_step = 0
        for f in input.getFeatures():
            field_val = str(f[fieldname])
            if field_val not in assoc_table:
                raise QgsProcessingException("Value '" + str(field_val) + "' does not exist in association")
            new_f = QgsFeature(out_fields)
            new_f["Origin"] = input.sourceName()
            new_f["Class"] = grp_name + "_" + str(field_val)
            try:
                code = int(assoc_table[field_val])
            except ValueError:
                raise QgsProcessingException("Matrix contains non-integer value " + str(assoc_table[field_val]))
            new_f["Code"] = code
            new_f.setGeometry(f.geometry())
            sink.addFeature(new_f)
            curr_step += 1
            feedback.setProgress(int(curr_step * progress_step))
        res = { self.OUTPUT : dest_id }
        return res        
      
class WeightingAlgorithm(WeightingBaseAlgorithm):
    
    INPUT_LAYER = 'INPUT_LAYER'
    WEIGHT_LAYER = 'WEIGHT_LAYER'
    RESAMPLING = 'RESAMPLING'

    def initAlgorithm(self, config=None):
        self.methods = ((self.tr('Nearest neighbour'), 'near'),
                        (self.tr('Bilinear'), 'bilinear'),
                        (self.tr('Cubic'), 'cubic'),
                        (self.tr('Cubic spline'), 'cubicspline'),
                        (self.tr('Lanczos windowed sinc'), 'lanczos'),
                        (self.tr('Average'), 'average'),
                        (self.tr('Mode'), 'mode'),
                        (self.tr('Maximum'), 'max'),
                        (self.tr('Minimum'), 'min'),
                        (self.tr('Median'), 'med'),
                        (self.tr('First quartile'), 'q1'),
                        (self.tr('Third quartile'), 'q3'))
                        
        self.addParameter(
            QgsProcessingParameterRasterLayer(
                self.INPUT_LAYER,
                description=self.tr('Input layer')))
        self.addParameter(
            QgsProcessingParameterRasterLayer(
                self.WEIGHT_LAYER,
                description=self.tr('Weighting layer')))
        self.addParameter(QgsProcessingParameterEnum(self.RESAMPLING,
                                                     self.tr('Resampling method to use'),
                                                     options=[i[0] for i in self.methods],
                                                     optional=True,
                                                     defaultValue=0))
        self.addParameter(
            QgsProcessingParameterRasterDestination(
                self.OUTPUT,
                self.tr("Output layer")))
                
    def prepareParameters(self,parameters,context,feedback):
        input = self.parameterAsRasterLayer(parameters,self.INPUT_LAYER,context)
        if input is None:
            raise QgsProcessingException(self.invalidRasterError(parameters, self.INPUT_LAYER))
        weighting = self.parameterAsRasterLayer(parameters,self.WEIGHT_LAYER,context)
        if weighting is None:
            raise QgsProcessingException(self.invalidRasterError(parameters, self.WEIGHT_LAYER))
        resampling = parameters[self.RESAMPLING]
        output = self.parameterAsOutputLayer(parameters, self.OUTPUT, context)
        return (input, weighting, resampling, output)
        
    def warpWeightingLayer(self,parameters,context,feedback):
        input, weighting, resampling, output = self.prepareParameters(parameters,context,feedback)
        input_dp = input.dataProvider()
        nodata_val = input_dp.sourceNoDataValue(1)
        resolution = input.rasterUnitsPerPixelX()
        crs = input.crs()
        out = QgsProcessingUtils.generateTempFilename('warped.tif')
        warp_params = { 'INPUT' : weighting,
                        'TARGET_CRS' : crs,
                        'RESAMPLING' : resampling,
                        'NODATA' : nodata_val,
                        'TARGET_RESOLUTION' : resolution,
                        'TARGET_EXTENT' : input.extent(),
                        'TARGET_EXTENT_CRS' : crs,
                        'OUTPUT' : out }
        warped = processing.run('gdal:warpreproject',warp_params,context=context,feedback=feedback)
        return warped['OUTPUT']
        
    def warpFromCustomLayer(self,input,resampling,output,context,feedback):
        input_dp = input.dataProvider()
        nodata_val = input_dp.sourceNoDataValue(1)
        resolution = input.rasterUnitsPerPixelX()
        crs = input.crs()
        warp_params = { 'INPUT' : input,
                        'TARGET_CRS' : crs,
                        'RESAMPLING' : resampling,
                        'NODATA' : nodata_val,
                        'TARGET_RESOLUTION' : resolution,
                        'TARGET_EXTENT' : input.extent(),
                        'TARGET_EXTENT_CRS' : crs,
                        'OUTPUT' : output }
        warped = processing.run('gdal:warpreproject',warp_params,context=context,feedback=feedback)
        return warped['OUTPUT']


class WeightingBasics(WeightingAlgorithm):

    ALG_NAME = 'weightingbasics'

    OPERATOR = 'OPERATOR'
        
    def displayName(self):
        return self.tr('Weighting (Basics)')
        
    def shortHelpString(self):
        helpStr = "Weighting of friction layer A by another layer B. Layers must be aligned.\n"
        helpStr += "Available weighting operations :\n"
        helpStr += " * Minimum (pixResult = min(pixA, pixB))\n"
        helpStr += " * Maximum (pixResult = max(pixA, pixB))\n"
        helpStr += " * Multiplication (pixResult = pixA * pixB)"
        return self.tr(helpStr)

    def initAlgorithm(self, config=None):
        self.operators = [ self.tr('Minimum'),
                           self.tr('Maximum'),
                           self.tr('Multiplication') ]
        super().initAlgorithm()
        self.addParameter(QgsProcessingParameterEnum(self.OPERATOR,
                                                     self.tr('Weighting method to use'),
                                                     options=self.operators,
                                                     defaultValue=0))
                                                             
    def processAlgorithm(self,parameters,context,feedback):
        input, weighting, resampling, output = self.prepareParameters(parameters,context,feedback)
        operator = self.parameterAsEnum(parameters,self.OPERATOR,context)
        #output = self.parameterAsOutputLayer(parameters, self.OUTPUT, context)
        warped_path = self.warpWeightingLayer(parameters,context,feedback)
        feedback.pushDebugInfo('warped_path = ' + str(warped_path))
        warped_layer = qgsUtils.loadRasterLayer(warped_path)
        nodata_val = input.dataProvider().sourceNoDataValue(1)
        min, max = qgsUtils.getRastersMinMax([input,weighting])
        range = [min,max]
        layers = [qgsUtils.pathOfLayer(input),qgsUtils.pathOfLayer(weighting)]
        out_path = parameters['OUTPUT']
        feedback.pushDebugInfo('out_path = ' + str(out_path))
        feedback.pushDebugInfo('output = ' + str(output))
        # if os.path.isfile(out_path):
            # qgsUtils.removeRaster(out_path)
        if operator == 0:
            out = qgsTreatments.applyRasterCalcMin(input,warped_layer,output,
                                                   nodata_val=nodata_val,out_type=Qgis.Int32,
                                                   context=context,feedback=feedback)
        elif operator == 1:
            out = qgsTreatments.applyRasterCalcMax(input,warped_layer,output,
                                                   nodata_val=nodata_val,out_type=Qgis.Int32,
                                                   context=context,feedback=feedback)
        elif operator == 2:
            out = qgsTreatments.applyRasterCalcMult(input,warped_layer,output,
                                                    nodata_val=nodata_val,out_type=Qgis.Int32,
                                                    context=context,feedback=feedback)
        else:
            assert(False)
        return { 'OUTPUT' : out }

            
class WeightingIntervalsAlgorithm(WeightingAlgorithm):
    
    INTERVALS = 'INTERVALS'
    RANGE_BOUNDARIES = 'RANGE_BOUNDARIES'
    
    LOW_BOUND = 'LOW_BOUND'
    UP_BOUND = 'UP_BOUND'
    POND_VAL = 'POND_VALUE'
    NODATA_POND_VAL = 'NODATA_POND_VALUE'

    def initAlgorithm(self, config=None):
        self.range_boundaries = [self.tr('min < value <= max'),
                                 self.tr('min <= value < max'),
                                 self.tr('min <= value <= max'),
                                 self.tr('min < value < max')]
        super().initAlgorithm(config)
        self.addParameter(
            QgsProcessingParameterMatrix (
                self.INTERVALS,
                description=self.tr('Intervals'),
                numberRows=1,
                hasFixedNumberRows=False,
                headers=[self.LOW_BOUND,self.UP_BOUND,self.POND_VAL]))
        self.addParameter(QgsProcessingParameterEnum(self.RANGE_BOUNDARIES,
                                                     self.tr('Range boundaries'),
                                                     options=self.range_boundaries,
                                                     optional=True,
                                                     defaultValue=2))
                
   
class WeightingByIntervals(WeightingIntervalsAlgorithm):

    ALG_NAME = 'weightingbyintervals'
        
    def displayName(self):
        return self.tr('Weighting (By intervals)')
        
    def shortHelpString(self):
        helpStr = "Weighting of friction layer A by another layer B. Layers must be aligned.\n"
        helpStr += "Value intervals [lowBound, upBound] and weighting value 'pond_val' are defined for layer B.\n"
        helpStr += "If pixB belongs to [lowBound, upBound] then pixResult = pixA * pond_val."
        return self.tr(helpStr)

    def initAlgorithm(self, config=None):
        super().initAlgorithm(config)
                
    def processAlgorithm(self,parameters,context,feedback):
        input, weighting, resampling, output = self.prepareParameters(parameters,context,feedback)
        range_boundaries = self.parameterAsEnum(parameters,self.RANGE_BOUNDARIES,context)
        # WARP
        warped_layer = self.warpWeightingLayer(parameters,context,feedback)
        # RECLASSIFY
        nodata_val = input.dataProvider().sourceNoDataValue(1)
        out_reclassed = QgsProcessingUtils.generateTempFilename('Reclassed.tif')
        reclass_params = { 'DATA_TYPE' : 5,
                           'INPUT_RASTER' : warped_layer,
                           'NODATA_FOR_MISSING' : True,
                           'NO_DATA' : nodata_val,
                           'OUTPUT' : out_reclassed,
                           'RANGE_BOUNDARIES' : range_boundaries,
                           'RASTER_BAND' : 1,
                           'TABLE' : parameters[self.INTERVALS] }
        reclassed = processing.run('native:reclassifybytable',reclass_params,context=context,feedback=feedback)
        reclassed_layer = reclassed['OUTPUT']
        # WEIGHTING
        weighted = qgsTreatments.applyRasterCalcMult(input,reclassed_layer,output,
                                                     nodata_val=nodata_val,out_type=Qgis.Float32,
                                                     context=context,feedback=feedback)
        return { 'OUTPUT' : weighted }
   
class WeightingByDistance(WeightingIntervalsAlgorithm):

    ALG_NAME = 'weightingbydistance'
        
    def displayName(self):
        return self.tr('Weighting (By distance)')
        
    def shortHelpString(self):
        helpStr = "Weighting of friction layer A by distance to another layer B. Layers must be aligned.\n"
        helpStr += "Distance intervals [lowBound, upBound] and weighting value 'pond_val' are defined for layer B.\n"
        helpStr += "Distance of pixA to layer B is computed as the minimum distance from pixA to a pixel of B that is not NoData"
        helpStr += "If distance(pixA,B) belongs to [lowBound, upBound] then pixResult = pixA * pond_val."
        return self.tr(helpStr)

    def initAlgorithm(self, config=None):
        super().initAlgorithm(config)
                
    def processAlgorithm(self,parameters,context,feedback):
        input, weighting, resampling, output = self.prepareParameters(parameters,context,feedback)
        range_boundaries = self.parameterAsEnum(parameters,self.RANGE_BOUNDARIES,context)
        intervals = self.parameterAsMatrix(parameters,self.INTERVALS,context)
        # WARP
        warped_layer = self.warpWeightingLayer(parameters,context,feedback)
        # BUFFER
        feedback.pushDebugInfo('intervals = ' +str(intervals))
        distances = intervals[1::3]
        feedback.pushDebugInfo('distances = ' +str(distances))
        distances_str = ",".join([str(d) for d in distances])
        feedback.pushDebugInfo('distances_str = ' +str(distances_str))
        out_buffer = QgsProcessingUtils.generateTempFilename('out_buffer.tif')
        buffer_params = { 'input' : warped_layer,
                          'output' : out_buffer,
                          'distances' : distances_str,
                          'units' : 0, # 0 = meters ?
                          'GRASS_RASTER_FORMAT_META' : '',
                          'GRASS_RASTER_FORMAT_OPT' : '',
                          'GRASS_REGION_CELLSIZE_PARAMETER' : 0,
                          'GRASS_REGION_PARAMETER' : None,
                          '-z' : False }
                          #'--type' : 'Int32'
                          #'--overwrite' : False}
        feedback.pushDebugInfo("buffer_params = " + str(buffer_params))
        buffered = processing.run('grass7:r.buffer',buffer_params,context=context,feedback=feedback)
        feedback.pushDebugInfo("buffered = " + str(buffered))
        buffered_layer = buffered['output']
        feedback.pushDebugInfo("buffered_layer = " + str(buffered_layer))
        # RECLASSIFY
        pond_vals = intervals[2::3]
        feedback.pushDebugInfo('pond_vals = ' + str(pond_vals))
        pv1 = pond_vals[0]
        pond_table = [1,1,pv1]
        for idx, pv in enumerate(pond_vals,2):
            pond_table.append(idx)
            pond_table.append(idx)
            pond_table.append(pv)
        feedback.pushDebugInfo('pond_table = ' + str(pond_table))
        nodata_val = input.dataProvider().sourceNoDataValue(1)
        out_reclassed = QgsProcessingUtils.generateTempFilename('Reclassed.tif')
        reclass_params = { 'DATA_TYPE' : 5,
                           'INPUT_RASTER' : buffered_layer,
                           'NODATA_FOR_MISSING' : True,
                           'NO_DATA' : nodata_val,
                           'OUTPUT' : out_reclassed,
                           'RANGE_BOUNDARIES' : range_boundaries,
                           'RASTER_BAND' : 1,
                           'TABLE' : pond_table }
        feedback.pushDebugInfo("reclass_params = " + str(reclass_params))
        reclassed = processing.run('native:reclassifybytable',reclass_params,context=context,feedback=feedback)
        reclassed_layer = reclassed['OUTPUT']
        # NODATA
        reclassed_nonull = QgsProcessingUtils.generateTempFilename('reclassed_nonull.tif')
        nonull = qgsTreatments.applyRNull(reclassed_layer,1,reclassed_nonull,context=context,feedback=feedback)
        # WEIGHTING
        weighted = qgsTreatments.applyRasterCalcMult(input,nonull,output,
                                                     nodata_val=nodata_val,out_type=Qgis.Float32,
                                                     context=context,feedback=feedback)
        return { 'OUTPUT' : weighted }
   
class RasterSelectionByValue(AuxAlgorithm):

    ALG_NAME = 'rasterselectionbyvalue'

    OPERATOR = 'OPERATOR'
    VALUE = 'VALUE'
    
    OPERATORS = ['<','<=','>','>=','==','!=']
    OPERATORS_CMPL = ['>=','>','<=','<','!=','==']
        
    def displayName(self):
        return self.tr('Raster selection by value')
        
    def shortHelpString(self):
        return self.tr('Creates new raster with input raster values veryfing specified operation.')

    def initAlgorithm(self, config=None):
        self.addParameter(
            QgsProcessingParameterRasterLayer(
                self.INPUT,
                description=self.tr('Input layer')))
        self.addParameter(
            QgsProcessingParameterEnum(self.OPERATOR,
                                       self.tr('Operator'),
                                       options=self.OPERATORS,
                                       defaultValue=4))
        self.addParameter(
            QgsProcessingParameterNumber (
                self.VALUE,
                description=self.tr('Value'),
                defaultValue=0.0,
                type=QgsProcessingParameterNumber.Double))
        self.addParameter(
            QgsProcessingParameterRasterDestination(
                self.OUTPUT,
                self.tr("Output layer")))
                
                
    def processAlgorithm(self,parameters,context,feedback):
        input = self.parameterAsRasterLayer(parameters,self.INPUT,context)
        if input is None:
            raise QgsProcessingException(self.invalidRasterError(parameters, self.INPUT))
        operator = self.parameterAsEnum(parameters,self.OPERATOR,context)
        value = self.parameterAsDouble(parameters,self.VALUE,context)
        output = self.parameterAsOutputLayer(parameters, self.OUTPUT, context)
        # Type
        input_type = input.dataProvider().sourceDataType(1)
        # Expression
        input_nodata_val = input.dataProvider().sourceNoDataValue(1)
        operator_str = self.OPERATORS[operator]
        operator_cmpl_str = self.OPERATORS_CMPL[operator]
        value_str = str(value)
        nodata_str = str(input_nodata_val)
        cmp_expr = '(A {} {})'.format(operator_str,value_str)
        cmp_expr_cmpl = '(A {} {})'.format(operator_cmpl_str,value_str)
        expr = "A * " + str(cmp_expr)
        mult_expr = "A * B"
        if math.isnan(input_nodata_val):
            nodata_val = None
        else:
            nodata_val = input_nodata_val
        feedback.pushDebugInfo("nodata_val = " + nodata_str)
        feedback.pushDebugInfo("gdalcalc expr = " + str(expr))
        # Call
        tmp = QgsProcessingUtils.generateTempFilename('tmp.tif')
        out = qgsTreatments.applyRasterCalc(input,tmp,expr,
                                      nodata_val=0,out_type=input_type,
                                      context=context,feedback=feedback)
        out = qgsTreatments.applyRSetNull(tmp,0,output,context,feedback)
        return { 'OUTPUT' : out }
        

class ExtractPatchesR(AuxAlgorithm):

    ALG_NAME = 'extractPatchesR'

    VALUES = 'VALUES'
    SURFACE = 'SURFACE'
        
    def displayName(self):
        return self.tr('Extract patches (Raster)')
        
    def shortHelpString(self):
        s = "Extract patches from land use raster layer according to"
        s += " specified land use types and minimum surface."
        s += "\nLand use values are integer separated by semicolons (';')."
        return self.tr(s)

    def initAlgorithm(self, config=None):
        self.addParameter(
            QgsProcessingParameterRasterLayer(
                self.INPUT,
                description=self.tr('Input layer')))
        self.addParameter(
            QgsProcessingParameterString (
                self.VALUES,
                description=self.tr('Land use values (separated by \';\')')))
        self.addParameter(
            QgsProcessingParameterNumber (
                self.SURFACE,
                description=self.tr('Patch minimum surface (expressed in pixels)'),
                type=QgsProcessingParameterNumber.Double,
                optional=True))
        self.addParameter(
            QgsProcessingParameterRasterDestination(
                self.OUTPUT,
                self.tr("Output layer")))
                
    def getDataType(self,in_type):
        typeAssoc = { Qgis.Byte : 0,
                      Qgis.Int16 : 1,
                      Qgis.UInt16 : 2,
                      Qgis.UInt32 : 3,
                      Qgis.Int32 : 4,
                      Qgis.Float32 : 5,
                      Qgis.Float64 : 6 }
        if in_type in typeAssoc:
            return typeAssoc[in_type]
            #return 5
        else:
            return 5
                
    def processAlgorithm(self,parameters,context,feedback):
        input = self.parameterAsRasterLayer(parameters,self.INPUT,context)
        if input is None:
            raise QgsProcessingException(self.invalidRasterError(parameters, self.INPUT))
        values = self.parameterAsInts(parameters,self.VALUES,context)
        surface = self.parameterAsDouble(parameters,self.SURFACE,context)
        feedback.pushDebugInfo("values = " + str(values))
        nb_vals = len(values)
        if nb_vals == 0:
            raise QgsProcessingException("No land use values specified (check string format)")
        output = self.parameterAsOutputLayer(parameters, self.OUTPUT, context)
        # Expression
        input_nodata_val = input.dataProvider().sourceNoDataValue(1)
        if nb_vals == 1:
            expr_str = 'A == {}'.format(values[0])
        else:
            expr_str = ''
            for v in values[:-1]:
                expr_str += 'logical_or(A == {},'.format(v)
            expr_str += 'A == {}'.format(values[-1])
            expr_str += ")" * (nb_vals - 1)
        feedback.pushDebugInfo("raster calc expr = " + expr_str)
        # Raster calc
        selection_path = QgsProcessingUtils.generateTempFilename('landuse_selection.tif')
        out_calc = selection_path if surface else output
        qgsTreatments.applyRasterCalc(input,out_calc,expr_str,
                                      nodata_val=0,out_type=0,
                                      context=context,feedback=feedback)
        # Labelling
        if surface:
            if not (import_scipy_ok and import_numpy_ok):
                raise QgsProcessingException("Import of numpy/scipy failed, please install these libraries from OSGEO installer")
            selection = qgsUtils.loadRasterLayer(selection_path)
            classes, array = qgsUtils.getRasterValsAndArray(selection_path)
            struct = ndimage.generate_binary_structure(2,1)
            labeled_array, nb_patches = ndimage.label(array,struct)
            sizes = ndimage.sum(array,labeled_array,range(1,nb_patches+1))
            # x_res = selection.rasterUnitsPerPixelX()
            # y_res = selection.rasterUnitsPerPixelY()
            indices = np.where(sizes > surface)[0] + 1
            new_array = np.zeros(labeled_array.shape)
            for i in indices:
                new_array[labeled_array == i] = 1
            qgsUtils.exportRaster(new_array,selection.source(),output,nodata=0,type=1)
        # return
        return { 'OUTPUT' : output }
        
    
class RasterizeFixAllTouch(AuxAlgorithm,rasterize):

    ALG_NAME = 'rasterizefixalltouch'
        
    def displayName(self):
        return self.tr('Rasterize (with ALL_TOUCH fix)')
        
    #def group(self):
    #    return "Auxiliary algorithms"
        
    #def groupId(self):
    #    return 'aux'
        
    def shortHelpString(self):
        return self.tr('Wrapper for gdal:rasterize algorithm allowing to use ALL_TOUCH option (every pixel touching input geometry are rasterized).')

    def initAlgorithm(self, config=None):
        super().initAlgorithm(config)
        self.addParameter(
            QgsProcessingParameterBoolean(
                self.ALL_TOUCH,
                description = 'ALL_TOUCH option',
                defaultValue=False,
                optional=True))
    
# Apply rasterization on field 'field' of vector layer 'in_path'.
# Output raster layer in 'out_path'.
# Resolution set to 25 if not given.
# Extent can be given through 'extent_path'. If not, it is extracted from input layer.
# Output raster layer is loaded in QGIS if 'load_flag' is True.
def applyRasterizationFixAllTouch(in_path,out_path,extent,resolution,
                   field=None,burn_val=None,out_type=Qgis.Float32,
                   nodata_val=qgsTreatments.nodata_val,all_touch=False,overwrite=False,
                   context=None,feedback=None):
    #TYPES = ['Byte', 'Int16', 'UInt16', 'UInt32', 'Int32', 'Float32', 'Float64', 'CInt16', 'CInt32', 'CFloat32', 'CFloat64']
    out_type = qgsTreatments.qgsTypeToInt(out_type,shift=True)
    if overwrite:
        qgsUtils.removeRaster(out_path)
    extra_param_name = 'EXTRA'
    if hasattr(rasterize,extra_param_name):
        res = qgsTreatments.applyRasterization(in_path,out_path,extent,resolution,
                field,burn_val,out_type,nodata_val,all_touch,overwrite,
                context,feedback)
    else:
        parameters = { 'ALL_TOUCH' : True,
                   'BURN' : burn_val,
                   'DATA_TYPE' : out_type,
                   'EXTENT' : extent,
                   'FIELD' : field,
                   'HEIGHT' : resolution,
                   'INPUT' : in_path,
                   'NODATA' : nodata_val,
                   'OUTPUT' : out_path,
                   'UNITS' : 1, 
                   'WIDTH' : resolution }
        res = qgsTreatments.applyProcessingAlg("BioDispersal",
            "rasterizefixalltouch",parameters,context,feedback)
    return res
    
    
class ChangeNoDataVal(AuxAlgorithm):

    ALG_NAME = 'changenodata'
    
    NODATA_VAL = 'NODATA_VAL'
        
    def displayName(self):
        return self.tr('Change NoData value')
        
    def shortHelpString(self):
        return self.tr('Change NoData value and reclassifies old NoData pixels to new NoData value.')

    def initAlgorithm(self, config=None):
        self.addParameter(
            QgsProcessingParameterRasterLayer(
                self.INPUT,
                description=self.tr('Input layer')))
        self.addParameter(
            QgsProcessingParameterNumber (
                self.NODATA_VAL,
                description=self.tr('New NoData value'),
                type=QgsProcessingParameterNumber.Double))
        self.addParameter(
            QgsProcessingParameterRasterDestination(
                self.OUTPUT,
                self.tr("Output layer")))
                
    def processAlgorithm(self,parameters,context,feedback):
        input = self.parameterAsRasterLayer(parameters,self.INPUT,context)
        if input is None:
            raise QgsProcessingException(self.invalidRasterError(parameters, self.INPUT))
        new_val = self.parameterAsDouble(parameters,self.NODATA_VAL,context)
        output = self.parameterAsOutputLayer(parameters, self.OUTPUT, context)
        input_nodata_val = input.dataProvider().sourceNoDataValue(1)
        feedback.pushDebugInfo("Input NoData value = " + str(input_nodata_val))
        #input_vals = qgsUtils.getRasterValsBis(input)
        input_vals = qgsTreatments.getRasterUniqueVals(input,feedback)
        feedback.pushDebugInfo("Input values = " + str(input_vals))
        if input_vals == []:
            feedback.pushInfo("Empty input layer (no input values)")
        if new_val in input_vals:
            raise QgsProcessingException("Input layer contains pixels with new NoData value '"
                    + str(new_val) + "'.")
        tmp = QgsProcessingUtils.generateTempFilename('tmp.tif')
        qgsTreatments.applyRNull(input,new_val,tmp,context,feedback)
        qgsTreatments.applyRSetNull(tmp,new_val,output,context,feedback)
        return { 'OUTPUT' : output }
    
    
class ExportToGraphab(GraphabAlgorithm):

    ALG_NAME = 'exporttographab'
        
    def name(self):
        return self.ALG_NAME
        
    def displayName(self):
        return self.tr('Export to Graphab')
        
    def shortHelpString(self):
        return self.tr('Ensures that friction layer is compatible with Graphab.')

    def initAlgorithm(self, config=None):
        self.addParameter(
            QgsProcessingParameterRasterLayer(
                self.INPUT,
                description=self.tr('Input layer (friction)')))
        self.addParameter(
            QgsProcessingParameterRasterDestination(
                self.OUTPUT,
                self.tr("Exported layer (friction)")))
                
    def processAlgorithm(self,parameters,context,feedback):
        input = self.parameterAsRasterLayer(parameters,self.INPUT,context)
        if input is None:
            raise QgsProcessingException(self.invalidRasterError(parameters, self.INPUT))
        output = self.parameterAsOutputLayer(parameters, self.OUTPUT, context)
        input_nodata_val = input.dataProvider().sourceNoDataValue(1)
        feedback.pushDebugInfo("Input NoData value = " + str(input_nodata_val))
        #input_vals = qgsUtils.getRasterValsBis(input)
        input_vals = qgsTreatments.getRasterUniqueVals(input,feedback)
        feedback.pushDebugInfo("Input values = " + str(input_vals))
        if input_vals == []:
            raise QgsProcessingException("Empty input layer (no input values)")
        for v in input_vals:
            if v <= 0:
                raise QgsProcessingException("Input layer contains value '"
                        + str(v) + "', but Graphab expects strictly positive (> 0) values")
                
        if input_nodata_val == 0 and 0 in input_vals:
            raise QgsProcessingException("Input layer contains value 0, but 0 represents NoData in Graphab")
        tmp = QgsProcessingUtils.generateTempFilename('tmp.tif')
        qgsTreatments.applyRNull(input,0,tmp,context,feedback)
        qgsTreatments.applyRSetNull(tmp,0,output,context,feedback)
        return {'OUTPUT' : output }
    
    
class ASCIIOutput(QgsProcessingParameterRasterDestination):
    def __init__(self, name, description):
        super().__init__(name, description)
    def defaultFileExtension(self):
        return 'asc'
    def supportedOutputRasterLayerExtensions(self):
        return ['asc']
    
    
class ExportPatchesToCircuitscape(CircuitscapeAlgorithm):

    ALG_NAME = 'exportpatchestocircuitscape'
    
    CLASS = 'CLASS'
        
    def displayName(self):
        return self.tr('Export to Circuitscape (start points)')
        
    def shortHelpString(self):
        return self.tr('Export patch layer (focal nodes, biodiversity reservois, ...) to Circuitscape')

    def initAlgorithm(self, config=None):
        self.addParameter(
            QgsProcessingParameterRasterLayer(
                self.INPUT,
                description=self.tr('Input patch layer')))
        self.addParameter(QgsProcessingParameterNumber(
            self.CLASS, "Choose Landscape Class", type=QgsProcessingParameterNumber.Integer,
            defaultValue=None,optional=True))
        self.addParameter(
            ASCIIOutput(
                self.OUTPUT,
                self.tr("Exported layer (start points)")))
                
    def processAlgorithm(self,parameters,context,feedback):
        if not import_scipy_ok:
            msg = "Scipy (python library) import failed. You can install it through OSGEO installer"
            raise QgsProcessingException(msg)
    
        input = self.parameterAsRasterLayer(parameters,self.INPUT,context)
        if input is None:
            raise QgsProcessingException(self.invalidRasterError(parameters, self.INPUT))
        cl = self.parameterAsInt(parameters, self.CLASS, context)
        cl_param = parameters[self.CLASS]
        output = self.parameterAsOutputLayer(parameters, self.OUTPUT, context)
                
        input_filename = input.source()
        input_nodata_val = input.dataProvider().sourceNoDataValue(1)
        feedback.pushDebugInfo("Input NoData value = " + str(input_nodata_val))
        if input_nodata_val == 1:
            raise QgsProcessingException("Input NoData value cannot be equal to 1.")
        input_type = input.dataProvider().dataType(1)
        feedback.pushDebugInfo("Input type = " + str(input_type))
        # if 0 in input_vals:
            # raise QgsProcessingException("Input layer contains 0 value")
        feedback.pushDebugInfo("output = " + str(output))
        output_basename, ext = os.path.splitext(output)
        output_tif = output_basename + ".tif"
                
        classes, array = qgsUtils.getRasterValsAndArray(str(input_filename))
        new_array = np.copy(array)
        feedback.pushDebugInfo("class = " + str(cl) + ", " + str(parameters[self.CLASS]))
        feedback.pushDebugInfo("array = " + str(array[0][0]))
        feedback.pushDebugInfo("new_array = " + str(new_array[0][0]))
        if cl_param is None:
            new_array[array!=input_nodata_val] = 1
            new_array[array==input_nodata_val] = 0
            new_array[array!=array] = 0
        elif cl not in classes:
            raise QgsProcessingException("No pixel found with class value " + str(cl))
        else:
            new_array[new_array!=cl] = 0
            new_array[array==cl] = 1
        struct = scipy.ndimage.generate_binary_structure(2,2)
        labeled_array, nb_patches = scipy.ndimage.label(new_array,struct)
        labeled_array[labeled_array==0] = input_nodata_val
        
        qgsUtils.exportRaster(labeled_array,input_filename,output_tif,
            nodata=input_nodata_val,type=input_type)
        out = qgsTreatments.applyTranslate(output_tif,output,data_type=input_type,
            nodata_val=input_nodata_val,context=context,feedback=feedback)
        # Data type coule be problematic if input layer has small type 
        # (suchs as Byte but BioDispersal exports Float32) and lot of patches.
        return {'OUTPUT' : out }
      
      
class ExportFrictionToCircuitscape(CircuitscapeAlgorithm):

    ALG_NAME = 'exportfrictiontocircuitscape'
        
    def displayName(self):
        return self.tr('Export to Circuitscape (friction layer)')
        
    def shortHelpString(self):
        return self.tr('Export friction (resistance) layer to Circuitscape, converting existing layer to ASCII format.')

    def initAlgorithm(self, config=None):
        self.addParameter(
            QgsProcessingParameterRasterLayer(
                self.INPUT,
                description=self.tr('Input resistance layer')))
        self.addParameter(
            ASCIIOutput(
                self.OUTPUT,
                self.tr("Exported layer (resistance)")))
                
    def processAlgorithm(self,parameters,context,feedback):    
        input = self.parameterAsRasterLayer(parameters,self.INPUT,context)
        if input is None:
            raise QgsProcessingException(self.invalidRasterError(parameters, self.INPUT))
        output = self.parameterAsOutputLayer(parameters, self.OUTPUT, context)        
                
        if output is None:
            raise QgsProcessingException("Empty output layer")
        base, ext = os.path.splitext(output)
        if ext != '.asc':
            raise QgsProcessingException("Invalid extension for output ASCII file : " + str(output))
        input_filename = input.source()
        input_nodata_val = input.dataProvider().sourceNoDataValue(1)
        feedback.pushDebugInfo("Input NoData value = " + str(input_nodata_val))
        if input_nodata_val == 1:
            raise QgsProcessingException("Input NoData value cannot be equal to 1.")
            
        input_type = input.dataProvider().dataType(1)
        out = qgsTreatments.applyTranslate(input_filename,output,data_type=input_type,
            nodata_val=input_nodata_val,context=context,feedback=feedback)
        return {'OUTPUT' : output }
        
        
class RandomStartPointsCircuitscape(CircuitscapeAlgorithm):

    ALG_NAME = 'randomStartPointsCircuitscape'
    
    def displayName(self):
        return self.tr('Random start points (Circuitscape)')
        
    def shortHelpString(self):
        return self.tr('Generates random start points layer for circuitscape input')
        
    PATCH_LAYER = 'PATCH_LAYER'
    NB_POINTS = 'NB_POINTS'
    NB_LAUNCHES = 'NB_LAUNCHES'
    DEFAULT_NB_LAUNCHES = 1
    RESISTANCE_LAYER = 'RESISTANCE_LAYER'
    # OUTPUT_DIR = 'OUTPUT_DIR'
    OUTPUT = 'OUTPUT'

    POINTS_VECTOR = 'POINTS_VECTOR'

    def initAlgorithm(self,config=None):
        self.addParameter(
            QgsProcessingParameterFeatureSource(
                self.PATCH_LAYER,
                description=self.tr('Patch layer')))
        self.addParameter(
            QgsProcessingParameterRasterLayer(
                self.RESISTANCE_LAYER,
                description=self.tr('Resistance layer')))
        self.addParameter(
            QgsProcessingParameterNumber (
                self.NB_POINTS,
                description=self.tr('Number of points'),
                type=QgsProcessingParameterNumber.Integer))
        self.addParameter(
            QgsProcessingParameterNumber (
                self.NB_LAUNCHES,
                description=self.tr('Number of launches'),
                type=QgsProcessingParameterNumber.Integer,
                defaultValue=self.DEFAULT_NB_LAUNCHES))
        self.addParameter(
            QgsProcessingParameterFolderDestination (
                self.OUTPUT,
                description=self.tr('Output directory')))
        
        
    def processAlgorithm(self,parameters,context,feedback):
        # Parameters
        patch_source, patch_layer = qgsTreatments.parameterAsSourceLayer(
            self,parameters,self.PATCH_LAYER,context,feedback=feedback)
        resistance_layer = self.parameterAsRasterLayer(parameters,self.RESISTANCE_LAYER,context)
        nb_points = self.parameterAsInt(parameters, self.NB_POINTS, context)
        nb_launches = self.parameterAsInt(parameters, self.NB_LAUNCHES, context)
        out_dir = self.parameterAsFileOutput(parameters,self.OUTPUT,context)
        resistance_path = qgsUtils.pathOfLayer(resistance_layer)
        # Init input / output
        utils.mkDir(out_dir)
        dirname = os.path.dirname(__file__)
        base_config_file = os.path.join(dirname,"baseConfig.ini")
        fin = open(base_config_file,"rt")
        config_content = fin.read()
        fin.close()
        # Resistance translation
        EPT = ExportFrictionToCircuitscape
        out_resistance = os.path.join(out_dir,'resistance.asc')
        parameters = { EPT.INPUT : resistance_layer , EPT.OUTPUT : out_resistance } 
        qgsTreatments.applyProcessingAlg('BioDispersal',EPT.ALG_NAME,
            parameters,context=context,feedback=feedback)
        # Loop
        step_feedback = feedbacks.ProgressMultiStepFeedback(nb_launches*4,feedback)
        outfiles = []
        for i in range(nb_launches):
            bname = "launch" + str(i)
            basepath = os.path.join(out_dir,bname)
            # Sort random points from patch layer
            points_vector = basepath + "_start.gpkg"
            qgsTreatments.applyVRandom(patch_layer,nb_points,points_vector,
                context=context,feedback=step_feedback)
            #qgsUtils.loadVectorLayer(points_vector,loadProject=True)
            step_feedback.setCurrentStep(4*i+1)
            # Rasterize points layer
            extent = resistance_layer.extent()
            resolution = resistance_layer.rasterUnitsPerPixelX()
            #points_tif = QgsProcessingUtils.generateTempFilename('points_raster.tif')
            points_tif = basepath + "_start.tif"
            qgsUtils.removeRaster(points_tif)
            qgsTreatments.applyRasterization(points_vector,points_tif,extent,resolution,
                field='cat',out_type=Qgis.Int16,nodata_val=-9999,
                context=context,feedback=step_feedback)
            #qgsUtils.loadRasterLayer(points_tif,loadProject=True)
            step_feedback.setCurrentStep(4*i+2)
            # Convert to asc
            #points_asc = QgsProcessingUtils.generateTempFilename('points_raster.asc')
            points_asc = basepath + "_start.asc"
            qgsUtils.removeRaster(points_asc)
            qgsTreatments.applyTranslate(points_tif,points_asc,
                nodata_val=0,context=context,feedback=step_feedback)
            #qgsUtils.loadRasterLayer(points_asc,loadProject=True)
            step_feedback.setCurrentStep(4*i+3)
            # Out config file
            out_content = config_content.replace('OUTPUT_DIR',out_dir)
            out_content = out_content.replace('OUTPUT_BNAME',bname)
            out_content = out_content.replace('START_LAYER',points_asc)
            out_content = out_content.replace('RESISTANCE_LAYER',out_resistance)
            outfile = basepath + "_config.ini"
            with open(outfile,"wt") as fout:
                fout.write(out_content)
            outfiles.append(outfile)
            step_feedback.setCurrentStep(4*i+4)
        # Output Julia script
        outscript = os.path.join(out_dir,"launchCircuitscape.jl")
        outscript = utils.normPath(outscript)
        script_text = "#include(\"" + outscript +"\")\n"
        script_text += "using Circuitscape\n"
        for outfile in outfiles:
            # f_posix = str(Path(outfile))
            # f_posix = f_posix.replace("\\","/")
            f_posix = utils.normPath(outfile)
            script_text += "compute(\"" + f_posix + "\")\n"
        utils.removeFile(outscript)
        with open(outscript,"w+") as fout:
            fout.write(script_text)
        os.chmod(outscript,0o7242)
        #os.chmod(outscript,stat.S_IXUSR)
        return { self.OUTPUT : out_dir }
        
        
class AggregateCirctuitscapeCurrentMaps(CircuitscapeAlgorithm):

    ALG_NAME = 'aggrCurrMapsLayers'
    
    def displayName(self):
        return self.tr('Aggregates current maps')
        
    def shortHelpString(self):
        return self.tr('Aggregates current maps (Circuitscape output) into one cumulative current map')
        
    INPUT_LAYERS = 'INPUT_LAYERS'

    def initAlgorithm(self,config=None):
        self.addParameter(
            QgsProcessingParameterMultipleLayers(
                self.INPUT_LAYERS,
                description=self.tr('Input layers'),
                layerType=QgsProcessing.TypeRaster))
        self.addParameter(
            QgsProcessingParameterRasterDestination(
                self.OUTPUT,
                self.tr("Output layer")))
                
    # def createFileFilter(self):
        # return "*.asc"
                
    def processAlgorithm(self,parameters,context,feedback):
        # Parameters
        input_layers = self.parameterAsLayerList(parameters,self.INPUT_LAYERS,context)
        output = self.parameterAsOutputLayer(parameters, self.OUTPUT, context)
        # Serie
        aggregate = QgsProcessingUtils.generateTempFilename('aggregate.tif')
        qgsTreatments.applyRSeries(input_layers,aggr_func=0,output=aggregate,
            context=context,feedback=feedback)
        # Set null
        qgsTreatments.applyRSetNull(aggregate,0,output,context=context,feedback=feedback)
        # Set style
        # self.output = output
        # self.out_layer = qgsUtils.loadRasterLayer(output)
        return { self.OUTPUT : output }

    # def postProcessAlgorithm(self, context, feedback):
        # out_layer = self.out_layer#qgsUtils.loadRasterLayer(output)
        # color_ramp = styles.mkColorRamp('Plasma')
        # shader = styles.mkRasterShader(out_layer,color_ramp)
        # styles.setSBPCRasterRenderer(out_layer,shader)
        # out_layer.triggerRepaint()
        # return { self.OUTPUT : self.out_layer }
        
        
class AggregateCirctuitscapeResults(CircuitscapeAlgorithm):

    ALG_NAME = 'aggrCircuitscapeResults'
    
    def displayName(self):
        return self.tr('Aggregates Circuitscape results')
        
    def shortHelpString(self):
        return self.tr('Aggregates Circuitscape results (start points and current maps) from directory')
        
    RESULTS_DIR = 'RESULTS_DIR'
    AGGR_CURR = 'AGGR_CURR'
    AGGR_START = 'AGGR_START'

    def initAlgorithm(self,config=None):
        self.addParameter(
            QgsProcessingParameterFile(
                self.RESULTS_DIR,
                description=self.tr('Results directory'),
                behavior=QgsProcessingParameterFile.Folder))
        self.addParameter(
            QgsProcessingParameterRasterDestination(
                self.AGGR_CURR,
                self.tr("Aggregate current map")))
        self.addParameter(
            QgsProcessingParameterVectorDestination(
                self.AGGR_START,
                self.tr("Aggregate start points")))
                
    def processAlgorithm(self,parameters,context,feedback):
        # Parameters
        input_dir = self.parameterAsFile(parameters,self.RESULTS_DIR,context)
        aggr_curr = self.parameterAsOutputLayer(parameters, self.AGGR_CURR, context)
        aggr_start = self.parameterAsOutputLayer(parameters, self.AGGR_START, context)
        # Retrieve files
        files = os.listdir(input_dir)
        curr_maps = [os.path.join(input_dir,f) for f in files if f.endswith("_cum_curmap.asc")]
        start_layers = [os.path.join(input_dir,f) for f in files if f.endswith("_start.gpkg")]
        nb_curr_maps, nb_start_layers = len(curr_maps), len(start_layers)
        if nb_curr_maps != nb_start_layers:
            raise QgsProcessingException("Inconsistent number of maps : "
                + str(nb_curr_maps) + " current maps vs "
                + str(nb_start_layers) + " start points layers")
        if nb_curr_maps == 0:
            raise QgsProcessingException("No layers found in " + str(input_dir))
        # Aggregate current
        ACC = AggregateCirctuitscapeCurrentMaps
        parameters = { ACC.INPUT_LAYERS : curr_maps, ACC.OUTPUT : aggr_curr} 
        qgsTreatments.applyProcessingAlg('BioDispersal',ACC.ALG_NAME,parameters,
            context=context,feedback=feedback)
        # Aggregate start points
        layer = qgsUtils.loadVectorLayer(start_layers[0])
        crs = layer.crs()
        qgsTreatments.mergeVectorLayers(start_layers,crs,aggr_start,
            context=context,feedback=feedback)
        # Return
        return { self.AGGR_CURR : aggr_curr, self.AGGR_START : aggr_start }
    
        

class DistanceToBorderVector(IsolationAlgorithm):

    ALG_NAME = 'distanceToBorderVector'
    
    EXTENT = 'EXTENT'
    RESOLUTION = 'RESOLUTION'
    
    def displayName(self):
        return self.tr("Distance to borders (vector)")
        
    def shortHelpString(self):
        return self.tr("TODO")
        
    def initAlgorithm(self, config=None, report_opt=True):
        self.addParameter(QgsProcessingParameterMapLayer(
            self.INPUT,
            "Input landuse layer",
            types=[Qgis.Polygon]))
        self.addParameter(QgsProcessingParameterExtent(
            self.EXTENT,
            "Output extent"))
        self.addParameter(QgsProcessingParameterNumber(
            self.RESOLUTION,
            "Output resolution",
            defaultValue=10.0,
            type=QgsProcessingParameterNumber.Double))
        self.addParameter(QgsProcessingParameterRasterDestination(
            self.OUTPUT,
            self.tr("Output layer")))
            
    def processAlgorithm(self,parameters,context,feedback):
        input = self.parameterAsMapLayer(parameters,self.INPUT,context)
        if input is None:
            raise QgsProcessingException(self.invalidRasterError(parameters, self.INPUT))
        extent = self.parameterAsExtent(parameters,self.EXTENT,context)
        resolution = self.parameterAsDouble(parameters,self.RESOLUTION,context)
        output = self.parameterAsOutputLayer(parameters, self.OUTPUT, context)
        # Processing
        border_path = self.mkTmpPath('borders.gpkg')
        # type = 2 <=> LineString
        qgsTreatments.convertGeomType(input,2,border_path,context,feedback)
        border_raster_path = self.mkTmpPath('borders.tif')
        qgsTreatments.applyRasterization(border_path,border_raster_path,
            extent,resolution,burn_val=1,out_type=Qgis.Byte,
            context=context,feedback=feedback)

   

class DistanceToBorderRaster(IsolationAlgorithm):

    ALG_NAME = 'distanceToBorderRaster'
    
    def displayName(self):
        return self.tr("Distance to borders (Raster)")
        
    def shortHelpString(self):
        return self.tr("Distance for each pixel to patch border.")
        
    def initAlgorithm(self, config=None, report_opt=True):
        self.addParameter(QgsProcessingParameterRasterLayer(
            self.INPUT,
            "Input landuse layer"))
        self.addParameter(QgsProcessingParameterRasterDestination(
            self.OUTPUT,
            self.tr("Output layer")))
            
    def processAlgorithm(self,parameters,context,feedback):
        input = self.parameterAsRasterLayer(parameters,self.INPUT,context)
        if input is None:
            raise QgsProcessingException(self.invalidRasterError(parameters, self.INPUT))
        output = self.parameterAsOutputLayer(parameters, self.OUTPUT, context)
        # Processing
        extent = input.extent()
        input_nodata = input.dataProvider().sourceNoDataValue(1)
        unique_vals = qgsTreatments.getRasterUniqueVals(input,feedback)
        nb_vals = len(unique_vals)
        mf = QgsProcessingMultiStepFeedback(nb_vals * 2 + 2, feedback)
        prox_layers = []
        mf.pushDebugInfo("classes = " + str(unique_vals))
        for count, v in enumerate(unique_vals,start=0):
            classes = list(unique_vals)
            classes.remove(v)
            mf.pushDebugInfo("classes = " + str(classes))
            classes_str = ",".join([str(c) for c in classes])
            mf.pushDebugInfo("classes_str = " + str(classes_str))
            prox_v_path = self.mkTmpPath("proximity_" + str(v) + ".tif")
            qgsTreatments.applyProximity(input,prox_v_path,classes=classes_str,context=context,feedback=mf)
            mf.setCurrentStep(count * 2 + 1)
            prox_vnull_path = self.mkTmpPath("proximity_" + str(v) + "_null.tif")
            # expr_v = "logical_and(A != " + str(v) + ", A != " + str(input_nodata) + ") * B"
            # qgsTreatments.applyRasterCalcAB(input,prox_v_path,prox_vnull_path,expr_v,
                # nodata_val=0,context=context,feedback=mf)
            extract_params = { RasterSelectionByValue.INPUT : prox_v_path,
                RasterSelectionByValue.OPERATOR : 2,
                RasterSelectionByValue.VALUE : 0,
                RasterSelectionByValue.OUTPUT : prox_vnull_path
            }
            processing.run("BioDispersal:" + RasterSelectionByValue.ALG_NAME,
                extract_params,context=context,feedback=mf)
            prox_layers.append(prox_vnull_path)
            # qgsUtils.removeRaster(prox_v_path)
            mf.setCurrentStep(count * 2 + 2)
        min_prox_path = self.mkTmpPath("min_prox.tif")
        qgsTreatments.applyRSeries(prox_layers,4,min_prox_path,
            context=context,feedback=mf)
        mf.setCurrentStep(nb_vals+1)
        expr = "((A != " + str(input_nodata) + ") * B)"
        qgsTreatments.applyRasterCalcAB(input,min_prox_path,output,expr,
            nodata_val=0,context=context,feedback=mf)
        mf.setCurrentStep(nb_vals+2)
        return { self.OUTPUT : output }
        
        
   

class LabelPatches(IsolationAlgorithm):

    ALG_NAME = 'labelPatches'
    
    def displayName(self):
        return self.tr("Label patches")
        
    def shortHelpString(self):
        return self.tr("Patch labelling")
        
    def initAlgorithm(self, config=None, report_opt=True):
        self.addParameter(QgsProcessingParameterRasterLayer(
            self.INPUT,
            "Input layer"))
        self.addParameter(QgsProcessingParameterRasterDestination(
            self.OUTPUT,
            self.tr("Output layer")))
            
    def processAlgorithm(self,parameters,context,feedback):
        input = self.parameterAsRasterLayer(parameters,self.INPUT,context)
        if input is None:
            raise QgsProcessingException(self.invalidRasterError(parameters, self.INPUT))
        input_path = qgsUtils.pathOfLayer(input)
        output = self.parameterAsOutputLayer(parameters, self.OUTPUT, context)
        # Processing
        classes, array = qgsUtils.getRasterValsAndArray(input_path)
        mf = QgsProcessingMultiStepFeedback(len(classes), feedback)
        struct = scipy.ndimage.generate_binary_structure(2,1)
        res_array = np.zeros(array.shape)
        class_array = np.copy(array)
        prev_nb_patches = 0
        for count, c in enumerate(classes,start=1):
            # mf.pushDebugInfo("Labelling class " + str(c))
            class_array[array==c] = 1
            class_array[array!=c] = 0
            labeled_array, nb_patches = ndimage.label(class_array,struct)
            mf.pushDebugInfo("labeled_array = " + str(labeled_array))
            labeled_array[array==c] += prev_nb_patches
            mf.pushDebugInfo("labeled_array = " + str(labeled_array))
            tmp_path = self.mkTmpPath("labeled_" + str(c) + ".tif")
            # qgsUtils.exportRaster(res_array,input_path,tmp_path)
            res_array = np.add(res_array,labeled_array)
            mf.pushDebugInfo("res_array = " + str(res_array))
            prev_nb_patches += nb_patches
            mf.setCurrentStep(count)
        qgsUtils.exportRaster(res_array,input_path,output,nodata=0,type=gdal.GDT_UInt16)
        return {self.OUTPUT : output}
    

class PatchSizeRaster(IsolationAlgorithm):

    ALG_NAME = 'patchSizeRaster'
    LABELLED = 'LABELLED'
    
    def displayName(self):
        return self.tr("Patch size (Raster)")
        
    def shortHelpString(self):
        return self.tr("Computes patch size (pixel value = pixel patch size)")
        
    def initAlgorithm(self, config=None, report_opt=True):
        self.addParameter(QgsProcessingParameterRasterLayer(
            self.INPUT,
            "Input layer"))
        self.addParameter(
            QgsProcessingParameterBoolean(
                self.LABELLED,
                description = 'Input is already labelled',
                defaultValue=False,
                optional=True))
        self.addParameter(QgsProcessingParameterRasterDestination(
            self.OUTPUT,
            self.tr("Output layer")))
            
    def processAlgorithm(self,parameters,context,feedback):
        input = self.parameterAsRasterLayer(parameters,self.INPUT,context)
        if input is None:
            raise QgsProcessingException(self.invalidRasterError(parameters, self.INPUT))
        input_path = qgsUtils.pathOfLayer(input)
        is_labelled = self.parameterAsBool(parameters,self.LABELLED,context)
        output = self.parameterAsOutputLayer(parameters, self.OUTPUT, context)
        # Processing
        if is_labelled:
            labelled_path = input_path
        else:
            labelled_path = self.mkTmpPath("labelled.tif")
            label_params = { LabelPatches.INPUT : input, LabelPatches.OUTPUT : labelled_path }
            processing.run("BioDispersal:" + LabelPatches.ALG_NAME,
                label_params,context=context,feedback=feedback)
        classes, array = qgsUtils.getRasterValsAndArray(labelled_path)
        mf = QgsProcessingMultiStepFeedback(len(classes), feedback)
        res_array = np.zeros(array.shape)
        for count, c in enumerate(classes,start=1):
            mf.pushDebugInfo("Labelling class " + str(c))
            nb_pix = np.count_nonzero(array == c)
            res_array[array==c] = nb_pix
            mf.setCurrentStep(count)
        qgsUtils.exportRaster(res_array,input_path,output,nodata=0,type=gdal.GDT_UInt32)
        return {self.OUTPUT : output}
        

class NeighboursCount(IsolationAlgorithm):

    ALG_NAME = 'neigboursCount'
    
    def displayName(self):
        return self.tr("Neigbours count")
        
    def shortHelpString(self):
        return self.tr("Computes for each pixel the number of immediate neighbours of same value")
    
    def initAlgorithm(self, config=None, report_opt=True):
        self.addParameter(QgsProcessingParameterRasterLayer(
            self.INPUT,
            "Input layer"))
        self.addParameter(QgsProcessingParameterRasterDestination(
            self.OUTPUT,
            self.tr("Output layer")))
            
    def processAlgorithm(self,parameters,context,feedback):
        input = self.parameterAsRasterLayer(parameters,self.INPUT,context)
        if input is None:
            raise QgsProcessingException(self.invalidRasterError(parameters, self.INPUT))
        output = self.parameterAsOutputLayer(parameters, self.OUTPUT, context)
        # Processing
        in_path = qgsUtils.pathOfLayer(input)
        in_nodata = input.dataProvider().sourceNoDataValue(1)
        classes, array = qgsUtils.getRasterValsAndArray(in_path)
        struct = ndimage.generate_binary_structure(2,1)
        nb_neighbours_arr = ndimage.generic_filter(array,
            self.countNeighbours,footprint=struct, mode="constant",cval=in_nodata)
        qgsUtils.exportRaster(nb_neighbours_arr,input.source(),output)
        return {self.OUTPUT : output}
            
    def countNeighbours(self,array):
        cell_val = array[2]
        return np.count_nonzero(array == cell_val) - 1


class SlidingWindowCircle(IsolationAlgorithm):
    
    WINDOW_SIZE = 'WINDOW_SIZE'
    # METHOD = "METHOD"
    # METHODsel = ["mean", "sum","minimum","maximum","standard deviation","variance","median","variety"]
    MODE = "MODE"
    m = ["reflect", "constant", "nearest", "mirror", "wrap"]
    CLASSES_ORDER = "CLASSES_ORDER"
    OUTPUT_FILE = "OUTPUT"
    
    DEBUG_FIELDNAME = 'DEBUG'
    DEBUG = False
        
    def initAlgorithm(self, classes=False, config=None, report_opt=True):
        self.addParameter(QgsProcessingParameterRasterLayer(
            self.INPUT,
            "Input layer"))
        self.addParameter(
            QgsProcessingParameterNumber(
                self.WINDOW_SIZE,
                description = self.tr('Window size (pixels)'),
                type=QgsProcessingParameterNumber.Integer,
                defaultValue=5))
        # self.addParameter(
            # QgsProcessingParameterEnum(
                # self.MODE,
                # description = self.tr('Behaviour at Edges'),
                # options=self.m,
                # defaultValue=0))
        if classes:
            self.addParameter(
                QgsProcessingParameterString(
                    self.CLASSES_ORDER,
                    description = self.tr('Classes order (from unfavorable to very favorable)')))      
        self.addParameter(
            QgsProcessingParameterBoolean(
                self.DEBUG_FIELDNAME,
                description = self.tr('Print debug messages'),
                defaultValue=False,
                optional=True))
        self.addParameter(
            QgsProcessingParameterRasterDestination(
            self.OUTPUT,
            description = self.tr('Output layer')))
            
    def pushDebug(self,msg,feedback=None):
        feedback = feedback if feedback else self.feedback
        if self.DEBUG:
            feedback.pushDebugInfo(msg)
            
    def parseParams(self,parameters,context,feedback,classes=False):
        self.input = self.parameterAsRasterLayer(parameters,self.INPUT,context)
        if self.input is None:
            raise QgsProcessingException(self.invalidRasterError(parameters, self.INPUT))
        self.input_path = qgsUtils.pathOfLayer(self.input)
        self.size = self.parameterAsInt(parameters,self.WINDOW_SIZE,context)
        # mode = self.m[self.parameterAsEnum(parameters, self.MODE, context)]
        if classes:
            self.classes_order = self.parameterAsString(parameters,self.CLASSES_ORDER,context)
            feedback.pushDebugInfo("classes_order = " + str(self.classes_order)) 
            self.classes_ordered = [int(c) for c in self.classes_order.split(",")]
            feedback.pushDebugInfo("classes_ordered = " + str(self.classes_ordered))
            if not self.classes_ordered:
                raise QgsProcessingException("Please specify classes order (empty list)")
        self.DEBUG = self.parameterAsBool(parameters,self.DEBUG_FIELDNAME,context)
        self.output = self.parameterAsOutputLayer(parameters, self.OUTPUT, context)
        # Processing
        self.feedback = feedback
        self.nodata = self.input.dataProvider().sourceNoDataValue(1)
        feedback.pushDebugInfo("nodata = " + str(self.nodata))
        self.out_nodata = -1
        
    def prepareWindow(self,feedback=None):        
        self.array_size = self.size * 2 + 1
        self.val_idx = int((self.array_size + 1) / 2)
        self.pushDebug("val_idx = " + str(self.val_idx)) 
        self.dist_shape = (self.array_size, self.array_size)
        self.pushDebug("dist_shape = " + str(self.dist_shape)) 
        self.dist_array = np.fromfunction(self.distFromCenter,self.dist_shape)
        self.pushDebug("dist_array = " + str(self.dist_array))
        self.footprint = np.ones(self.dist_shape,dtype='bool')
        self.pushDebug("foot_shape = " + str(self.footprint.shape))
        self.footprint[self.dist_array > self.size] = False
        self.pushDebug("footprint = " + str(self.footprint))
        self.dist_array2 = self.dist_array[self.dist_array <= self.size]
        self.pushDebug("dist_array2 = " + str(self.dist_array2))
        nb_elem_footprint = np.count_nonzero(self.footprint != False)
        self.val_idx_footprint = int(nb_elem_footprint/2)
        self.dist_array[self.dist_array > self.size] = math.nan
        self.pushDebug("dist_array = " + str(self.dist_array))
        self.dist_array_flatten = self.dist_array2.flatten()
        self.pushDebug("self.dist_array_flatten = " + str(self.dist_array_flatten))
        # Computing immediate neighbours (4-connexity)
                    
    def distFromCenter(self,X,Y):
        self.pushDebug("X = " + str(X))
        self.pushDebug("Y = " + str(Y))
        return np.sqrt(((X.astype(int) - self.size) ** 2) + ((Y.astype(int) - self.size) ** 2))

    @abstractmethod
    def filter_func(self,array):
        pass
        

class SlidingWindowDistrib(SlidingWindowCircle):
    
    def initAlgorithm(self, classes=True, config=None, report_opt=True):
        SlidingWindowCircle.initAlgorithm(self,classes=True)
    
    def prepareClasses(self,classes,feedback):
        feedback.pushDebugInfo("classes = " + str(classes))
        excludeClasses = [c for c in classes if c not in self.classes_ordered]
        for c in excludeClasses:
            if c not in self.classes_ordered:
                feedback.pushWarning("Class " + str(c) + " order not specified")
        keepClasses = [c for c in self.classes_ordered if c in classes]
        feedback.pushDebugInfo("classes = " + str(keepClasses))
        keepClasses = keepClasses[1:] + keepClasses[:1]
        feedback.pushDebugInfo("classes = " + str(keepClasses))
        return keepClasses

    def processAlgorithm(self,parameters,context,feedback):
        self.parseParams(parameters,context,feedback,classes=True)
        self.prepareWindow(feedback)
        # Retrieve classes and array
        classes, array = qgsUtils.getRasterValsAndArray(str(self.input_path))
        classes = self.prepareClasses(classes,feedback)
        return self.processDistrib(array,classes,feedback)
        
    # def processDistrib(self,array,classes,feedback,classArray=None,neutralElem=-1):
        # Accumulating connexity class by class
        # acc_arr = np.zeros(array.shape)
        # curr_q3 = 0
        # nb_vals = len(classes)
        # feedback.pushDebugInfo("nb_vals = " + str(nb_vals))
        # classArray = array if classArray is None else classArray
        # for cpt, c in enumerate(classes,start=1):
            # feedback.pushDebugInfo("class = " + str(c))
            # feedback.pushDebugInfo("cpt = " + str(cpt))
            # tmp_arr = np.copy(array)
            # tmp_arr[classArray != c] = neutralElem
            # feedback.pushDebugInfo("neutralElem = " + str(neutralElem))
            # feedback.pushDebugInfo("tmp_arr.dtype = " + str(tmp_arr.dtype))
            # if self.DEBUG:
                # feedback.pushDebugInfo("tmp_arr = " + str(tmp_arr))
                # tmp_path = QgsProcessingUtils.generateTempFilename("tmp_" + str(c) + ".tif")
                # feedback.pushDebugInfo("tmp_path = " + str(tmp_path))
                # qgsUtils.exportRaster(tmp_arr,self.input_path,tmp_path,
                    # nodata=-1,type=gdal.GDT_Float32)
            # computed_arr = ndimage.generic_filter(tmp_arr,
                # self.filter_func,footprint=self.footprint,
                # mode="constant",cval=neutralElem,output=np.float32)
            # if self.DEBUG:
                # feedback.pushDebugInfo("computed_arr = " + str(computed_arr))
                # feedback.pushDebugInfo("computed_arr.dtype = " + str(computed_arr.dtype))
                # computed_c_path = QgsProcessingUtils.generateTempFilename("computed_" + str(c) + ".tif")
                # feedback.pushDebugInfo("computed_c_path = " + str(computed_c_path))
                # qgsUtils.exportRaster(computed_arr,self.input_path,computed_c_path,
                    # nodata=-1,type=gdal.GDT_Float32)
            # if cpt > 1:
                # computed_arr = np.add(computed_arr,curr_q3)
            # if cpt == nb_vals:
                # acc_arr /= computed_arr
            # else:
                # curr_q3 = np.quantile(computed_arr,q=0.75)
                # feedback.pushDebugInfo("curr_q3 = " + str(curr_q3))
                # acc_arr += computed_arr
            # if self.DEBUG:
                # acc_path = QgsProcessingUtils.generateTempFilename("acc_" + str(c) + ".tif")
                # feedback.pushDebugInfo("acc_path = " + str(acc_path))
                # qgsUtils.exportRaster(acc_arr,self.input_path,acc_path,
                    # nodata=-1,type=gdal.GDT_Float32)
                # feedback.pushDebugInfo("acc_arr = " + str(acc_arr))
        # qgsUtils.exportRaster(acc_arr,self.input_path,self.output,
            # nodata=self.out_nodata,type=gdal.GDT_Float32)
        # return { self.OUTPUT_FILE : self.output }
        


class MedianDistance(SlidingWindowCircle):

    ALG_NAME = 'medianDistance'
    
    def displayName(self):
        return self.tr("Median distance")
        
    def shortHelpString(self):
        return self.tr("Median distance to pixel of same values inside sliding window.")
        
    # def icon(self):
        # return QIcon(os.path.dirname(__file__) + os.sep+"icons"+os.sep+"img_neighboranalysis.png")

    def processAlgorithm(self,parameters,context,feedback):
        self.parseParams(parameters,context,feedback)
        self.prepareWindow(feedback)
        classes, array = qgsUtils.getRasterValsAndArray(str(self.input_path))
        feedback.pushDebugInfo("classes = " + str(classes))
        self.nb_vals = len(classes)
        # Computing immediate neighbours (4-connexity)
        feedback.pushDebugInfo("array shape = " + str(array.shape))
        # Encoding value with immediate neighbouts
        # new_arr = array * 10 + nb_neighbours_arr
        # feedback.pushDebugInfo("new_arr shape = " + str(new_arr.shape))
        res_arr = ndimage.generic_filter(array,
            self.filter_func,footprint=self.footprint,
            mode="constant",cval=0,output=np.float32)
        # Output
        qgsUtils.exportRaster(res_arr,self.input_path,self.output,
            nodata=self.out_nodata,type=gdal.GDT_Float32)
        # qgsUtils.exportRaster(result,self.input_path,output,
            # nodata=self.out_nodata,type=gdal.GDT_UInt16)
        return { self.OUTPUT_FILE : self.output }

    def filter_func(self,array):
        self.pushDebug("array = " + str(array))
        cell_val = array[self.val_idx_footprint]
        if cell_val == self.nodata:
            res = self.out_nodata
        else:
            self.pushDebug("cell_val = " + str(cell_val))
            dist_val = self.dist_array_flatten[array==cell_val]
            self.pushDebug("dist_val = " + str(dist_val))
            val_median = np.nanmedian(dist_val)
            res = val_median
        return res
        
    # def filterFuncDistrib(self,array):
        # cell_val = array[self.val_idx_footprint]
        # if cell_val == self.nodata:
            # res = self.out_nodata
        # else:
            # for c in self.classes_ordered:
                # dist_val = self.dist_array_flatten[array==c]
                # val_median = np.nanmedian(dist_val)
                
                
        
        

class PatchAreaWindow(SlidingWindowCircle):

    ALG_NAME = 'patchAreaWindow'
    
    def displayName(self):
        return self.tr("Patch area (Sliding Window)")
        
    def shortHelpString(self):
        return self.tr("Patch area inside sliding window")
        
    # def icon(self):
        # return QIcon(os.path.dirname(__file__) + os.sep+"icons"+os.sep+"img_neighboranalysis.png")

    def processAlgorithm(self,parameters,context,feedback):
        self.parseParams(parameters,context,feedback)
        self.prepareWindow(feedback)
        # Label input
        labelled_path = self.mkTmpPath("labelled.tif")
        label_params = { LabelPatches.INPUT : self.input,
            LabelPatches.OUTPUT : labelled_path }
        processing.run("BioDispersal:" + LabelPatches.ALG_NAME,
            label_params,context=context,feedback=feedback)
        # Processing on labelled array
        classes, array = qgsUtils.getRasterValsAndArray(str(labelled_path))
        # feedback.pushDebugInfo("classes = " + str(classes))
        # self.nb_vals = len(classes)
        # feedback.pushDebugInfo("labelled array  = " + str(array))
        feedback.pushDebugInfo("labelled array shape = " + str(array.shape))
        res_arr = ndimage.generic_filter(array,
            self.filter_func,footprint=self.footprint,
            mode="constant",cval=0,output=np.float32)
        # Output
        qgsUtils.exportRaster(res_arr,self.input_path,self.output,
            nodata=0,type=gdal.GDT_UInt32)
        # qgsUtils.exportRaster(result,self.input_path,output,
            # nodata=self.out_nodata,type=gdal.GDT_UInt16)
        return { self.OUTPUT_FILE : self.output }

    def filter_func(self,array):
        # self.feedback.pushDebugInfo("array = " + str(array))
        cell_val = array[self.val_idx_footprint]    
        # self.feedback.pushDebugInfo("cell_val = " + str(cell_val))
        res = np.count_nonzero(array[array == cell_val])
        # self.feedback.pushDebugInfo("res = " + str(res))
        return res



class AreaDistrib(SlidingWindowDistrib):

    ALG_NAME = 'areaWindowDistrib'
    
    def displayName(self):
        return self.tr("Area index")
        
    def shortHelpString(self):
        return self.tr("Area index (sliding window distribution)")
        
    # def icon(self):
        # return QIcon(os.path.dirname(__file__) + os.sep+"icons"+os.sep+"img_neighboranalysis.png")

    def processAlgorithm(self,parameters,context,feedback):
        self.parseParams(parameters,context,feedback,classes=True)
        self.prepareWindow(feedback)
        classes, array, input_nodata = qgsUtils.getRasterValsArrayND(str(self.input_path))
        classes = self.prepareClasses(classes,feedback)
        feedback.pushDebugInfo("classes = " + str(classes))
        self.nb_vals = len(classes)
        feedback.pushDebugInfo("array shape = " + str(array.shape))
        acc_arr = np.zeros(array.shape)
        acc_q3 = 0
        for cpt, c in enumerate(classes,start=1):
            feedback.pushDebugInfo("class = " + str(c))
            feedback.pushDebugInfo("cpt = " + str(cpt))
            self.currVal = c
            area_arr = ndimage.generic_filter(array,
                self.filter_func,footprint=self.footprint,
                mode="constant",cval=0,output=np.float32)
            if self.DEBUG:
                feedback.pushDebugInfo("area_arr = " + str(area_arr))
                feedback.pushDebugInfo("area_arr.dtype = " + str(area_arr.dtype))
                area_c_path = QgsProcessingUtils.generateTempFilename("area_" + str(c) + ".tif")
                feedback.pushDebugInfo("area_c_path = " + str(area_c_path))
                qgsUtils.exportRaster(area_arr,self.input_path,area_c_path,
                    nodata=-1,type=gdal.GDT_Int32)
            # area_arr[array==input_nodata] = math.nan
            # q3 = np.nanquantile(area_arr,q=0.75)
            # feedback.pushDebugInfo("q3 = " + str(q3))
            # area_arr[np.isnan(area_arr)] = 0
            area_arr = np.add(area_arr,acc_q3)
            if cpt == self.nb_vals:
                acc_arr /= area_arr
                # acc_arr = area_arr / acc_arr
            else:
                area_arr[array==input_nodata] = math.nan
                acc_q3 = np.nanquantile(area_arr,q=0.75)
                feedback.pushDebugInfo("acc_q3 = " + str(acc_q3))
                area_arr[array==input_nodata] = 0
                acc_arr += area_arr
                
                # acc_arr = np.add(acc_arr,area_arr)
                # acc_q3 += q3
                # feedback.pushDebugInfo("acc_q3 = " + str(acc_q3))
            self.pushDebug("acc_arr = " + str(acc_arr))
            if self.DEBUG:
                acc_path = QgsProcessingUtils.generateTempFilename("acc_" + str(c) + ".tif")
                feedback.pushDebugInfo("acc_path = " + str(acc_path))
                qgsUtils.exportRaster(acc_arr,self.input_path,acc_path,
                    nodata=self.out_nodata,type=gdal.GDT_Float32)
                feedback.pushDebugInfo("acc_arr = " + str(acc_arr))
        # Output
        acc_arr[array==input_nodata] = self.out_nodata
        self.pushDebug("acc_arr = " + str(acc_arr))
        qgsUtils.exportRaster(acc_arr,self.input_path,self.output,
            nodata=-1,type=gdal.GDT_Float32)
        # qgsUtils.exportRaster(result,self.input_path,output,
            # nodata=self.out_nodata,type=gdal.GDT_UInt16)
        return { self.OUTPUT_FILE : self.output }

    def filter_func(self,array):
        # self.feedback.pushDebugInfo("array = " + str(array))
        res = np.count_nonzero(array[array == self.currVal])
        # self.feedback.pushDebugInfo("res = " + str(res))
        return res
                


class MedianDistanceDistrib(SlidingWindowDistrib,MedianDistance):

    ALG_NAME = 'medianDistanceDistrib'
    
    def initAlgorithm(self, report_opt=True):
        SlidingWindowDistrib.initAlgorithm(self,classes=True)
    
    def displayName(self):
        return self.tr("Median distance (Distrib)")
        
    def shortHelpString(self):
        return self.tr("Computes median index. Index is obtained by redistributing median distances of each class value.")
    
    def filter_func(self,array):
        # self.pushDebug("array = " + str(array))
        # self.pushDebug("cell_val = " + str(self.currVal))
        dist_val = self.dist_array_flatten[array==self.currVal]
        # self.pushDebug("dist_val = " + str(dist_val))
        val_median = np.nanmedian(dist_val)
        # res = self.size if math.isnan(val_median) else self.size - val_median
        # return res
        return self.size - val_median
        
    def processDistrib(self,array,classes,feedback,classArray=None,neutralElem=math.nan):
        return SlidingWindowDistrib.processDistrib(self,array,
            classes,feedback,classArray=classArray,neutralElem=neutralElem)
        
    # def processAlgorithm(self,parameters,context,feedback):
        # return SlidingWindowDistrib.processAlgorithm(self,parameters,context,feedback)

    def processAlgorithm(self,parameters,context,feedback):
        self.parseParams(parameters,context,feedback,classes=True)
        self.prepareWindow(feedback)
        classes, array, input_nodata = qgsUtils.getRasterValsArrayND(str(self.input_path))
        classes = self.prepareClasses(classes,feedback)
        feedback.pushDebugInfo("classes = " + str(classes))
        self.nb_vals = len(classes)
        feedback.pushDebugInfo("array shape = " + str(array.shape))
        acc_arr = np.zeros(array.shape)
        acc_q3 = 0
        for cpt, c in enumerate(classes,start=1):
            feedback.pushDebugInfo("class = " + str(c))
            feedback.pushDebugInfo("cpt = " + str(cpt))
            # tmp_arr = np.copy(array)
            # tmp_arr[array != c] = -1
            self.currVal = c
            median_arr = ndimage.generic_filter(array,
                self.filter_func,footprint=self.footprint,
                mode="constant",cval=-1,output=np.float32)
            self.pushDebug("median_arr = " + str(median_arr))
            feedback.pushDebugInfo("median_arr.dtype = " + str(median_arr.dtype))
            if self.DEBUG:
                feedback.pushDebugInfo("median_arr = " + str(median_arr))
                feedback.pushDebugInfo("median_arr.dtype = " + str(median_arr.dtype))
                median_c_path = QgsProcessingUtils.generateTempFilename("median_" + str(c) + ".tif")
                feedback.pushDebugInfo("median_c_path = " + str(median_c_path))
                qgsUtils.exportRaster(median_arr,self.input_path,median_c_path,
                    nodata=-1,type=gdal.GDT_Float32)
            median_arr[array==input_nodata] = math.nan
            q3 = np.nanquantile(median_arr,q=0.75)
            feedback.pushDebugInfo("q3 = " + str(q3))
            # median_arr[array==input_nodata] = 0
            median_arr[np.isnan(median_arr)] = self.size
            self.pushDebug("median_arr nonan = " + str(median_arr))
            if cpt > 1:
                median_arr = np.add(median_arr,acc_q3)
            if cpt == self.nb_vals:
                # acc_arr /= median_arr
                acc_arr = median_arr / acc_arr
            else:
                acc_arr = np.add(acc_arr,median_arr)
                acc_q3 += q3
                feedback.pushDebugInfo("acc_q3 = " + str(acc_q3))
            self.pushDebug("acc_arr = " + str(acc_arr))
        acc_arr[array==input_nodata] = self.out_nodata
        self.pushDebug("acc_arr = " + str(acc_arr))
        qgsUtils.exportRaster(acc_arr,self.input_path,self.output,
            nodata=self.out_nodata,type=gdal.GDT_Float32)
        return { self.OUTPUT_FILE : self.output }
        
class MedianDistanceDistrib2(MedianDistance):

    ALG_NAME = 'medianDistanceDistrib2'
    
    def initAlgorithm(self, report_opt=True):
        super().initAlgorithm(classes=True)
    
    def displayName(self):
        return self.tr("Median distance (Distrib  2")
        
    def shortHelpString(self):
        return self.tr("TODO")
        
    def prepareClasses(self,classes,feedback):
        feedback.pushDebugInfo("classes = " + str(classes))
        excludeClasses = [c for c in classes if c not in self.classes_ordered]
        for c in excludeClasses:
            if c not in self.classes_ordered:
                feedback.pushWarning("Class " + str(c) + " order not specified")
        keepClasses = [c for c in self.classes_ordered if c in classes]
        feedback.pushDebugInfo("classes = " + str(keepClasses))
        keepClasses = keepClasses[1:] + keepClasses[:1]
        feedback.pushDebugInfo("classes = " + str(keepClasses))
        return keepClasses
        
    # def icon(self):
        # return QIcon(os.path.dirname(__file__) + os.sep+"icons"+os.sep+"img_neighboranalysis.png")

    def processAlgorithm(self,parameters,context,feedback):
        self.parseParams(parameters,context,feedback,classes=True)
        self.prepareWindow(feedback)
        # Retrieve classes and array
        classes, array = qgsUtils.getRasterValsAndArray(str(self.input_path))
        classes = self.prepareClasses(classes,feedback)
        feedback.pushDebugInfo("classes = " + str(classes))
        self.nb_vals = len(classes)
        feedback.pushDebugInfo("array shape = " + str(array.shape))
        # Main loop
        acc_arr = np.zeros(array.shape)
        curr_q3 = 0
        for cpt, c in enumerate(classes,start=1):
            feedback.pushDebugInfo("class = " + str(c))
            feedback.pushDebugInfo("cpt = " + str(cpt))
            tmp_arr = np.copy(array)
            tmp_arr[array != c] = -1
            median_arr = ndimage.generic_filter(tmp_arr,
                self.filter_func,footprint=self.footprint,
                mode="constant",cval=math.nan,output=np.float32)
            feedback.pushDebugInfo("median_arr = " + str(median_arr))
            feedback.pushDebugInfo("median_arr.dtype = " + str(median_arr.dtype))
            if cpt > 1:
                median_arr = np.add(median_arr,curr_q3)
            if cpt == self.nb_vals:
                acc_arr /= median_arr
            else:
                curr_q3 = np.quantile(median_arr,q=0.75)
                feedback.pushDebugInfo("curr_q3 = " + str(curr_q3))
                acc_arr += median_arr
        # Output
        qgsUtils.exportRaster(acc_arr,self.input_path,self.output,
            nodata=self.out_nodata,type=gdal.GDT_Float32)
        # qgsUtils.exportRaster(result,self.input_path,output,
            # nodata=self.out_nodata,type=gdal.GDT_UInt16)
        return { self.OUTPUT_FILE : self.output }

class NbContactDistrib(SlidingWindowDistrib):

    ALG_NAME = 'NbContactDistrib'
    
    FILTER_FUNC = 'FILTER_FUNC'
    FUNCS = ['sum','nansum','nanmean']
    filter_funcs = [np.sum,np.nansum,np.nanmean]
    
    def initAlgorithm(self, report_opt=True):
        SlidingWindowDistrib.initAlgorithm(self,classes=True)
        self.addParameter(
            QgsProcessingParameterEnum(
                self.FILTER_FUNC,
                description = self.tr('Filter function'),
                options=self.FUNCS,
                defaultValue=0))
        
    def displayName(self):
        return self.tr("Number of contacts (distrib)")
        
    def shortHelpString(self):
        return self.tr("Computes number of contacts (adjacent pixels of same value) in sliding window")
        
    # def icon(self):
        # return QIcon(os.path.dirname(__file__) + os.sep+"icons"+os.sep+"img_neighboranalysis.png")
        
    # def rolling_window(self, a, window_size):
        # shape = (a.shape[0] - window_size + 1, window_size) + a.shape[1:]
        # strides = (a.strides[0],) + a.strides
        # return np.lib.stride_tricks.as_strided(a, shape=shape, strides=strides)
        
    def processAlgorithm(self,parameters,context,feedback):
        self.parseParams(parameters,context,feedback,classes=True)
        func_mode = self.parameterAsEnum(parameters,self.FILTER_FUNC,context)
        filter_func = self.filter_funcs[func_mode]
        # neutralElem = math.nan if func_mode == 2 else 0
        self.prepareWindow(feedback)
        # Retrieve classes and array
        classes, array, input_nodata = qgsUtils.getRasterValsArrayND(str(self.input_path))
        ncount_struct = ndimage.generate_binary_structure(2,1)
        classes = self.prepareClasses(classes,feedback)
        nb_neighbours_arr = ndimage.generic_filter(array,
            self.count_neighbours_4,footprint=ncount_struct,
            mode="constant",cval=self.nodata)
        feedback.pushDebugInfo("nb_neighbours_arr shape = " + str(nb_neighbours_arr.shape))
        if self.DEBUG:
            self.feedback.pushDebugInfo("array = " + str(array))
            feedback.pushDebugInfo("nb_neighbours_arr = " + str(nb_neighbours_arr))
        # Process distrb
        acc_arr = np.zeros(array.shape)
        curr_q3 = 0
        nb_vals = len(classes)
        feedback.pushDebugInfo("nb_vals = " + str(nb_vals))
        neutralElem = 0
        feedback.pushDebugInfo("neutralElem = " + str(neutralElem))
        for cpt, c in enumerate(classes,start=1):
            feedback.pushDebugInfo("class = " + str(c))
            feedback.pushDebugInfo("cpt = " + str(cpt))
            tmp_arr = nb_neighbours_arr.astype(np.float)
            tmp_arr[array != c] = neutralElem
            tmp_arr[array==input_nodata] = math.nan
            feedback.pushDebugInfo("tmp_arr.dtype = " + str(tmp_arr.dtype))
            if self.DEBUG:
                feedback.pushDebugInfo("tmp_arr = " + str(tmp_arr))
                tmp_path = QgsProcessingUtils.generateTempFilename("tmp_" + str(c) + ".tif")
                feedback.pushDebugInfo("tmp_path = " + str(tmp_path))
                qgsUtils.exportRaster(tmp_arr,self.input_path,tmp_path,
                    nodata=0,type=gdal.GDT_Float32)
            computed_arr = ndimage.generic_filter(tmp_arr,
                filter_func,footprint=self.footprint,
                mode="constant",cval=math.nan,output=np.float32)
            # computed_arr = ndimage.generic_filter(tmp_arr,
                # self.filter_func,footprint=self.footprint,
                # mode='nearest',output=np.float32)
            if self.DEBUG:
                feedback.pushDebugInfo("computed_arr = " + str(computed_arr))
                feedback.pushDebugInfo("computed_arr.dtype = " + str(computed_arr.dtype))
                computed_c_path = QgsProcessingUtils.generateTempFilename(
                    "computed_" + str(c) + ".tif")
                feedback.pushDebugInfo("computed_c_path = " + str(computed_c_path))
                qgsUtils.exportRaster(computed_arr,self.input_path,computed_c_path,
                    nodata=0,type=gdal.GDT_Float32)
            if cpt > 1:
                computed_arr = np.add(computed_arr,curr_q3)
            if cpt == nb_vals:
                #et donc si computed = 0 ???
                # Comment 0 possible avec curr_q3 ?
                acc_arr /= computed_arr
            else:
                computed_arr[array==input_nodata] = math.nan
                # computed_arr[array==input_nodata] = neutralElem
                curr_q3 = np.nanquantile(computed_arr,q=0.75)
                feedback.pushDebugInfo("curr_q3 = " + str(curr_q3))
                computed_arr[array==input_nodata] = neutralElem
                acc_arr += computed_arr
            if self.DEBUG:
                acc_path = QgsProcessingUtils.generateTempFilename("acc_" + str(c) + ".tif")
                feedback.pushDebugInfo("acc_path = " + str(acc_path))
                qgsUtils.exportRaster(acc_arr,self.input_path,acc_path,
                    nodata=self.out_nodata,type=gdal.GDT_Float32)
                feedback.pushDebugInfo("acc_arr = " + str(acc_arr))
        # Output
        feedback.pushDebugInfo("out_nodata = " + str(self.out_nodata))
        acc_arr[array==input_nodata] = self.out_nodata
        feedback.pushDebugInfo("acc_arr = " + str(acc_arr))
        qgsUtils.exportRaster(acc_arr,self.input_path,self.output,
            nodata=self.out_nodata,type=gdal.GDT_Float32)
        return { self.OUTPUT_FILE : self.output }
        # return self.processDistrib(nb_neighbours_arr,classes,feedback,
                    # classArray=array,neutralElem=0)
    
    def filter_func_sum(self,array):
        # if self.DEBUG:
            # self.feedback.pushDebugInfo("arrayFilt = " + str(array))
        return np.nansum(array)
    def filter_func_mean(self,array):
        # if self.DEBUG:
            # self.feedback.pushDebugInfo("arrayFilt = " + str(array))
        return np.nanmean(array)
        
            
    # def processAlgorithm(self,parameters,context,feedback):
        # self.parseParams(parameters,context,feedback)
        # self.prepareWindow(feedback)
        # classes, array = qgsUtils.getRasterValsAndArray(str(self.input_path))
        # feedback.pushDebugInfo("classes = " + str(classes))
        # self.nb_vals = len(classes)
        # Computing immediate neighbours (4-connexity)
        # feedback.pushDebugInfo("array shape = " + str(array.shape))
        # ncount_struct = ndimage.generate_binary_structure(2,1)
        # nb_neighbours_arr = ndimage.generic_filter(array,
            # self.count_neighbours_4,footprint=ncount_struct,
            # mode="constant",cval=self.nodata)
        # feedback.pushDebugInfo("nb_neighbours_arr shape = " + str(nb_neighbours_arr.shape))
        # Accumulating connexity class by class
        # acc_arr = np.zeros(array.shape)
        # curr_q3 = 0
        # feedback.pushDebugInfo("nb_vals = " + str(self.nb_vals))
        # classes_reshaped = classes[1:] + [classes[0]]
        # feedback.pushDebugInfo("classes_reshaped = " + str(classes_reshaped))
        # for cpt, c in enumerate(classes_reshaped,start=1):
            # feedback.pushDebugInfo("class = " + str(c))
            # feedback.pushDebugInfo("cpt = " + str(cpt))
            # tmp_arr = np.copy(nb_neighbours_arr)
            # tmp_arr[array != c] = 0
            # feedback.pushDebugInfo("tmp_arr.dtype = " + str(tmp_arr.dtype))
            # if self.DEBUG:
                # tmp_path = QgsProcessingUtils.generateTempFilename("tmp_" + str(c) + ".tif")
                # feedback.pushDebugInfo("tmp_path = " + str(tmp_path))
                # qgsUtils.exportRaster(tmp_arr,self.input_path,tmp_path,
                    # nodata=-1,type=gdal.GDT_Float32)
            # nb_contact_arr = ndimage.generic_filter(tmp_arr,
                # np.sum,footprint=self.footprint,
                # mode="constant",cval=0,output=np.float32)
            # if self.DEBUG:
                # feedback.pushDebugInfo("nb_contact_arr = " + str(nb_contact_arr))
                # feedback.pushDebugInfo("nb_contact_arr.dtype = " + str(nb_contact_arr.dtype))
                # nb_c_path = QgsProcessingUtils.generateTempFilename("nb_contact_" + str(c) + ".tif")
                # feedback.pushDebugInfo("nb_c_path = " + str(nb_c_path))
                # qgsUtils.exportRaster(nb_contact_arr,self.input_path,nb_c_path,
                    # nodata=-1,type=gdal.GDT_Float32)
            # if cpt > 1:
                # nb_contact_arr = np.add(nb_contact_arr,curr_q3)
            # if cpt == self.nb_vals:
                # acc_arr /= nb_contact_arr
            # else:
                # curr_q3 = np.quantile(nb_contact_arr,q=0.75)
                # feedback.pushDebugInfo("curr_q3 = " + str(curr_q3))
                # acc_arr += nb_contact_arr
            # if self.DEBUG:
                # acc_path = QgsProcessingUtils.generateTempFilename("acc_" + str(c) + ".tif")
                # feedback.pushDebugInfo("acc_path = " + str(acc_path))
                # qgsUtils.exportRaster(acc_arr,self.input_path,acc_path,
                    # nodata=-1,type=gdal.GDT_Float32)
                # feedback.pushDebugInfo("acc_arr = " + str(acc_arr))
        # Output
        # qgsUtils.exportRaster(acc_arr,self.input_path,self.output,
            # nodata=self.out_nodata,type=gdal.GDT_Float32)
        # return { self.OUTPUT_FILE : self.output }
                
    def count_neighbours_4(self,array):
        cell_val = array[2]
        return np.count_nonzero(array == cell_val) - 1
        
    # def count_neighbours_decode(self,array):
        # res = {}
        # center_val = array[self.val_idx_footprint]
        # center_val = (center_val - (center_val % 10)) / 10
        # for cpt, a in enumerate(array):
            # neigbours = a % 10
            # val = (a - neigbours) / 10
            # if val in res:
                # res[val] += neigbours
            # else:
                # res[val] = neigbours
        # return res[center_val]

    # def contact_count(self,array):
        # cell_val = array[self.val_idx]
        # array[array!= cell_val] = 0
        # array[self.footprint_flatten != 0] = 0
        # reshaped = np.reshape(array,self.dist_shape)
        # struct = ndimage.generate_binary_structure(2,1)
        
        # nb_neighbours_arr = ndimage.generic_filter(reshaped,
            # self.contact_count_aux,footprint=struct, mode="constant")
        # res = nb_neighbours_arr[reshaped==cell_val].sum()
        # return res
        # return cell_val
        # for cpt, c in enumerate(self.classes):
            # res[cpt] = nb_neighbours_arr[reshaped==c].sum()
        # return res[0]
        
    # def contact_count_aux(self,array):
        # cell_val = array[2]
        # return np.count_nonzero(array == cell_val) - 1

    # Return number of unique classes
    # def connexity_index(self,array):
        # cell_val = array[self.val_idx]
        # if cell_val == self.nodata:
            # res = self.out_nodata
        # else:
            # dist_val = self.dist_array2[array==cell_val]
            # val_median = np.nanmedian(dist_val)
            # self.feedback.pushDebugInfo("val_median = " + str(val_median))
            # dist_noval = self.dist_array2[array!=cell_val]
            # noval_median = float(np.nanmedian(dist_noval))
            # self.feedback.pushDebugInfo("noval_median = " + str(noval_median))
            # if val_median == 0:
                # self.feedback.pushDebugInfo("array = " + str(array))
                # assert(False)
            # if noval_median == 0 or math.isnan(noval_median):
                # res = val_median
            # else:
                # res = noval_median / val_median
        # self.feedback.pushDebugInfo("res = " + str(res))
        # return res
        
class NbContactMedianDistrib(NbContactDistrib):

    ALG_NAME = 'NbContactMedianDistrib'
        
    def displayName(self):
        return self.tr("Number of contacts x Median distance (distrib)")
        
    def shortHelpString(self):
        return self.tr("Computes connexity index")    
        
    def filter_median(self,array):
        # self.pushDebug("array = " + str(array))
        # self.pushDebug("cell_val = " + str(self.currVal))
        dist_val = self.dist_array_flatten[array==self.currVal]
        # self.pushDebug("dist_val = " + str(dist_val))
        val_median = np.nanmedian(dist_val)
        # res = self.size if math.isnan(val_median) else self.size - val_median
        # return res
        return val_median
        
    def filter_nbContact_distance(self,array):
        cell_val = array[2]
        div_arr = array[array == cell_val] / self.dist_array_flatten[array == cell_val]
        return self.filter_func(div_arr)

    def processAlgorithm(self,parameters,context,feedback):
        self.parseParams(parameters,context,feedback,classes=True)
        func_mode = self.parameterAsEnum(parameters,self.FILTER_FUNC,context)
        self.filter_func = self.filter_funcs[func_mode]
        # neutralElem = math.nan if func_mode == 2 else 0
        self.prepareWindow(feedback)
        # Retrieve classes and array
        classes, array, input_nodata = qgsUtils.getRasterValsArrayND(str(self.input_path))
        ncount_struct = ndimage.generate_binary_structure(2,1)
        classes = self.prepareClasses(classes,feedback)
        nb_neighbours_arr = ndimage.generic_filter(array,
            self.count_neighbours_4,footprint=ncount_struct,
            mode="constant",cval=self.nodata)
        feedback.pushDebugInfo("nb_neighbours_arr shape = " + str(nb_neighbours_arr.shape))
        if self.DEBUG:
            self.feedback.pushDebugInfo("array = " + str(array))
            feedback.pushDebugInfo("nb_neighbours_arr = " + str(nb_neighbours_arr))
        # Process distrb
        acc_arr = np.zeros(array.shape)
        curr_q3 = 0
        nb_vals = len(classes)
        feedback.pushDebugInfo("nb_vals = " + str(nb_vals))
        neutralElem = 0
        feedback.pushDebugInfo("neutralElem = " + str(neutralElem))
        for cpt, c in enumerate(classes,start=1):
            feedback.pushDebugInfo("class = " + str(c))
            feedback.pushDebugInfo("cpt = " + str(cpt))
            self.currVal = c
            tmp_arr = nb_neighbours_arr.astype(np.float)
            tmp_arr[array != c] = neutralElem
            tmp_arr[array==input_nodata] = math.nan
            feedback.pushDebugInfo("tmp_arr.dtype = " + str(tmp_arr.dtype))
            if self.DEBUG:
                feedback.pushDebugInfo("tmp_arr = " + str(tmp_arr))
                tmp_path = QgsProcessingUtils.generateTempFilename("tmp_" + str(c) + ".tif")
                feedback.pushDebugInfo("tmp_path = " + str(tmp_path))
                qgsUtils.exportRaster(tmp_arr,self.input_path,tmp_path,
                    nodata=self.out_nodata,type=gdal.GDT_Float32)
            computed_arr = ndimage.generic_filter(tmp_arr,
                self.filter_nbContact_distance,footprint=self.footprint,
                mode="constant",cval=math.nan,output=np.float32)
            # median_arr = ndimage.generic_filter(array,
                # self.filter_median,footprint=self.footprint,
                # mode="constant",cval=-1,output=np.float32)
            # median_arr[np.isnan(median_arr)] = 0
            # computed_arr = computed_arr * median_arr
            # computed_arr = ndimage.generic_filter(tmp_arr,
                # self.filter_func,footprint=self.footprint,
                # mode='nearest',output=np.float32)
            if self.DEBUG:
                feedback.pushDebugInfo("computed_arr = " + str(computed_arr))
                feedback.pushDebugInfo("computed_arr.dtype = " + str(computed_arr.dtype))
                computed_c_path = QgsProcessingUtils.generateTempFilename(
                    "computed_" + str(c) + ".tif")
                feedback.pushDebugInfo("computed_c_path = " + str(computed_c_path))
                qgsUtils.exportRaster(computed_arr,self.input_path,computed_c_path,
                    nodata=self.out_nodata,type=gdal.GDT_Float32)
            if cpt > 1:
                computed_arr = np.add(computed_arr,curr_q3)
            if cpt == nb_vals:
                #et donc si computed = 0 ???
                # Comment 0 possible avec curr_q3 ?
                acc_arr /= computed_arr
            else:
                computed_arr[array==input_nodata] = math.nan
                # computed_arr[array==input_nodata] = neutralElem
                curr_q3 = np.nanquantile(computed_arr,q=0.75)
                feedback.pushDebugInfo("curr_q3 = " + str(curr_q3))
                computed_arr[array==input_nodata] = neutralElem
                acc_arr += computed_arr
            if self.DEBUG:
                acc_path = QgsProcessingUtils.generateTempFilename("acc_" + str(c) + ".tif")
                feedback.pushDebugInfo("acc_path = " + str(acc_path))
                qgsUtils.exportRaster(acc_arr,self.input_path,acc_path,
                    nodata=self.out_nodata,type=gdal.GDT_Float32)
                feedback.pushDebugInfo("acc_arr = " + str(acc_arr))
        # Output
        feedback.pushDebugInfo("out_nodata = " + str(self.out_nodata))
        acc_arr[array==input_nodata] = self.out_nodata
        feedback.pushDebugInfo("acc_arr = " + str(acc_arr))
        qgsUtils.exportRaster(acc_arr,self.input_path,self.output,
            nodata=self.out_nodata,type=gdal.GDT_Float32)
        return { self.OUTPUT_FILE : self.output }
        
class RelativeSurface(QualifAlgorithm):

    ALG_NAME = 'RelativeSurface'
    
    LAYER_A = 'LAYER_A'
    LAYER_B = 'LAYER_B'
    
    def displayName(self):
        return self.tr("Relative surface")
        
    def shortHelpString(self):
        return self.tr("Relative surface (percentage of B surface in each patch of layer A)")
    
    def initAlgorithm(self, config=None):
        self.addParameter(
            QgsProcessingParameterFeatureSource(
                self.LAYER_A,
                description=self.tr('Layer A')))
        self.addParameter(
            QgsProcessingParameterFeatureSource(
                self.LAYER_B,
                description=self.tr('Layer B')))
        self.addParameter(
            QgsProcessingParameterFeatureSink(
                self.OUTPUT,
                self.tr("Output layer")))
                
    def processAlgorithm(self,parameters,context,feedback):
        layerA = self.parameterAsVectorLayer(parameters,self.LAYER_A,context)
        if layerA is None:
            raise QgsProcessingException(self.invalidSourceError(parameters, self.LAYER_A))
        layerB = self.parameterAsVectorLayer(parameters,self.LAYER_B,context)
        if layerB is None:
            raise QgsProcessingException(self.invalidSourceError(parameters, self.LAYER_B))
        # Processing : todo intersection
        pass
        
    